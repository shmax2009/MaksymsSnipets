<templateSet group="user">
  <template name=".BigInt" value="class Bigint {&#10;private:&#10;    std::vector&lt;int&gt; number;&#10;    bool positive;&#10;    int base;&#10;    unsigned int skip;&#10;    static const int default_base = 1000000000;&#10;&#10;public:&#10;    //Constructors&#10;    Bigint() {&#10;        positive = true;&#10;        base = Bigint::default_base;&#10;        skip = 0;&#10;    }&#10;    Bigint(long long value) {&#10;        base = Bigint::default_base;&#10;        skip = 0;&#10;        if (value &lt; 0) {&#10;            positive = false;&#10;            value *= -1;&#10;        } else {&#10;            positive = true;&#10;        }&#10;&#10;        while (value) {&#10;            number.push_back((int) (value % base));&#10;            value /= base;&#10;        }&#10;    }&#10;    Bigint(std::string stringInteger) {&#10;        int size = stringInteger.length();&#10;&#10;        base = Bigint::default_base;&#10;        skip = 0;&#10;        positive = (stringInteger[0] != '-');&#10;&#10;        while (true) {&#10;            if (size &lt;= 0) break;&#10;            if (!positive &amp;&amp; size &lt;= 1) break;&#10;&#10;            int length = 0;&#10;            int num = 0;&#10;            int prefix = 1;&#10;            for (int i(size - 1); i &gt;= 0 &amp;&amp; i &gt;= size - 9; --i) {&#10;                if (stringInteger[i] &lt; '0' || stringInteger[i] &gt; '9') break;&#10;                num += (stringInteger[i] - '0') * prefix;&#10;                prefix *= 10;&#10;                ++length;&#10;            }&#10;            number.push_back(num);&#10;            size -= length;&#10;        }&#10;    }&#10;    Bigint(const Bigint &amp;b) = default;&#10;&#10;    //Adding&#10;    Bigint operator+(Bigint const &amp;) const;&#10;    Bigint &amp;operator+=(Bigint const &amp;);&#10;    Bigint operator+(long long const &amp;) const;&#10;    Bigint &amp;operator+=(long long);&#10;&#10;    //Subtraction&#10;    Bigint operator-(Bigint const &amp;) const;&#10;    Bigint &amp;operator-=(Bigint const &amp;);&#10;&#10;    //Multiplication&#10;    Bigint operator*(Bigint const &amp;);&#10;    Bigint &amp;operator*=(Bigint const &amp;);&#10;    Bigint operator*(long long const &amp;);&#10;    Bigint &amp;operator*=(int const &amp;);&#10;&#10;    //Compare&#10;    bool operator&lt;(const Bigint &amp;) const;&#10;    bool operator&gt;(const Bigint &amp;) const;&#10;    bool operator&lt;=(const Bigint &amp;) const;&#10;    bool operator&gt;=(const Bigint &amp;) const;&#10;    bool operator==(const Bigint &amp;) const;&#10;    bool operator!=(const Bigint &amp;) const;&#10;&#10;    //Allocation&#10;    Bigint &amp;operator=(const long long &amp;);&#10;&#10;    //Access&#10;    int operator[](int const &amp;) const;&#10;&#10;    //Input&amp;Output&#10;    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;, Bigint &amp;);&#10;    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, Bigint const &amp;);&#10;&#10;    //Helpers&#10;    void clear();&#10;    Bigint &amp;abs();&#10;&#10;    //Power&#10;    Bigint &amp;pow(int const &amp;);&#10;&#10;    //Trivia&#10;    int digits() const;&#10;    int trailing_zeros() const;&#10;&#10;private:&#10;    static int segment_length(int);&#10;    Bigint pow(int const &amp;, std::map&lt;int, Bigint&gt; &amp;);&#10;    int compare(Bigint const &amp;) const;//0 a == b, -1 a &lt; b, 1 a &gt; b&#10;};&#10;&#10;Bigint abs(Bigint);&#10;std::string to_string(Bigint const &amp;);&#10;Bigint factorial(int);&#10;&#10;//Constructor&#10;&#10;&#10;//Adding&#10;Bigint Bigint::operator+(Bigint const &amp;b) const {&#10;    Bigint c = *this;&#10;    c += b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator+=(Bigint const &amp;b) {&#10;    if (!b.positive) {&#10;        return *this -= b;&#10;    }&#10;    std::vector&lt;int&gt;::iterator&#10;            it1 = number.begin();&#10;    std::vector&lt;int&gt;::const_iterator&#10;            it2 = b.number.begin();&#10;    int sum = 0;&#10;    while (it1 != number.end() || it2 != b.number.end()) {&#10;        if (it1 != number.end()) {&#10;            sum += *it1;&#10;        } else {&#10;            number.push_back(0);&#10;            it1 = number.end() - 1;&#10;        }&#10;        if (it2 != b.number.end()) {&#10;            sum += *it2;&#10;            ++it2;&#10;        }&#10;        *it1 = sum % base;&#10;        ++it1;&#10;        sum /= base;&#10;    }&#10;    if (sum) number.push_back(1);&#10;&#10;    return *this;&#10;}&#10;&#10;Bigint Bigint::operator+(long long const &amp;b) const {&#10;    Bigint c = *this;&#10;    c += b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator+=(long long b) {&#10;    std::vector&lt;int&gt;::iterator it = number.begin();&#10;    if (skip &gt; number.size()) {&#10;        number.insert(number.end(), skip - number.size(), 0);&#10;    }&#10;    it += skip;&#10;    bool initial_flag = true;&#10;    while (b || initial_flag) {&#10;        initial_flag = false;&#10;        if (it != number.end()) {&#10;            *it += b % base;&#10;            b /= base;&#10;            b += *it / base;&#10;            *it %= base;&#10;            ++it;&#10;        } else {&#10;            number.push_back(0);&#10;            it = number.end() - 1;&#10;        }&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;//Subtraction&#10;Bigint Bigint::operator-(Bigint const &amp;b) const {&#10;    Bigint c = *this;&#10;    c -= b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator-=(Bigint const &amp;b) {&#10;    std::vector&lt;int&gt;::iterator&#10;            it1 = number.begin();&#10;    std::vector&lt;int&gt;::const_iterator&#10;            it2 = b.number.begin();&#10;    int dif = 0;&#10;    while (it1 != number.end() || it2 != b.number.end()) {&#10;        if (it1 != number.end()) {&#10;            dif += *it1;&#10;            ++it1;&#10;        }&#10;        if (it2 != b.number.end()) {&#10;            dif -= *it2;&#10;            ++it2;&#10;        }&#10;        if (dif &lt; 0) {&#10;            *(it1 - 1) = dif + base;&#10;            dif = -1;&#10;        } else {&#10;            *(it1 - 1) = dif % base;&#10;            dif /= base;&#10;        }&#10;    }&#10;    if (dif &lt; 0) positive = false;&#10;&#10;    if (number.size() &gt; 1) {&#10;        do {&#10;            it1 = number.end() - 1;&#10;            if (*it1 == 0) number.pop_back();&#10;            else&#10;                break;&#10;        } while (number.size() &gt; 1);&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;//Multiplication&#10;Bigint Bigint::operator*(Bigint const &amp;b) {&#10;    if (b.number.size() == 1) return *this *= b.number[0];&#10;    std::vector&lt;int&gt;::iterator it1;&#10;    std::vector&lt;int&gt;::const_iterator it2;&#10;    Bigint c;&#10;    for (it1 = number.begin(); it1 != number.end(); ++it1) {&#10;        for (it2 = b.number.begin(); it2 != b.number.end(); ++it2) {&#10;            c.skip = (unsigned int) (it1 - number.begin()) + (it2 - b.number.begin());//TODO&#10;            c += (long long) (*it1) * (*it2);&#10;        }&#10;    }&#10;    c.skip = 0;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator*=(Bigint const &amp;b) {&#10;    *this = *this * b;&#10;&#10;    return *this;&#10;}&#10;&#10;Bigint Bigint::operator*(long long const &amp;b) {&#10;    Bigint c = *this;&#10;    c *= b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator*=(int const &amp;b) {&#10;    auto it = number.begin();&#10;    long long sum = 0;&#10;    while (it != number.end()) {&#10;        sum += (long long) (*it) * b;&#10;        *it = (int) (sum % base);&#10;        sum /= base;&#10;        ++it;&#10;    }&#10;    if (sum) number.push_back((int) sum);&#10;&#10;    return *this;&#10;}&#10;&#10;//Power&#10;Bigint Bigint::pow(int const &amp;power, std::map&lt;int, Bigint&gt; &amp;lookup) {&#10;    if (power == 1) return *this;&#10;    if (lookup.count(power)) return lookup[power];&#10;&#10;    int closestPower = 1;&#10;    while (closestPower &lt; power) closestPower &lt;&lt;= 1;&#10;    closestPower &gt;&gt;= 1;&#10;&#10;    if (power == closestPower) lookup[power] = pow(power / 2, lookup) * pow(power / 2, lookup);&#10;    else&#10;        lookup[power] = pow(closestPower, lookup) * pow(power - closestPower, lookup);&#10;&#10;    return lookup[power];&#10;}&#10;&#10;Bigint &amp;Bigint::pow(int const &amp;power) {&#10;    std::map&lt;int, Bigint&gt; lookup;&#10;    if (power % 2 == 0 &amp;&amp; !positive) {&#10;        positive = true;&#10;    }&#10;    *this = pow(power, lookup);&#10;&#10;    return *this;&#10;}&#10;&#10;//Compare&#10;int Bigint::compare(const Bigint &amp;a) const//0 this == a || -1 this &lt; a || 1 this &gt; a&#10;{&#10;    if (positive &amp;&amp; !a.positive) return 1;&#10;    if (!positive &amp;&amp; a.positive) return -1;&#10;&#10;    int check = 1;&#10;    if (!positive &amp;&amp; !a.positive) check = -1;&#10;&#10;    if (number.size() &lt; a.number.size()) return -1 * check;&#10;    if (number.size() &gt; a.number.size()) return check;&#10;    for (size_t i(number.size()); i &gt; 0; --i) {&#10;        if (number[i - 1] &lt; a.number[i - 1]) return -1 * check;&#10;        if (number[i - 1] &gt; a.number[i - 1]) return check;&#10;    }&#10;&#10;    return 0;// ==&#10;}&#10;&#10;bool Bigint::operator&lt;(Bigint const &amp;b) const {&#10;    return compare(b) == -1;&#10;}&#10;&#10;bool Bigint::operator&lt;=(const Bigint &amp;b) const {&#10;    int compared = compare(b);&#10;&#10;    return compared == 0 || compared == -1;&#10;}&#10;&#10;bool Bigint::operator&gt;(const Bigint &amp;b) const {&#10;    return compare(b) == 1;&#10;}&#10;&#10;bool Bigint::operator&gt;=(const Bigint &amp;b) const {&#10;    int compared = compare(b);&#10;&#10;    return compared == 0 || compared == 1;&#10;}&#10;&#10;bool Bigint::operator==(Bigint const &amp;b) const {&#10;    return compare(b) == 0;&#10;}&#10;&#10;bool Bigint::operator!=(Bigint const &amp;b) const {&#10;    return !(*this == b);&#10;}&#10;&#10;//Allocation&#10;Bigint &amp;Bigint::operator=(const long long &amp;a) {&#10;    number.clear();&#10;    long long t = a;&#10;    do {&#10;        number.push_back((int) (t % base));&#10;        t /= base;&#10;    } while (t != 0);&#10;&#10;    return *this;&#10;}&#10;&#10;//Access&#10;int Bigint::operator[](int const &amp;b) const {&#10;    return to_string(*this)[b] - '0';&#10;}&#10;&#10;//Trivia&#10;int Bigint::digits() const {&#10;    int segments = number.size();&#10;&#10;    if (segments == 0) return 0;&#10;&#10;    int digits = 9 * (segments - 1);&#10;    digits += segment_length(number.back());&#10;&#10;    return digits;&#10;}&#10;&#10;int Bigint::trailing_zeros() const {&#10;    if (number.empty() || (number.size() == 1 &amp;&amp; number[0] == 0)) return 1;&#10;&#10;    int zeros = 0;&#10;    auto it = number.begin();&#10;    if (number.size() &gt; 1) {&#10;        for (; it != number.end() - 1 &amp;&amp; *it == 0; ++it) {&#10;            zeros += 9;&#10;        }&#10;    }&#10;    int a = *it;&#10;    while (a % 10 == 0 &amp;&amp; a) {&#10;        ++zeros;&#10;        a /= 10;&#10;    }&#10;&#10;    return zeros;&#10;}&#10;&#10;//Helpers&#10;void Bigint::clear() {&#10;    number.clear();&#10;    positive = true;&#10;    skip = 0;&#10;}&#10;&#10;Bigint &amp;Bigint::abs() {&#10;    positive = true;&#10;&#10;    return *this;&#10;}&#10;&#10;//Input&amp;Output&#10;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Bigint const &amp;a) {&#10;    if (!a.number.size()) return out &lt;&lt; 0;&#10;    int i = a.number.size() - 1;&#10;    for (; i &gt;= 0 &amp;&amp; a.number[i] == 0; --i)&#10;        ;&#10;&#10;    if (i == -1) return out &lt;&lt; 0;&#10;    if (!a.positive) out &lt;&lt; '-';&#10;&#10;    auto it = a.number.rbegin() + (a.number.size() - i - 1);&#10;&#10;    out &lt;&lt; *it++;&#10;    for (; it != a.number.rend(); ++it) {&#10;        for (int i(0), len = a.segment_length(*it); i &lt; 9 - len; ++i) out &lt;&lt; '0';&#10;        if (*it) out &lt;&lt; *it;&#10;    }&#10;&#10;    return out;&#10;}&#10;&#10;std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Bigint &amp;a) {&#10;    std::string str;&#10;    in &gt;&gt; str;&#10;&#10;    a = str;&#10;&#10;    return in;&#10;}&#10;&#10;int Bigint::segment_length(int segment) {&#10;    int length = 0;&#10;    while (segment) {&#10;        segment /= 10;&#10;        ++length;&#10;    }&#10;&#10;    return length;&#10;}&#10;&#10;Bigint abs(Bigint value) {&#10;    return value.abs();&#10;}&#10;&#10;std::string to_string(Bigint const &amp;value) {&#10;    std::ostringstream stream;&#10;    stream &lt;&lt; value;&#10;&#10;    return stream.str();&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".hld" value="const int maxN = 3 * 100000 + 5;&#10;&#10;array&lt;int, 4 * maxN&gt; segtree;&#10;&#10;struct HLD {&#10;&#10;    vector&lt;int&gt; a;&#10;&#10;    int combine(int x, int y) {&#10;        return x + y;&#10;    }&#10;&#10;    void build(int v, int tl, int tr) {&#10;        if (tl == tr) {&#10;            segtree[v] = a[tl];&#10;        } else {&#10;            int tm = (tl + tr) / 2;&#10;            build(2 * v, tl, tm);&#10;            build(2 * v + 1, tm + 1, tr);&#10;            segtree[v] = combine(segtree[2 * v], segtree[2 * v + 1]);&#10;        }&#10;    }&#10;&#10;    int get(int v, int tl, int tr, int l, int r) {&#10;        if (l == tl &amp;&amp; r == tr) {&#10;            return segtree[v];&#10;        }&#10;        int tm = (tl + tr) / 2;&#10;        if (r &lt;= tm) {&#10;            return get(2 * v, tl, tm, l, r);&#10;        }&#10;        if (l &gt; tm) {&#10;            return get(2 * v + 1, tm + 1, tr, l, r);&#10;        }&#10;        return combine(get(2 * v, tl, tm, l, tm), get(2 * v + 1, tm + 1, tr, tm + 1, r));&#10;    }&#10;&#10;    void update(int v, int tl, int tr, int pos, int val) {&#10;        if (tl == tr) {&#10;            segtree[v] = val;&#10;        } else {&#10;            int tm = (tl + tr) / 2;&#10;            if (pos &lt;= tm) {&#10;                update(2 * v, tl, tm, pos, val);&#10;            } else {&#10;                update(2 * v + 1, tm + 1, tr, pos, val);&#10;            }&#10;            segtree[v] = combine(segtree[2 * v], segtree[2 * v + 1]);&#10;        }&#10;    }&#10;&#10;&#10;    int n;&#10;&#10;    graph&lt;int&gt; g;&#10;    vector&lt;int&gt; parent;&#10;    vector&lt;int&gt; depth;&#10;    vector&lt;int&gt; sizes;&#10;    vector&lt;int&gt; heavy;&#10;    vector&lt;int&gt; group;&#10;    vector&lt;int&gt; alias;&#10;    int cnt = 0;&#10;&#10;    void dfs(int u, int p) {&#10;        sizes[u] = 1;&#10;        parent[u] = p;&#10;        depth[u] = depth[p] + 1;&#10;        int max_size = 0;&#10;        for (auto v: g[u]) {&#10;            if (v != p) {&#10;                dfs(v, u);&#10;                sizes[u] += sizes[v];&#10;                if (sizes[v] &gt; max_size) {&#10;                    max_size = sizes[v];&#10;                    heavy[u] = v;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    void decompose(int v, int p, int root) {&#10;        group[v] = root;&#10;        alias[v] = cnt++;&#10;&#10;        if (heavy[v] != -1) {&#10;            decompose(heavy[v], v, root);&#10;        }&#10;&#10;&#10;        for (auto u: g[v]) {&#10;            if (u != p and u != heavy[v]) {&#10;&#10;                decompose(u, v, u);&#10;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    int get_ans(int v1, int v2) {&#10;        int sum = 0;&#10;        while (group[v1] != group[v2]) {&#10;            if (depth[group[v1]] &lt; depth[group[v2]]) {&#10;                swap(v1, v2);&#10;            }&#10;            sum += get(1, 0, n - 1, alias[group[v1]], alias[v1]);&#10;            v1 = parent[group[v1]];&#10;        }&#10;        if (depth[v1] &gt; depth[v2]) {&#10;            swap(v1, v2);&#10;        }&#10;        sum += get(1, 0, n - 1, alias[v1], alias[v2]);&#10;        return sum;&#10;&#10;    }&#10;&#10;&#10;public:&#10;    HLD(int n, graph&lt;int&gt; g, vector&lt;int&gt; b) : n(n), g(std::move(g)) {&#10;        parent.resize(n);&#10;        depth.resize(n);&#10;        sizes.resize(n);&#10;        heavy.resize(n, -1);&#10;        group.resize(n);&#10;        alias.resize(n);&#10;        dfs(0, 0);&#10;        decompose(0, 0, 0);&#10;        a.resize(n);&#10;        for (int i = 0; i &lt; n; i++) {&#10;            a[alias[i]] = b[i];&#10;        }&#10;        build(1, 0, n - 1);&#10;    }&#10;&#10;    HLD(int n, graph&lt;int&gt; g) : n(n), g(std::move(g)) {&#10;        parent.resize(n);&#10;        depth.resize(n);&#10;        sizes.resize(n);&#10;        heavy.resize(n, -1);&#10;        group.resize(n);&#10;        alias.resize(n);&#10;        dfs(0, 0);&#10;        decompose(0, 0, 0);&#10;        a.resize(n, 0);&#10;        build(1, 0, n - 1);&#10;    }&#10;&#10;    int get(int v1, int v2) {&#10;        return get_ans(v1, v2);&#10;    }&#10;&#10;    void set(int v, int val) {&#10;        update(1, 0, n - 1, alias[v], val);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".fft" value="namespace fft {&#10;    struct cmpl {&#10;        double x, y;&#10;&#10;        cmpl() {&#10;            x = y = 0;&#10;        }&#10;&#10;        cmpl(double x, double y) : x(x), y(y) {}&#10;&#10;        inline cmpl conjugated() const {&#10;            return cmpl(x, -y);&#10;        }&#10;    };&#10;&#10;    inline cmpl operator+(cmpl a, cmpl b) {&#10;        return cmpl(a.x + b.x, a.y + b.y);&#10;    }&#10;&#10;    inline cmpl operator-(cmpl a, cmpl b) {&#10;        return cmpl(a.x - b.x, a.y - b.y);&#10;    }&#10;&#10;    inline cmpl operator*(cmpl a, cmpl b) {&#10;        return cmpl(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#10;    }&#10;&#10;    int base = 1; // current power of two (2^base &gt;= n)&#10;    vector&lt;cmpl&gt; roots = {{0, 0},&#10;                          {1, 0}}; // complex roots of 1 (with bases from 1 to base), 1-based indexing&#10;    vector&lt;int&gt; rev = {0, 1}; // rev[i] = reversed bit representation of i&#10;    const double PI = static_cast&lt;double&gt;(acosl(-1.0));&#10;&#10;    void ensure_base(int nbase) { // if base &lt; nbase increase it&#10;        if (nbase &lt;= base) {&#10;            return;&#10;        }&#10;        rev.resize(1 &lt;&lt; nbase);&#10;        for (int i = 1; i &lt; (1 &lt;&lt; nbase); i++) {&#10;            rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));&#10;        }&#10;        roots.resize(1 &lt;&lt; nbase);&#10;        while (base &lt; nbase) {&#10;            double angle = 2 * PI / (1 &lt;&lt; (base + 1));&#10;            for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {&#10;                roots[i &lt;&lt; 1] = roots[i];&#10;                double angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base));&#10;                roots[(i &lt;&lt; 1) + 1] = cmpl(cos(angle_i), sin(angle_i));&#10;            }&#10;            base++;&#10;        }&#10;    }&#10;&#10;    void fft(vector&lt;cmpl&gt; &amp;a, int n = -1) {&#10;        if (n == -1) {&#10;            n = (int) a.size();&#10;        }&#10;        assert((n &amp; (n - 1)) == 0); // ensure that n is a power of two&#10;        int zeros = __builtin_ctz(n);&#10;        ensure_base(zeros);&#10;        int shift = base - zeros;&#10;        for (int i = 0; i &lt; n; i++) {&#10;            if (i &lt; (rev[i] &gt;&gt; shift)) {&#10;                swap(a[i], a[rev[i] &gt;&gt; shift]);&#10;            }&#10;        }&#10;        for (int k = 1; k &lt; n; k &lt;&lt;= 1) {&#10;            for (int i = 0; i &lt; n; i += 2 * k) {&#10;                for (int j = 0; j &lt; k; j++) {&#10;                    cmpl z = a[i + j + k] * roots[j + k];&#10;                    a[i + j + k] = a[i + j] - z;&#10;                    a[i + j] = a[i + j] + z;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    vector&lt;cmpl&gt; fa, fb;&#10;&#10;    vector&lt;long long&gt; square(const vector&lt;int&gt; &amp;a) {&#10;        if (a.empty()) {&#10;            return {};&#10;        }&#10;        int need = (int) a.size() + (int) a.size() - 1;&#10;        int nbase = 1;&#10;        while ((1 &lt;&lt; nbase) &lt; need) {&#10;            nbase++;&#10;        }&#10;        ensure_base(nbase);&#10;        int sz = 1 &lt;&lt; nbase;&#10;        if ((sz &gt;&gt; 1) &gt; (int) fa.size()) {&#10;            fa.resize(sz &gt;&gt; 1);&#10;        }&#10;        for (int i = 0; i &lt; (sz &gt;&gt; 1); i++) {&#10;            int x = (2 * i &lt; (int) a.size() ? a[2 * i] : 0);&#10;            int y = (2 * i + 1 &lt; (int) a.size() ? a[2 * i + 1] : 0);&#10;            fa[i] = cmpl(x, y);&#10;        }&#10;        fft(fa, sz &gt;&gt; 1);&#10;        cmpl r(1.0 / (sz &gt;&gt; 1), 0.0);&#10;        for (int i = 0; i &lt;= (sz &gt;&gt; 2); i++) {&#10;            int j = ((sz &gt;&gt; 1) - i) &amp; ((sz &gt;&gt; 1) - 1);&#10;            cmpl fe = (fa[i] + fa[j].conjugated()) * cmpl(0.5, 0);&#10;            cmpl fo = (fa[i] - fa[j].conjugated()) * cmpl(0, -0.5);&#10;            cmpl aux = fe * fe + fo * fo * roots[(sz &gt;&gt; 1) + i] * roots[(sz &gt;&gt; 1) + i];&#10;            cmpl tmp = fe * fo;&#10;            fa[i] = r * (aux.conjugated() + cmpl(0, 2) * tmp.conjugated());&#10;            fa[j] = r * (aux + cmpl(0, 2) * tmp);&#10;        }&#10;        fft(fa, sz &gt;&gt; 1);&#10;        vector&lt;long long&gt; res(need);&#10;        for (int i = 0; i &lt; need; i++) {&#10;            res[i] = llround(i % 2 == 0 ? fa[i &gt;&gt; 1].x : fa[i &gt;&gt; 1].y);&#10;        }&#10;        return res;&#10;    }&#10;&#10;    // interface&#10;&#10;    vector&lt;long long&gt; multiply(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {&#10;        if (a.empty() || b.empty()) {&#10;            return {};&#10;        }&#10;        if (a == b) {&#10;            return square(a);&#10;        }&#10;        int need = (int) a.size() + (int) b.size() - 1;&#10;        int nbase = 1;&#10;        while ((1 &lt;&lt; nbase) &lt; need) nbase++;&#10;        ensure_base(nbase);&#10;        int sz = 1 &lt;&lt; nbase;&#10;        if (sz &gt; (int) fa.size()) {&#10;            fa.resize(sz);&#10;        }&#10;        for (int i = 0; i &lt; sz; i++) {&#10;            int x = (i &lt; (int) a.size() ? a[i] : 0);&#10;            int y = (i &lt; (int) b.size() ? b[i] : 0);&#10;            fa[i] = cmpl(x, y);&#10;        }&#10;        fft(fa, sz);&#10;        cmpl r(0, -0.25 / (sz &gt;&gt; 1));&#10;        for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) {&#10;            int j = (sz - i) &amp; (sz - 1);&#10;            cmpl z = (fa[j] * fa[j] - (fa[i] * fa[i]).conjugated()) * r;&#10;            fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conjugated()) * r;&#10;            fa[i] = z;&#10;        }&#10;        for (int i = 0; i &lt; (sz &gt;&gt; 1); i++) {&#10;            cmpl A0 = (fa[i] + fa[i + (sz &gt;&gt; 1)]) * cmpl(0.5, 0);&#10;            cmpl A1 = (fa[i] - fa[i + (sz &gt;&gt; 1)]) * cmpl(0.5, 0) * roots[(sz &gt;&gt; 1) + i];&#10;            fa[i] = A0 + A1 * cmpl(0, 1);&#10;        }&#10;        fft(fa, sz &gt;&gt; 1);&#10;        vector&lt;long long&gt; res(need);&#10;        for (int i = 0; i &lt; need; i++) {&#10;            res[i] = llround(i % 2 == 0 ? fa[i &gt;&gt; 1].x : fa[i &gt;&gt; 1].y);&#10;        }&#10;        return res;&#10;    }&#10;&#10;    vector&lt;int&gt; multiply_mod(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b, int m) {&#10;        if (a.empty() || b.empty()) {&#10;            return {};&#10;        }&#10;        int need = (int) a.size() + (int) b.size() - 1;&#10;        int nbase = 0;&#10;        while ((1 &lt;&lt; nbase) &lt; need) {&#10;            nbase++;&#10;        }&#10;        ensure_base(nbase);&#10;        int sz = 1 &lt;&lt; nbase;&#10;        if (sz &gt; (int) fa.size()) {&#10;            fa.resize(sz);&#10;        }&#10;        for (int i = 0; i &lt; (int) a.size(); i++) {&#10;            int x = (a[i] % m + m) % m;&#10;            fa[i] = cmpl(x &amp; ((1 &lt;&lt; 15) - 1), x &gt;&gt; 15);&#10;        }&#10;        fill(fa.begin() + a.size(), fa.begin() + sz, cmpl{0, 0});&#10;        fft(fa, sz);&#10;        if (sz &gt; (int) fb.size()) {&#10;            fb.resize(sz);&#10;        }&#10;        if (a == b) {&#10;            copy(fa.begin(), fa.begin() + sz, fb.begin());&#10;        } else {&#10;            for (int i = 0; i &lt; (int) b.size(); i++) {&#10;                int x = (b[i] % m + m) % m;&#10;                fb[i] = cmpl(x &amp; ((1 &lt;&lt; 15) - 1), x &gt;&gt; 15);&#10;            }&#10;            fill(fb.begin() + b.size(), fb.begin() + sz, cmpl{0, 0});&#10;            fft(fb, sz);&#10;        }&#10;        double ratio = 0.25 / sz;&#10;        cmpl r2(0, -1);&#10;        cmpl r3(ratio, 0);&#10;        cmpl r4(0, -ratio);&#10;        cmpl r5(0, 1);&#10;        for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) {&#10;            int j = (sz - i) &amp; (sz - 1);&#10;            cmpl a1 = (fa[i] + fa[j].conjugated());&#10;            cmpl a2 = (fa[i] - fa[j].conjugated()) * r2;&#10;            cmpl b1 = (fb[i] + fb[j].conjugated()) * r3;&#10;            cmpl b2 = (fb[i] - fb[j].conjugated()) * r4;&#10;            if (i != j) {&#10;                cmpl c1 = (fa[j] + fa[i].conjugated());&#10;                cmpl c2 = (fa[j] - fa[i].conjugated()) * r2;&#10;                cmpl d1 = (fb[j] + fb[i].conjugated()) * r3;&#10;                cmpl d2 = (fb[j] - fb[i].conjugated()) * r4;&#10;                fa[i] = c1 * d1 + c2 * d2 * r5;&#10;                fb[i] = c1 * d2 + c2 * d1;&#10;            }&#10;            fa[j] = a1 * b1 + a2 * b2 * r5;&#10;            fb[j] = a1 * b2 + a2 * b1;&#10;        }&#10;        fft(fa, sz);&#10;        fft(fb, sz);&#10;        vector&lt;int&gt; res(need);&#10;        for (int i = 0; i &lt; need; i++) {&#10;            long long aa = llround(fa[i].x);&#10;            long long bb = llround(fb[i].x);&#10;            long long cc = llround(fa[i].y);&#10;            res[i] = static_cast&lt;int&gt;((aa + ((bb % m) &lt;&lt; 15) + ((cc % m) &lt;&lt; 30)) % m);&#10;        }&#10;        return res;&#10;    }&#10;}  // namespace fft&#10;/*&#10;use these:&#10;vector&lt;int&gt; multiply_mod(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b, int m)&#10;vector&lt;ll&gt; square(const vector&lt;int&gt;&amp; a)&#10;vector&lt;ll&gt; multiply(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) // (if a == b it uses square)&#10;*/" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".ptest" value="namespace PrimeTest {&#10;    const int COUNT_ITERATIONS = 30;&#10;    &#10;    mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());&#10;&#10;    int randInt(int l, int r) {&#10;        return uniform_int_distribution&lt;int&gt;(l, r)(rnd);&#10;    }&#10;&#10;    int binpow(int a, int b, int m) {&#10;        a %= m;&#10;        i128 res = 1;&#10;        i128 ta = a;&#10;        i128 tb = b;&#10;        i128 tm = m;&#10;        while (tb &gt; 0) {&#10;            if (tb &amp; 1) {&#10;                res = res * ta % tm;&#10;            }&#10;            ta = ta * ta % tm;&#10;            tb &gt;&gt;= 1;&#10;        }&#10;        return res % tm;&#10;    }&#10;&#10;    int gen(int n) {&#10;        return randInt(2, n - 1);&#10;    }&#10;    &#10;    bool is_prime(int n) {&#10;        if (n == 2)&#10;            return true;&#10;        bool only_ones = true;&#10;        int m = (n - 1) &gt;&gt; 1;&#10;        for (int i = 0; i &lt; COUNT_ITERATIONS; i++) {&#10;            int a = gen(n);&#10;            int res = binpow(a, m, n);&#10;            if (res != 1 and res != n - 1)&#10;                return false;&#10;            if (res != 1)&#10;                only_ones = false;&#10;        }&#10;        return not only_ones;&#10;    }&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>