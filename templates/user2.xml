<templateSet group="user">
  <template name=".BigInt" value="class Bigint {&#10;private:&#10;    std::vector&lt;int&gt; number;&#10;    bool positive;&#10;    int base;&#10;    unsigned int skip;&#10;    static const int default_base = 1000000000;&#10;&#10;public:&#10;    //Constructors&#10;    Bigint() {&#10;        positive = true;&#10;        base = Bigint::default_base;&#10;        skip = 0;&#10;    }&#10;    Bigint(long long value) {&#10;        base = Bigint::default_base;&#10;        skip = 0;&#10;        if (value &lt; 0) {&#10;            positive = false;&#10;            value *= -1;&#10;        } else {&#10;            positive = true;&#10;        }&#10;&#10;        while (value) {&#10;            number.push_back((int) (value % base));&#10;            value /= base;&#10;        }&#10;    }&#10;    Bigint(std::string stringInteger) {&#10;        int size = stringInteger.length();&#10;&#10;        base = Bigint::default_base;&#10;        skip = 0;&#10;        positive = (stringInteger[0] != '-');&#10;&#10;        while (true) {&#10;            if (size &lt;= 0) break;&#10;            if (!positive &amp;&amp; size &lt;= 1) break;&#10;&#10;            int length = 0;&#10;            int num = 0;&#10;            int prefix = 1;&#10;            for (int i(size - 1); i &gt;= 0 &amp;&amp; i &gt;= size - 9; --i) {&#10;                if (stringInteger[i] &lt; '0' || stringInteger[i] &gt; '9') break;&#10;                num += (stringInteger[i] - '0') * prefix;&#10;                prefix *= 10;&#10;                ++length;&#10;            }&#10;            number.push_back(num);&#10;            size -= length;&#10;        }&#10;    }&#10;    Bigint(const Bigint &amp;b) = default;&#10;&#10;    //Adding&#10;    Bigint operator+(Bigint const &amp;) const;&#10;    Bigint &amp;operator+=(Bigint const &amp;);&#10;    Bigint operator+(long long const &amp;) const;&#10;    Bigint &amp;operator+=(long long);&#10;&#10;    //Subtraction&#10;    Bigint operator-(Bigint const &amp;) const;&#10;    Bigint &amp;operator-=(Bigint const &amp;);&#10;&#10;    //Multiplication&#10;    Bigint operator*(Bigint const &amp;);&#10;    Bigint &amp;operator*=(Bigint const &amp;);&#10;    Bigint operator*(long long const &amp;);&#10;    Bigint &amp;operator*=(int const &amp;);&#10;&#10;    //Compare&#10;    bool operator&lt;(const Bigint &amp;) const;&#10;    bool operator&gt;(const Bigint &amp;) const;&#10;    bool operator&lt;=(const Bigint &amp;) const;&#10;    bool operator&gt;=(const Bigint &amp;) const;&#10;    bool operator==(const Bigint &amp;) const;&#10;    bool operator!=(const Bigint &amp;) const;&#10;&#10;    //Allocation&#10;    Bigint &amp;operator=(const long long &amp;);&#10;&#10;    //Access&#10;    int operator[](int const &amp;) const;&#10;&#10;    //Input&amp;Output&#10;    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;, Bigint &amp;);&#10;    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;, Bigint const &amp;);&#10;&#10;    //Helpers&#10;    void clear();&#10;    Bigint &amp;abs();&#10;&#10;    //Power&#10;    Bigint &amp;pow(int const &amp;);&#10;&#10;    //Trivia&#10;    int digits() const;&#10;    int trailing_zeros() const;&#10;&#10;private:&#10;    static int segment_length(int);&#10;    Bigint pow(int const &amp;, std::map&lt;int, Bigint&gt; &amp;);&#10;    int compare(Bigint const &amp;) const;//0 a == b, -1 a &lt; b, 1 a &gt; b&#10;};&#10;&#10;Bigint abs(Bigint);&#10;std::string to_string(Bigint const &amp;);&#10;Bigint factorial(int);&#10;&#10;//Constructor&#10;&#10;&#10;//Adding&#10;Bigint Bigint::operator+(Bigint const &amp;b) const {&#10;    Bigint c = *this;&#10;    c += b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator+=(Bigint const &amp;b) {&#10;    if (!b.positive) {&#10;        return *this -= b;&#10;    }&#10;    std::vector&lt;int&gt;::iterator&#10;            it1 = number.begin();&#10;    std::vector&lt;int&gt;::const_iterator&#10;            it2 = b.number.begin();&#10;    int sum = 0;&#10;    while (it1 != number.end() || it2 != b.number.end()) {&#10;        if (it1 != number.end()) {&#10;            sum += *it1;&#10;        } else {&#10;            number.push_back(0);&#10;            it1 = number.end() - 1;&#10;        }&#10;        if (it2 != b.number.end()) {&#10;            sum += *it2;&#10;            ++it2;&#10;        }&#10;        *it1 = sum % base;&#10;        ++it1;&#10;        sum /= base;&#10;    }&#10;    if (sum) number.push_back(1);&#10;&#10;    return *this;&#10;}&#10;&#10;Bigint Bigint::operator+(long long const &amp;b) const {&#10;    Bigint c = *this;&#10;    c += b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator+=(long long b) {&#10;    std::vector&lt;int&gt;::iterator it = number.begin();&#10;    if (skip &gt; number.size()) {&#10;        number.insert(number.end(), skip - number.size(), 0);&#10;    }&#10;    it += skip;&#10;    bool initial_flag = true;&#10;    while (b || initial_flag) {&#10;        initial_flag = false;&#10;        if (it != number.end()) {&#10;            *it += b % base;&#10;            b /= base;&#10;            b += *it / base;&#10;            *it %= base;&#10;            ++it;&#10;        } else {&#10;            number.push_back(0);&#10;            it = number.end() - 1;&#10;        }&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;//Subtraction&#10;Bigint Bigint::operator-(Bigint const &amp;b) const {&#10;    Bigint c = *this;&#10;    c -= b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator-=(Bigint const &amp;b) {&#10;    std::vector&lt;int&gt;::iterator&#10;            it1 = number.begin();&#10;    std::vector&lt;int&gt;::const_iterator&#10;            it2 = b.number.begin();&#10;    int dif = 0;&#10;    while (it1 != number.end() || it2 != b.number.end()) {&#10;        if (it1 != number.end()) {&#10;            dif += *it1;&#10;            ++it1;&#10;        }&#10;        if (it2 != b.number.end()) {&#10;            dif -= *it2;&#10;            ++it2;&#10;        }&#10;        if (dif &lt; 0) {&#10;            *(it1 - 1) = dif + base;&#10;            dif = -1;&#10;        } else {&#10;            *(it1 - 1) = dif % base;&#10;            dif /= base;&#10;        }&#10;    }&#10;    if (dif &lt; 0) positive = false;&#10;&#10;    if (number.size() &gt; 1) {&#10;        do {&#10;            it1 = number.end() - 1;&#10;            if (*it1 == 0) number.pop_back();&#10;            else&#10;                break;&#10;        } while (number.size() &gt; 1);&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;//Multiplication&#10;Bigint Bigint::operator*(Bigint const &amp;b) {&#10;    if (b.number.size() == 1) return *this *= b.number[0];&#10;    std::vector&lt;int&gt;::iterator it1;&#10;    std::vector&lt;int&gt;::const_iterator it2;&#10;    Bigint c;&#10;    for (it1 = number.begin(); it1 != number.end(); ++it1) {&#10;        for (it2 = b.number.begin(); it2 != b.number.end(); ++it2) {&#10;            c.skip = (unsigned int) (it1 - number.begin()) + (it2 - b.number.begin());//TODO&#10;            c += (long long) (*it1) * (*it2);&#10;        }&#10;    }&#10;    c.skip = 0;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator*=(Bigint const &amp;b) {&#10;    *this = *this * b;&#10;&#10;    return *this;&#10;}&#10;&#10;Bigint Bigint::operator*(long long const &amp;b) {&#10;    Bigint c = *this;&#10;    c *= b;&#10;&#10;    return c;&#10;}&#10;&#10;Bigint &amp;Bigint::operator*=(int const &amp;b) {&#10;    auto it = number.begin();&#10;    long long sum = 0;&#10;    while (it != number.end()) {&#10;        sum += (long long) (*it) * b;&#10;        *it = (int) (sum % base);&#10;        sum /= base;&#10;        ++it;&#10;    }&#10;    if (sum) number.push_back((int) sum);&#10;&#10;    return *this;&#10;}&#10;&#10;//Power&#10;Bigint Bigint::pow(int const &amp;power, std::map&lt;int, Bigint&gt; &amp;lookup) {&#10;    if (power == 1) return *this;&#10;    if (lookup.count(power)) return lookup[power];&#10;&#10;    int closestPower = 1;&#10;    while (closestPower &lt; power) closestPower &lt;&lt;= 1;&#10;    closestPower &gt;&gt;= 1;&#10;&#10;    if (power == closestPower) lookup[power] = pow(power / 2, lookup) * pow(power / 2, lookup);&#10;    else&#10;        lookup[power] = pow(closestPower, lookup) * pow(power - closestPower, lookup);&#10;&#10;    return lookup[power];&#10;}&#10;&#10;Bigint &amp;Bigint::pow(int const &amp;power) {&#10;    std::map&lt;int, Bigint&gt; lookup;&#10;    if (power % 2 == 0 &amp;&amp; !positive) {&#10;        positive = true;&#10;    }&#10;    *this = pow(power, lookup);&#10;&#10;    return *this;&#10;}&#10;&#10;//Compare&#10;int Bigint::compare(const Bigint &amp;a) const//0 this == a || -1 this &lt; a || 1 this &gt; a&#10;{&#10;    if (positive &amp;&amp; !a.positive) return 1;&#10;    if (!positive &amp;&amp; a.positive) return -1;&#10;&#10;    int check = 1;&#10;    if (!positive &amp;&amp; !a.positive) check = -1;&#10;&#10;    if (number.size() &lt; a.number.size()) return -1 * check;&#10;    if (number.size() &gt; a.number.size()) return check;&#10;    for (size_t i(number.size()); i &gt; 0; --i) {&#10;        if (number[i - 1] &lt; a.number[i - 1]) return -1 * check;&#10;        if (number[i - 1] &gt; a.number[i - 1]) return check;&#10;    }&#10;&#10;    return 0;// ==&#10;}&#10;&#10;bool Bigint::operator&lt;(Bigint const &amp;b) const {&#10;    return compare(b) == -1;&#10;}&#10;&#10;bool Bigint::operator&lt;=(const Bigint &amp;b) const {&#10;    int compared = compare(b);&#10;&#10;    return compared == 0 || compared == -1;&#10;}&#10;&#10;bool Bigint::operator&gt;(const Bigint &amp;b) const {&#10;    return compare(b) == 1;&#10;}&#10;&#10;bool Bigint::operator&gt;=(const Bigint &amp;b) const {&#10;    int compared = compare(b);&#10;&#10;    return compared == 0 || compared == 1;&#10;}&#10;&#10;bool Bigint::operator==(Bigint const &amp;b) const {&#10;    return compare(b) == 0;&#10;}&#10;&#10;bool Bigint::operator!=(Bigint const &amp;b) const {&#10;    return !(*this == b);&#10;}&#10;&#10;//Allocation&#10;Bigint &amp;Bigint::operator=(const long long &amp;a) {&#10;    number.clear();&#10;    long long t = a;&#10;    do {&#10;        number.push_back((int) (t % base));&#10;        t /= base;&#10;    } while (t != 0);&#10;&#10;    return *this;&#10;}&#10;&#10;//Access&#10;int Bigint::operator[](int const &amp;b) const {&#10;    return to_string(*this)[b] - '0';&#10;}&#10;&#10;//Trivia&#10;int Bigint::digits() const {&#10;    int segments = number.size();&#10;&#10;    if (segments == 0) return 0;&#10;&#10;    int digits = 9 * (segments - 1);&#10;    digits += segment_length(number.back());&#10;&#10;    return digits;&#10;}&#10;&#10;int Bigint::trailing_zeros() const {&#10;    if (number.empty() || (number.size() == 1 &amp;&amp; number[0] == 0)) return 1;&#10;&#10;    int zeros = 0;&#10;    auto it = number.begin();&#10;    if (number.size() &gt; 1) {&#10;        for (; it != number.end() - 1 &amp;&amp; *it == 0; ++it) {&#10;            zeros += 9;&#10;        }&#10;    }&#10;    int a = *it;&#10;    while (a % 10 == 0 &amp;&amp; a) {&#10;        ++zeros;&#10;        a /= 10;&#10;    }&#10;&#10;    return zeros;&#10;}&#10;&#10;//Helpers&#10;void Bigint::clear() {&#10;    number.clear();&#10;    positive = true;&#10;    skip = 0;&#10;}&#10;&#10;Bigint &amp;Bigint::abs() {&#10;    positive = true;&#10;&#10;    return *this;&#10;}&#10;&#10;//Input&amp;Output&#10;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Bigint const &amp;a) {&#10;    if (!a.number.size()) return out &lt;&lt; 0;&#10;    int i = a.number.size() - 1;&#10;    for (; i &gt;= 0 &amp;&amp; a.number[i] == 0; --i)&#10;        ;&#10;&#10;    if (i == -1) return out &lt;&lt; 0;&#10;    if (!a.positive) out &lt;&lt; '-';&#10;&#10;    auto it = a.number.rbegin() + (a.number.size() - i - 1);&#10;&#10;    out &lt;&lt; *it++;&#10;    for (; it != a.number.rend(); ++it) {&#10;        for (int i(0), len = a.segment_length(*it); i &lt; 9 - len; ++i) out &lt;&lt; '0';&#10;        if (*it) out &lt;&lt; *it;&#10;    }&#10;&#10;    return out;&#10;}&#10;&#10;std::istream &amp;operator&gt;&gt;(std::istream &amp;in, Bigint &amp;a) {&#10;    std::string str;&#10;    in &gt;&gt; str;&#10;&#10;    a = str;&#10;&#10;    return in;&#10;}&#10;&#10;int Bigint::segment_length(int segment) {&#10;    int length = 0;&#10;    while (segment) {&#10;        segment /= 10;&#10;        ++length;&#10;    }&#10;&#10;    return length;&#10;}&#10;&#10;Bigint abs(Bigint value) {&#10;    return value.abs();&#10;}&#10;&#10;std::string to_string(Bigint const &amp;value) {&#10;    std::ostringstream stream;&#10;    stream &lt;&lt; value;&#10;&#10;    return stream.str();&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>