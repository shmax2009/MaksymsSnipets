<templateSet group="Algoritms">
  <template name=".STree" value="namespace Algorithms {&#10;&#10;    template&lt;typename T&gt;&#10;    class vertex {&#10;    public:&#10;        vertex&lt;T&gt; *left;&#10;        vertex&lt;T&gt; *right;&#10;        T val;&#10;&#10;        explicit vertex(const T &amp;_val = T()) : val(_val), left(NULL), right(NULL) {}&#10;&#10;        vertex(vertex&lt;T&gt; *_left, vertex&lt;T&gt; *_right, std::function&lt;T(T, T)&gt; &amp;merge) : left(_left), right(_right),&#10;                                                                                     val(T()) {&#10;            if (_left == NULL)&#10;                val = right-&gt;val;&#10;            else if (_right == NULL)val = left-&gt;val;&#10;            else&#10;                val = merge(right-&gt;val, left-&gt;val);&#10;        }&#10;    };&#10;&#10;    template&lt;typename T&gt;&#10;    class segment_tree {&#10;    private:&#10;        std::function&lt;T(T, T)&gt; merge;&#10;        T defaultValue = T();&#10;        std::vector&lt;T&gt; data;&#10;        std::vector&lt;vertex&lt;T&gt; *&gt; versions;&#10;        std::vector&lt;vertex&lt;T&gt; *&gt; vertexes;&#10;&#10;        vertex&lt;T&gt; *_build(int tl, int tr) {&#10;            if (tl == tr)&#10;                return new vertex&lt;T&gt;(data[tl]);&#10;            int tm = (tl + tr) / 2;&#10;            auto vertex = new Algorithms::vertex&lt;T&gt;(_build(tl, tm), _build(tm + 1, tr), merge);&#10;            vertexes.push_back(vertex);&#10;            return vertex;&#10;        }&#10;&#10;        T _get(vertex&lt;T&gt; *v, int tl, int tr, int l, int r) {&#10;            if (l &gt; r)&#10;                return defaultValue;&#10;            if (l == tl &amp;&amp; r == tr)&#10;                return v-&gt;val;&#10;            int tm = (tl + tr) / 2;&#10;            return merge(_get(v-&gt;left, tl, tm, l, std::min(r, tm)), _get(v-&gt;right, tm + 1, tr, std::max(l, tm + 1), r));&#10;        }&#10;&#10;        vertex&lt;T&gt; *_update(vertex&lt;T&gt; *t, int tl, int tr, int pos, T newVal) {&#10;            if (tl == tr) {&#10;                auto vertex = new Algorithms::vertex&lt;T&gt;(newVal);&#10;                vertexes.push_back(vertex);&#10;                return vertex;&#10;            }&#10;            int tm = (tl + tr) / 2;&#10;            if (pos &lt;= tm) {&#10;                auto vertex = new Algorithms::vertex&lt;T&gt;(_update(t-&gt;left, tl, tm, pos, newVal), t-&gt;right, merge);&#10;                vertexes.push_back(vertex);&#10;                return vertex;&#10;            } else {&#10;                auto vertex = new Algorithms::vertex&lt;T&gt;(t-&gt;left, _update(t-&gt;right, tm + 1, tr, pos, newVal), merge);&#10;                vertexes.push_back(vertex);&#10;                return vertex;&#10;            }&#10;        }&#10;&#10;        template&lt;class F&gt;&#10;        static F sum(F a, F b) {&#10;            return a + b;&#10;        }&#10;&#10;    public:&#10;        segment_tree() = default;&#10;&#10;        explicit segment_tree(std::vector&lt;T&gt; _data, std::function&lt;T(T, T)&gt; merge = sum&lt;T&gt;) : data(_data), merge(merge) {&#10;            versions.push_back(_build(0, data.size() - 1));&#10;        }&#10;&#10;        void update(size_t pos, T val) {&#10;            if (pos &gt;= data.size())&#10;                throw std::out_of_range(&quot;Error: index is out of range&quot;);&#10;            data[pos] = val;&#10;            versions.push_back(_update(versions[versions.size() - 1], 0, data.size() - 1, pos, val));&#10;        }&#10;&#10;        T get(int x, int y, int version = -1) {&#10;            if (x &gt; y)&#10;                std::swap(x, y);&#10;            if (x &gt;= data.size() || y &gt;= data.size())&#10;                throw std::out_of_range(&quot;Error: at least one of the bounds is out of range&quot;);&#10;            if (version &lt; -1 || version &gt;= (int) versions.size())&#10;                throw std::out_of_range(&quot;Error: bad version of tree&quot;);&#10;            if (version == -1)&#10;                version += versions.size();&#10;            vertex&lt;T&gt; *t = versions[version];&#10;            return _get(t, 0, data.size() - 1, x, y);&#10;        }&#10;    };&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".import" value="/*&#10;&#10;&#10;         ~??:   :!?J???????????????! .????????~  !?!~?^~!:7:?!~7?. .????????^                                   .:^^^^^:...............::................::::::............:.. ....&#10;         .YYY:    .^7JYYYYYYYYYY?!:  ~YYYYYYYYJ??: :J7^Y?~Y!~J! .7?JYYYYYYYYJ                                .::^^^~~^.................::^~~^:::...........:::^^^^:::::.......... ..:.&#10;         .YYYJ.   ..  .::^^^^:..     .7JJYYJYYYYY7~?^ .?. !! .?!!JYYYYYYYYY?~                             .:^:::^^~~..................^~7!^:.................:::::^^::.............  ..:.&#10;.:.      ~YYYY~  ~77:     .~~~:.       :7JYY?~^^JYYYJ?JJ!!?J??YYYY!^~!!~^:.                            .:::::^^~~!~::::^:::..........:!^................::^::::::::::::........   ....  ..:.&#10;YYJ!.  .!YYJJY?   ..   ...?YYYYY!.   .!JYYJY?. .JYYJYYYYYYYYYYJJYY:                                 .:::::^^^~^^^^^^^^:...........:~~~:...::::..........:^!??7~^:.............  .   ....   ..:..&#10;YYYYY??JYYYYYY?.......JYJYYYYYYYY?...7YYYYJJYYJYYYYJJJJYYYYYJJYYY!................................^^^:::^^^^^^^^^^::..............::...::........::......:::^~7?7~..............  ........    .^^:...................................................................................................&#10;JJJJYYYYJJYJYY!......:YYYYJJJJJYYY^.:YYYYJYYYYYYY~7YYYYYJ?JYYYYJ~...............................^~~^^^^:::^^^^^^......^^^:...............::::.....::::::::^^::.:^7?~.............   ....::.  .  .^~:....................................................................................................&#10;YYYYYYYYYYYYY7........!YYYYYYYJJYY~.^YYJJJYYYYYY!..:~7~:..:~7!^...   ........................:!7!~^^::::^^^^^^.....^!!^....................:~^::....:::^^^^^:::...:!?^.......  ..... .::.::.. ..  .:^:....................................................................................................&#10;^:~JY!:~^.~?~..........:!?JYYYYYYY^.:YYYYYYYY?!:.................     .....................:!7!!^^::::^^^^~~.. .:!J?^.............:........::^~^:..::::::::^^:......:!!:.....    ..^^. :~.:^:. ...  .^^:...................................................................................................&#10;   .^       ..............:^~!7?J?:..?J?7!~^:................     ...     ...............^!!~!~^:::::^^^~!^.  .!YJ~......::.......:.....:::::::^^:...::....::^::......^7~.        ..^!: .!::^:......  .^^:..................................................................................................&#10;        :   .     .^!7????7~^:...........:^~7?????~.........    .    .:    ........... :77!!7~^^^:::^^~!7^.. .JP7....:.:^:.......::.....:::::::::~::.........:^:........~!.         .:7!:.7^:^^...::.   :~^:................................................................................................&#10;      .:.. .      !YYYYYYYYYYYJ?^.....:?JJYYYYYY7:.   ..     .  ..  ..  ..............~7777?~^^^^^^^^!77^...:?5~......:^:........::......:::::..:^!::..........:^:.......^7:       ....!J~:?~:^^...:^..  .^^:...............................................................................................&#10;   ::.     .::    :YYYYYJJYYJYY7..:^:..7YYJYYYJY?   .. ...   .      ..  ............:777777~~~^^^^^~7??~...:?J:......:^:.........^..............::^7::..........:^:.......:7^     ......^?77J!^~~:..:~...  ^~^:.............................................................................................&#10;    :       .    ..!YYJYJYJYYJ~..!JYJ!:.~JYYYJYJ?~...    :  ...   ..    ...........~?7?7!7~~~~~~^^~7??7...:JJ.::.....^!..........~...............~.~!.:...........:^....   .7~    .......^??7J7~!!...~~...  ^~^:............................................................................................&#10;     :.   .:.   ...?YYYYYYYJ!:.^JYYYYYJ~.:!JYY7.  .:.    .:    .....:..^77~~.....:!77J7!?~~!^~~^^!??J?:...JJ:^!......~~..........~:..............!:.?^.:...........:^.     ..!~   ........^??7?77?!..:7~...  :~^:...........................................................................................&#10;     :..   .     ..^!7???!^:..!YYYYJYYYY7..:^77.    ......     ...:!JJ7JYYYY:...:77?J!!?~~!~^!~^~????!...JY:~7!:..:..!~..........^~............. ~~ :Y............. .:. ......!~  .........^??77777~..!?^.....:~^:..........................................................................................&#10;                 ............~YYYYYJYYYYY~......   .  ..  .. .....~JYYY!!7?YJ?!^77JJ!!J!^!7~!!^~?????:..75^^777:.^..^!~.........::7............. ^J. 77.......    .. .:.::.....7: ..........!7777!!7^.~?7:......~^:.........................................................................................&#10;       ....   ...............!YJYJYYYJJYY7..........      .........!JJ7:.:?YYYJ77JY!!J?^~7!~!~~?????7:.^P!^7!7?..~..!!!....::...^.!^.............:5: .5:.....     .....:^^^....:7. .........:!77!!!!7::?7~..:.:..~::........................................................................................&#10;   ...............:^:...:^^...?YYYYJJYYY?:........................~JYYY??JJY!77?5Y!!?J~^~777!~7J????!~.5?^77777.^~.:7!!^...^....~:.7.........:....5~. ?Y..:.............^~!^....:! ..........^7!!~!!!~:7~!:.:::: .~^:.......................................................................................&#10;  .~~:^7~......:~!YYYJ!?YYY7~:.^7!:.:~7^...........................^77~!YYJJ7~?P5!!?Y7^^~7?7~!J?77777^75~!777?7.7~.^7!!!:::!....^~.^!:......:~....P?..:P~.:7^.....:..:...~!?~^...~^ ..........~~~~^~!!^!^~^..^~!. :~::......................................................................................&#10; :YYYYYYYJ:... !YYJ?!~7!~?JYY7........:.........::.........   .    .....:~:~~?P5!!75J^^~~7?7!?J777777^P?!77!!?7:?^.^7!!!~^~7..^.:^^:!7:.....^!:..:GJ:..JY:.!Y^...:^^::~...!??~^...7.........:.:!^~~.^77!^:!..^!7:  :^::.....................................................................................&#10;:?Y7!??!7YJ777!~JJ^~!~~~!!^?Y~.....::!YY?~....~?YY7::......  .  .  .......^~?P5!!!Y5!^^~!7?77Y?77777!?P777!!777^J^.~7!!!~~7?..7:.^:!^!~.....!7:..~GY:..~G!:.JY:...~!!7~~..:???7~..^7 ^.......:.!~^~~.:77^.!:.^7?~   ^^:.....................................................................................&#10;J77~^7!~~!~7YYYYY~!7^. .^7!^JYJ^..:YYY!~~.~..~.~~!YYY^...   .   ..   ....:~75Y!~~75J^^^~~7?7YY777777!5Y?7!!!77?!J~.~7!!!~~7?^:?~.::.?~~.....!?^..7GY~::.PJ!^:5J:..^7!7J7^..~J??7!..!::!..:...:.^7^^!^.:!!:^^.!J?!    ^^:....................................................................................&#10;!:7!~^^^!7~^JYJYY?^!!^:^!!^?YYJ^...77:::!77?7777:::!?....   . ...    ....~!57!~~!Y5~^^~~~??75?777!77!5J?!!!!7!??J~.~7!!!!!!?7~??:.~.~J~^...:77~..JGY!^~.?B!?^!P?:.:7!~??~..:?J7777::7.7!:.~...:.?~^^!:.:7~:^:77?7.  . :::...................................................................................&#10;:!7~:  .^~7^^JYYYY?7~~7~~77JYY!......:!?77~^^~77?7:..........    .......~~Y~~~^^7P?^^^~~~?7J5!~!!!7!75?77!!!7!7JJ~.~?!!!!!7YJ77?!.^:^7?~^:.:77!:.PGY7^J.:PY~?^YY7^:^!!!Y7^.:~5?7777:!::7!^!7^.~:^?~~!!..~7::!?~!7.  .  ^^:..................................................................................&#10;!~7!~:::~!!^JY7:::^YJJYJJY~:::...:^..!?7!:    .!7?7:.^:................^^J~:~^^^?5~^^~~~~?75Y~~!!!7~?J777!!7777??~.!Y~!!!!75Y7777^.^~!~~7^:~777~!BPJ?^P:.7Y7!7~G?!~~!!~~Y!::^?P!?!!7!!.!~!7??77!:77:^7^..7!~7!.^7:  :...^^:.................................................................................&#10;J^~!!!!!~~!~JYJ. ..~J?!7?^.::..:7YJ.:7?7!.    .!7??:.JY?:.............:^!!:~^^^~YJ^^^~~~~?7P?~~!!!7~J?777!!7777??~.!G!~!!!75Y!!7J7::7!!:!!!!!!!!PP5J?^B!.!!J!!!?G!~~~::.~Y~:~~55!?~!7J.~~~~~!7J?:!?!.^7^.:7!7::~7^. ~:.: ^^^................................................................................&#10;YYYJ^!77^?YYYYY:.^...^.::.~??~.:7YY~.~7?7!^:.^~7??~.^YY7:.............~^!.~~^^^~5!^^~~~~~7?G7~~~!!7~J?7777777!7J?!.!B7~~!!!YJ!!7J!~.!7!~^.?Y7!!?BJ577^BJ.~~~7~!!P5~~^....7J^~~!G??7^~J7:~^~~~~7J^^?7!.:!~.!7?.^7^!..?~ ^^ :~^:..............................................................................&#10;!YYYYJ!7YYYY!:^::..::^. .^.:^...^JYY~.^~!J7??7?7~^.~YYY^.............^^~.:~^^^^75~^^~~~~~!?G!~~~!!!~J77777!7777YJ~.~G7~~!!!5?!!JJ!!^:7!!^^77JYJPP!57!~Y5:^~:~~~!7BJ~^:...:?7~~~YG!Y~^~J.~^^~~~~?~:?77~..7!!?7.^Y:!:^J^  ?! :~^:.............................................................................&#10; :~~^....^^^..^. :~7?!~ ::.......:^^:.. ^.~^:!.^  .:^::....~?~!!....:^^:.~~^^^^YY^^^^~~~!!?P~~~~!!!!J77?77777775J~.^P!~~!!75?!!5?!!!:^7!~7?!!!YBPJY7!~!J~^~.:^^^~?GJ~^:::.:7~~~!G7??^^J:^~^~~~~7~:~?77:..7YJ?:~Y::!?J:. .Y?..~^:............................................................................&#10;   ...........:::.:~~^. :^..............77?!~?!7..........~JJ7JJ^...~^:.:!^^^^~P?^^^^~~~!!J5~~~~~!!757?777777775?!.^P!!~~!7P7!7P7!!!~:~7757!!^PP?YP5?!~!!^~..:^^^^?5?^::::.^~~~~YY~Y~^7!:~^~~~~!^::?77!::.?P5:~J..?J?:.. ~7Y~.^^^...........................................................................&#10;   .............^.  .:.::...............:?J77JJ^..........^!?J77^..^^:.:^!^^^^!P7^^^^~~~!!Y5~~~~~~!?57?77777777P?!.^5~~~~!J5!!YP!!!!!~:~J5!~.?#7!!7?JJ!~7!^.  .^^^:!7?^::...^~~~!Y!7?^^J:~~~~~~~^:.7777^:~:YG:!?..?J7... .~^Y?.:~^:.........................................................................&#10;   ..............::::........................:..............::.....~:..:~~^^^^?P!^^^^^~~!!5Y^~~~~~!?P7?77?77777P?~.^Y^^!~!YJ~!GJ~~~!~!~.77^.^GJ!!!!7!!~:!7!....^~~!!?YY7!!~~^7!!!Y?!?!^?~~~~~~~~^..~?77!.!7~G7?!..7?!.... ^^^?5~.^~:........................................................................&#10;   ...............................................................^^:.::~~^^^~?5!^^^^^~~!!PY^~~~~~!JP??77J7777?P7~.^?:.^!!57~?B7~~~~~!!?::.:55!!!!!7!!^.:!J?!~^^^:7!^~!7~::^^^?!!???J7~7Y7~~~~~^^..:J777^.!JYGP^..7?!......!^:~YJ::~^:......................................................................&#10;   ...............................................................~^:.::!^^^^~7P!^^^^^^^!!GJ^~~~~~~JG?7!?J7777?5!^.~7:..^J5~~5P~~~~~~!YG:..?P7!!!!!!7!^..^^^..   .:7!:^^~~::::~7^~!~!~!!GY~~^~^^^...J7!77^:~5PP^..7!7^.:.. :^^::757::~:.....................................................................&#10;   ..............................................................^^^  :^!^^^^~7P!^^^^^^^!7GJ^~~^~~~?G??7Y?777!JY~^.~~....!?^?G?~^^^~~JB!.:^~!!7!!!!~7!^  .::.     ..!!^^::^^:::~7^7^~!^7GP!~^~::^...J?7~!7~^!PG!::7:7!.^:...:^^^:^JY~:^~:...................................................................&#10;   ..............................................................~^: ..:!^^^^~?P7^^^^^^~!7GJ^^~^^~~?GJ?75777!!YY~:.~:... ^~7P5~^^^^~?GJ.:~??::!!~~!!7?^   .^:       .~~^^:.:^::.~7!!:!!~GG~~^^..:.. ?J!~:^7!~?GY!~?.~?:^^....:^^^::~JJ^:^^:.................................................................&#10;   ..........................:::::............................  .~^:::.^~^^^^~JP7^^^^^^!!7G5~^~^^~~7BY7JP777!!5?~^^!!!~:.!!7Y7^^^^^7G5::77?J?!^~~~~!~Y7 .  .^.       .:^:~^.:~~::~?7.:!^YB~~^^..... 7Y!~^.:?YJYP??7.:?~~^!....:^^^:::~JJ~:^^................................................................&#10;   .........................^: : .:.:........................   :~^....^~^^^^7YP?~^^^^^!!7GP~~~^^^~!GP?Y5777!JP?7^^~:...~!:.7^^^^:7P5^:J??!!YY!^~~~~~!5.    .:   ...::::^^^~^^^~^:^J7.:~~G^~^^..... ~5!^^::.^YPGJJ~.:^?!.?^....:^^^::::^?J!^^^:.............................................................&#10;   ........................::. ..  :^........................   ~~^..:.^~^^^^JYGJ~^^^^^!!7PP!~~~^^~~PG?557??7Y?:::~:.  :~. :~^:::!5Y~~5?7!~!!YY^:^~^^^J^     .::^::^~7JY5PPGGGP5YJ7~7^.:~J^~^^..... ^5?~^^^!:.7GPJ::~:?~.~?. ...:^::^:::.:7?7~~^:...........................................................&#10;   ................     ...:::. ...~............................!!~^::.~!^^^^YYGJ^~~^^^!?7PG7~~~^^~~JBJPP?7~!?~::^!.  .:  .~^:::JY!!?57!!!~~~!YY:.:~~^^~.     :^!YGB####BBBB##B#&amp;#B#P?!^~7^~^^....  ^5?7~^:^J!:?GJ.^7:?~..?7.....^^::^:::..:!?7!!~:.........................................................&#10;   ................     .....:::::::...........................:7!~:...^!^~^~5YGY^~~~^^~??PGJ~~~^^!~!G5P57!~7!^:^7~       ^^::^^^7JJ77~~~!!~~~~JJ...^~^^:   .!PBGY?5P55PGB#&amp;B: :#&amp;P!JGGGPY~~^^...   :5J?7^^::YJ!55.77:?~..~J7.....:^..::::....~7?77~:.......................................................&#10;   ................................. .    .....................~7~!..:.~7~~~!PJBY^^~~^^~?J5G5~~~~^~!~5GP57~~!~::!7.      ^::::. ^7!7!~~~~^~~~~~~??. .:^^^. .!PJ~::YBGGBB#&amp;&amp;&amp;B^.7&amp;&amp;&amp;5:^5GGP5?~:.     .5Y???^::^JPJ5^J!^?^:..?J!.....::..:^:::....:!???7~:....................................................&#10;   .................................   .  .....................7!^!^.:.~?!!~7GJB5^^~~~^~?55PP!~~~^:7~7BP57~!~^:~7:   ...~^~~^..^^. .^!~^^^^^^~~^^!!.. .:^^..:  .:^#&amp;&amp;&amp;#BBBG#PPB&amp;&amp;&amp;&amp;&amp;!:^PPY?J7~:..   .Y5????~^~7PG5YY~J?:^..^JJ!......::.:^:::......~7???!^..................................................&#10;   ........................ ......... .  ......................?~:7^.::^?!7~J5Y#P^^!~~^~?5GPGJ^~~~^^7~5GP7~^^:^~~.::^~^!!^^^^^^.     .:^:..:^^^^^^^^..  .:^.   .^^B&amp;&amp;&amp;BG5PBB#PP#BB#&amp;~.:55~!^:..      ?5J?777!~7YGGBYJ57.^:..!JJ!......::.:^:::.......^!???7~:...............................................&#10;   ......................       ...............................J^.!^.::^?7?!??PGG!^7~~~^?YGPG5~~~~^:!77G57~^^^^~!JPB#BG##B#BBB5^.       .:. ..:^^^^^^:.   .::   . ~&amp;###Y7YBBGJJBBG#B.  ^^:!:...  ..  !5J?^!!~77?YGGYY5J.~^...7JJ!.......:::^^:::........^7???!^:............................................&#10;   ....................  ..  . ...............................:J:.^~..:^??J77!GYPJ^Y!~!^?YBGPG!~!~~^^?7JP~:^^~JB&amp;#B#BBBBGB#Y:!#&amp;Y^        ..    .::^^^:..   ..     J#BG57!~!~!75PBB^   .::!. ..  ... ^5YJ^:77^!JJYG5P?J:!!....?JJ7...:^..:::^^:::.........:~7??7~:..........................................&#10;   ......................       ...................  .   .....:J:.:!..:^??YJ!!B?YP^Y?!!~!YGGPGJ^!~^^^^??J^~!Y#&amp;#J~PPPGG##&amp;#! :#&amp;B!.                 ..:::.          ?B57:.....^?P5^    .:^~  :.  ....:5YY!::?Y~~J5PGY~J:~!....:JJJ?:..:!^..:^^^^^^...........:!7??7~:.......................................&#10;   ......................   ............. ........   . ..   ..:J..:~^.:^?JYJ~JB?J5!?Y77!!YPGGGP~!7~^^^^?77~?##G~:^####&amp;&amp;###BPB#&amp;&amp;P.                     ...          ~57:....:7J!...   ..!^ .^.  ::.::5YJ?^..75?~JGG!!J:^~.:...^YJJJ^...!?^..:^^^^^:............^!7J?7^:....................................&#10;   ....................................    .   ....  . ..   ..:J..:.^::^!JYJ^PP?JYJ~P7?7!YPPPGG7~?!^^^^^7!!GBB7:::5&amp;&amp;&amp;##GP5G#BB#G#^                                   .~^^^^^^^::...   .:!. .~. .^:.!^YY??7:..!YY~JP^J7:^7.:....~YJJJ~...~J7:.:^^^^^:..............^!7J?!^..................................&#10;   ..................................   ..  .  ....       ....:J:.:. ^^^^YYJ?GJ?JJY~5Y7?!?GP55BY~7?~~^^^:!7YGB7:::^P&amp;#GGB?JG#BY5G#!                                 ... ............  ..~^. :~...^:.J^YYJ??7^:.^J5~?!5^:~7:.:....!YJJY7...:JJ~..:^^^^:................:!??7~:...............................&#10;   .................................   ..   .  ........ .......?:.:. ^~^:JYYP5?JJJY7!G???7PGPYGG~!J7~~^^:^?~!?J^^^. ~BBPPY77!^:^?P~                               ..................  ..!.. ^~...~:.5~?YJ?77?!:.:JY!5?.:!!::::..::!PJ?YJ^. .7J!^:.:^^^:..................:!??7~:............................&#10;   ....................................  .     ................?:..::^^:^?5GG5JJYYYJ~YG?J?YGPY5G?~YJ7~^^^:^7~^:...    ~PP57.....!5^                              ..................  ..^....!~...~:.5~^YJJ?!7J?~::JJG~.~?!::^:::::.?G??J57. .^?!~^:.:^^:....................^!??7~:.........................&#10;   ....................................    ........:^::~.......!^..::^:..~5GG5JYYYJJ?^PPJJJGG55PY~?P?!^^^^.^7~!:        ^7?~::^~~^...                            .................   ..^ . :7^...!^.Y7.JJJJ!~7JY?77PY::7!7:~7:::::^.PGJ7?YY^. .!!^^^:.::::.....................:!??7~:......................&#10;   .............................................~::~.  ^^.^^.  ^~..^^^.:::5BGYYYYJ?J?~7BPYJYG5555~!P57~^^^^.~!^7^.    ....^^::.........                           ..............     .:  . ~7^:..!^.JJ.7JJJ?~^^75YJ5P^J!J?^~5~::::^:^GG5?7J57. .:~^::::.:::.......................:~7?!^:...................&#10;   ............................................^^   ...   .~...:7..:^:.::?BBPYYYY?J?77!JGPYJPP555!~YG?!~^^^^.~^^7^..  ...................     ..                     .......        .:   ..77^:.:!~.?Y.~JJJJ7^~!!5Y5P5!!5?:~PY::::^^.7GGPJ77YY^. .^~^::^:.::.........................:~77!^.................&#10;   .............................................~:   ^:  .^^....?..^^..:~PGBPYYYJ??77?G!YPPYYP55P7~?B57~^^^~~.^^~~:......................                                           .   ..:Y7^:.:7~:?5::JJJJJ~:!?7YPP7.~Y7:^5P7::^^^:.5PPG57!?Y?:...:^::^^:.::..........................:~77~:..............&#10;   ............................................^~  ..  .. .!... !::^:.:^JGBPGYYY???77PG57Y5P55P55?^!GP?7~^^^!~.^^^~.....................                                           .    ..~57^:.:7!:?Y!.7JJJJJ^:~J?5P^.7Y!^~Y55^:^:^^.^GPPGPJ!!?Y~....:^^^^^::::...........................:~77~:...........&#10;   .............................................:::~:  ~^::.....:~:^..:!YGPY55YJ?77!JG5P57?Y5P555J^~PP?7!~^^~7!.~^^~. .................                                           .    .:.J57^^.:77^?JJ.~J??JJJ~:^J5P!:YJ~!7JYPY:::^^^.7GPPPP5?!!??:....^^^^^::.:::...........................:~7!^.........&#10;   .................................................::::.........~^: .^!PBJ5YYYJ77!7PP555Y??JY5GPJ~~5PJ!7~^^^!J!.!^^!: ..............                                            .    :7.:PY?^^::7?!??5^:J????JJ!::JGY7P7!J!JY5P?:::^^:.YP55555Y7!!?!.....^^^^::..:::............................:~7!:......&#10;   ............................................................. ^!..~~YGP75YYJ?7!!YP555YJJJJJJ5GY~~Y5?!J!~^^~75~.7~:^:  .                                                           !J!.7GJ?~^::?J?J7Y7.7????J7?!^:YGGJ?YJ!YJJ5P!.::^^.:PP5555Y5J7!!!:.....^^^:::..:::.............................^77~:...&#10;   ..............................................................^~ ^^?G577PYJJ7!!?P555YJJJJJJJY55!~Y5?!Y7~^^^!?P^:YJ??^                          ..      ..                       :???^:5PJJ~^^:?JYJ7?J.~????J!~77~!PP?YJ!5YJJJ5P~.::^:.!GP5J55YY5J7!!^.....:^^^::...::::............................:~77^.&#10;   ..................................:?J?^~^....................:^:^^!PJ7!?PYJ?7!!Y555YJJJJJJ??J5Y!~J5?!?Y~~^^~7JG^:YJJY~                         ..                             .7J7??:7GYJJ!^^^?J5J77Y~:?777J?^!~!JJ5JJ7J5YYJ?YPP^..:::.?GPPJJ5YJJYJ7!~:... ..^^^:....::::.............................:!7&#10;   ................................:7?JJJJYJ^...................^^^^~5?^?~JPY??7!?555YJJJYJ????Y5Y!^?5?7!57~~^^7?P5~^5J?Y7.                                                    :!??7777:YPJJ?7^~~JJ5J7!J?:7777?J~:7!^?YY!5J5JYYJ?YP5:..:::.YPPPY?JYJ?JYJ7!~:... ..^^:......:^:..............................&#10;   ................................:?J?JJJJ?:..................:^~^^J7:!7~YP5?7775555J?JY??????YYJ!^?577~JY~~~^~7JY?^^5?7JJ^                                                 :^!7777!7!^5Y7J??~^~JYYJ7!7J:~?777J7^:7J!YJJ5Y5JJYY??YGY....:.:5PP55J7JYJ?JJJ7!~....  .:^:.....::^:............................&#10;   ..................................~JY7!?!...................^!:^7!::?~~YP5?77?555J?JY?????7JYJ?7^7P77~757~~^^77Y!?~^YJ??Y?^.                                           .:^::~!77!!?^75?7J??!~~?PYJ7!!J~:?!!!7?!^:!JY?5Y5YJJ?YY??YGJ....:.:5PP5YY77JJ???JJ?7~....  .:^:.....::^:..........................&#10;   ....................................:......................:~:^!~::^7~~JP5??7Y55Y??YJ??7777JY?77^!57!~~JJ!~~^!7?77?!^YJ7YJ??7~:.                                    .:^::::.~!!!!!7:J57!?J77~~7G5J7!!??:?!!!!7?7!^~YY5JPJJJ??YY??5G7......:5P5YJ5?!7?J?7??7?7~:...  .:^^.....:::.........................&#10;   ...........................................................^:^!~:::~!^~JP5JJJ5YYJ?JJ?77777?JJ77?~~Y7!!^7J!7~^~7!?777!~YJJJ777777!!^:..                           .:^:::::...^!~~~~~~YJ7!7J7?~~7YGJ!!!7J^?!!!!!!!77!?5?YJJJJJ7?YY??5G!......:5P5YJYY7!7??777!!7?~....  .:^::....:::.......................&#10;   .........................................................:::~!^:::.J~^~?P55YYYYY?JY?777777?J?!!?~~J?!!^!?777~~!!77!!!!7YYJ777!!!!777!!!~^::..                ..:^:::::.......Y5YJ?~!?J!~!???!!!!G5!!!!Y~J!~!!!7?JY5P5555GGGP5JJ5Y??5P~......:55YY?J5J!!7??777~~7?~....   .:^:.....::.....................&#10;   ........................................................:::~!^:::.7J^^^7PPP55YY?JJJ7777!!7?J!!!7!^??~~~~7?~?7~!7!?!!~~!7YJ?!!!!!!!!!!!!!!77!!!:::....    ..::^::::::.........7GGGG~77J!^~!7??7~~7P7!!!Y7J!!7?Y5GGBB#BB##BBBG5JJYP5J?5P^......:55JY?75P?!!7?77?!^^!7^.....  .:::.....:....................&#10;   .......................................................:.^!!^:::.~J?^^^7PPPPYYJ?JJ7!!!!!!7JJ!!!77^?J~~~^!?!!J7!7!7!~~~!!!JJ?7~~!!!!~~~!!!!!~!?::::::^^::^^:::::::............:PGG5:??J7!!!!7??~~~JJ~!~JJY7?JJYPGBB###G##B##BG5J?5GG5J5P^.:....:Y5??77YGY7!!77777~::~7^.....  .:::.....:..................&#10;   .....................................................:..~!!^^^^:~7?7^^^!PPPPYJ?JJ?!!!!!!!?5!!~!!7^7J~~~^~!7~?J??7!7~~~~~!!!7J7!~~~~~~~!~~!7J5J:::::::::::::::.......... ......~GG5:??JJ!?~~77?7~~~Y!~!JJPPG5JJP####BGP5GBBBBB#BPY5BBBP55^.:....:YY7?7!JPGJ!!!777?7~::!7~.....  ..::......................&#10;   ...................................................::.:!~~~:..:^~~J!^^^~5P5PYJ?J?7!!!!!~7YY~!~!!7~!J~^~^^~!~~JYJ?77~^~~~!!!~~7??!~~~^!!!7?5GBJ:::::::::::::.........      .....!GY:?~?Y7Y!.^!??7~~!J!!JJGBBG5B#BBBBGPPYJPGBGP5PGBG5GBBYJ5^.:.....JY77!!?5GP?!!!7777!^:^~!~:....   .::....:...............&#10;   ..................................................:..~7^^~~  .^:^~J!^^^~JGPPJJ???!!!~~~!7J7~~~!!!~^?!^^^^~~!~!YYJ?!7^^~~!~~~~^^~777~~~775BBBB!::::::::............         .....~7:77JY?Y^...!7?7~~!77YYBBBB##PGBBP5PP?7JYPBBGYJJ55YGPJ7J5^.:.....7Y!!!!?5PG57!!!7777~^:^^~~:....   .:::...:.............&#10;   ...................................................:!!^.:~: .:^:~~??^^^^7PGPJ???7~~~~~~!77!~~~!!!~^7?^^^^^~~~~!J5J!7!^~^~~~^^^^^^~~!!7??YGBB?::::..............              ...:^:77?5Y7.....~7J?!~!JPJYPGBPJJGBPJJ5P?!7JYYPBGJJJ??YP5J7?Y^.^.....~J!!~~7Y5GPY!!!!777!~^:^^~^:....   .::::.::...........&#10;   ...............................................:..^7~:::^~. .^.~~~?J~^^^~JGPJ???!~~~~~~7!7~!~~!~!^:~7!^^^^^^~^~~755?7~^^^^~^^^^^:...:JY??YY~.................                  .:^:!!!PY:......~7?J?!!J7^~~~^!Y55JJ??Y??!7JY7JYYYYY?7YGPJ77Y~:^:....^7!~~~7JYPP5J!!!!777!^^^^^:::.....  ..::..:..........&#10;   ................................................:!7^::::~~  ^.^~~!J77^^^:7PBJ??7~~~~~~!7^!~~^~~~!^^^!!~^^^::^~^~~~?Y5J~^^~^^^:......:JJ!~~..................                   :^^:^JYP!........~7~!??777~^^~YGGP7J?7?YJ?!7Y?!7YGGGGJ7YGPJ77J!:~:....:!!~~~7JYPPP5?!!!!!!!~^^^^...:.....  ..::.::........&#10;   ............................................:..^!!^::^::~^ :::!~~??!Y!^^.~JBY77!~~~~~~7^^~~~^~~~~^^^^!~^^^^::^^^~~^^~Y57:.::. .......??~^~................                    .^^^^:J5~?:.......:~J^.~??77!^^~7??7J?!!JJY?!JJ77~JBBG777JPPY7!J7^~~.....~!~~~!JYYP5PY!!!!!!~^^^^:..........   .:::^:......&#10;^. .............................................:~~~~::^:.^~::^.~~~777~?Y^^..75G77!^^^~~!!.!^~^~~~!^^^^:^7~^^^::::^^~~~^:^???::.........!7~^~:....                              :^^^^7~!7.!!::::::^:!GP!..^7???7~^~7?7~^^^~~~~!7!7!~7P?777!JPP?!!J?~!7. ...~!~~~!JJ7555Y7!!!!~~^^^^:..........    .:^^:.....&#10;!^.:......................................... .^^^~~:.::..~~:^.^!~!7!!!~G7^^.:?GJ7!^^^~~7^^!^~^~~~^^^^:::~7!^.....:^^!~~~^.:!:^.........:?!^~:...                              .^^:^75J~?!:?^::::^^!~!YY~:...~7?J?YY!~~~~~~~~~~^^^^^^^^~7YYJ55Y77!?Y!7?: ...^!~~~!??^JJJJ!!!!!!~^:^^:...........   .:~~^....&#10;^:.::........................................:~^^~^..^:...~^^.:7!!?7!!7:5P~^:.~?P7!^^^~~!:~~~~~~~:.......:~77~^:.:::^^7?!~~:..:::........~?~^~^                        .     .:^:^~?5Y^:7?!~?^::^^!BP7?!^~~:....^!7???7!!!~~~~~~~~^^^^^::~?PGG5?!7!?Y77J^....^!~~^!?7:7?7?~~!!!~~~^:^^:...........  .::~!^..&#10;^..::.......................................~~:^~^..^:...:~~:.~7^!?!!!7~~G?~:..~?Y!~^~~7~:~~~^:::.....:::::^~!7!^:..:::!5J7!~^^~!~::::::::77^^^.                      .      :^::~J5?::^^~777J^^^!GP~7?~~!!7YY~:...::~!7???77!!!~~~~~~!!!!!7?7JY!~7!?5?7J!... ^!~^~!?!.!7!7~^~!!~~!~::^^:........... .:.:!7^&#10;...:....................................:::!^:^~~..::....^!~.:?~^?!!!!!?:YJ!^...~??~^~~7^^~^....:..:::::::::^^:~77!~::::^J5?7777???!^::^~~!?7^^^.                    .     .:::^!Y5!::::^^:^~7J~^5P!~?5J777JJ7~~~^:......::^^^~~~~~!!!!!!77~^::~7~~7!?5J7J7:.. :~~^~!7^ ~7~7?!^^!!~!!^.:^:.............:..:7&#10;.  ....................................::^~::^~~..::.....~!:.7!:!?!!!!?J^^Y~!:...~?7~~!!::.........::.....:::^^^^~!7??7!~^!???5J?77777~:.::~?7^^:                  .:.    .^:::75Y^..:::::^^^^:7BP7~~!J!!!!~~^~~~~~~^^^^::........:::^^~~~^::....^^~7!75J!?J~....~~^~!!. ~!~75Y!^~!~~!~:.^^:............:. .&#10;^^:...................................::~~.::~~:.::......~~ :7:.?!~!!7J^~:7?^!.  .~!~~7^:......:...^.......::.:^^::^^~7?JY?!!7PB?7?7777!:.. .::^^^.               ::  ...::^^^?GY:.........:^::^!~~!~~J~~^::...:::::::::::::::^^^^^^^^^:::.........:~7!7Y?!7?7:. .^~^~!~. ^!~!5Y7~!7!~~!^..^:............:.&#10;!~:..................................:^!^.::^!:.::.......!..!^.~7~!!!J7.^~:?~^~.  .^~^!:...........:............::..::::^~?J?!!??J5YYY?77^.      .^:....       .::.  .  :^::^5B?.....    ....7G~......^:........              ....^::::::.....  ....:~!!7J7!~7?!:. :~^~!^..^~^!5Y!~!7?!~!~..:^:...........:.&#10;^.   ...  .....:.:::................:^!:.:::~^..^:......:~ :~..7~~!!J?~.^^^:?~^~^. .:~~:..     ........................::^^^:^!!77JJ7~::^~^..      ..:::.    ...      .....:5G^          .  ?G!...:.................. ..... ....:JG5P!......~^.    ..:~!!!?!~~~!?!: .~^~!: .^~^!YY7~~!??!~!^ .^^:..........:&#10;:. ..     :^...   .^^::.............~!..::.~~..^:.......^:.^:.~!~!!J??::^^^^~?^:~!:  .~!~:.  .........           .............::!!^~!!~^^^^^:::...    .^^::..         .   :5J.         ....^~:                          ........YB#PGG.     ~55?.     :~!~!7!~^^~!7!..~^~~. .^~^~!!!~~~7J7~!~. :^^..........&#10;~^^.      ::::     .^:^............!J..::.^~:.::........:..:..7~~~7?77.:^^^^^!?^:^!~. .:!!~:.      .:.          ............ ....~J:.^^^~!~^^^^::^..:^~!!~!~.            ~57          .:...          ....                       ..^7Y5?      J55!..    .^7~~7~^^^^~7?~:^^~~. .^^:^^^~!!~~?J!~!: .:^:........&#10;?7^::.....:^:.    .:::^...........75:.::.:~^.::....... .: .:.~~~~!?!7~.^^^^^~^!7^^^!~:. .^!!^:.    .:.       ....              . .JY..:......::^^~77!!!^...^!~.        .?5^         .:.. .......::^^^..                            ^YY5:     !557 ...    ^7~~!~^^:^^~7?!!^~^ ..^::^^:^^~~~7J?!!^...^:.......&#10;??77!^:::^~^:....::::::..........!P~.::..~~..::.. .... :.....!~~~?!!7:.^^^^~^^^~!^^~ .... .^~^^^:.  ..                    ....... :PJ..^..........:~~~^^^:..:!7^.     :JJ.         .:..............                               .:JY5!     ^55J   ....  :!!~!~:^:^^^~77!~~: ..^..^^^^^:^~!?J7!~...:^:.....&#10; .~777!~^^^^::^::::::...........^57..^:.^~:.::. . .....:... ^~~~77~!7..^:^^~^:^~~~~:    ... .^~:::^:::              ...............~GJ.:^...........^^^:^^:::.^7~:   ^5?         .:....:::...            .....                    .:?55?     :55Y      ... .~~~!^::::^^^!7!~^. ..^..^^^^:::::!JJ!~:...^::...&#10;.  ...::::........:::..........:5J:.::.:~~..^:... ... :: ...!~~!?~~!!.:^:^^^^:::~~7:      ... .^~^..^~^.       .....................^7. ...  .       :^:::..:::^7!:.7G~        ..:.::^~^..         ...::^!~:.                     ..?55J     :YYY.        ....^~7^^:::^^^~!!~^...:^..^^^^.::..:7J7!^...:^:..&#10;!!^::::::.......:.::::.........?Y~.::..^~:.::........:?... ^!^~7!^!!!.::::^::::::~~~^:..  ..... .:~^..^^~^.  .................   .    ^?. ..          ^^..:  .::^7!!P:       ...:::^^:.       ...::::.....      ..               ..:?5YY.    :YYY.           ....^^^::::^^^~~~^...^:..^^^::^:...:7J!~...:^^.&#10;777!~~^^^::::::.:::^:::.......:J7:.^:..~~.:^:.......^?7....~~~!7^~!!!.:::^^.:::::^7~!!!~~^^:.......:~^:..:!~:..............           .Y?  ..         .~^... ...:!?!^        .::::..    ......:::...           .......         ....:75YY.    ^BGY.             ..  .:::::^^^^~~^...^..:^^:.^:.....:!7!:...^^&#10;?77!!!~~^^^:::::^:::::........!7!.:^..^~:.::.......~!J~ . .!^~7~^~!7!.:::::.::.::~~^~!!!!~~^:.........^~^.:^~!^..........              .7?. ..         .!:......!5!!!.      .::......::^:......           ....::..          ......::?5YY.    7B#5                .   .^^::^^^^^~^...^..:^^::^.......:~!^...^&#10;J??7!!!~~^^^:^^^::::.........^7!^.::..~~..^:.....:~~7J^ . ^~^!!^^~!7!.:::::.::.::~..:^~~~~~~~~^:.......:^~~:.:~!^.....                   !5^ ..         ~!.. .:JJ. .!:   ..:..::::::.........      ....::^^^^~:.    .............::^Y55J      :?!                 ..  :^^::::::^~^..:^..^^::^:........^!~...&#10;YJ??77!!~^^^^^:::... ........^77::^:..~^.:^.....:~:~!J: ..!~~!^^^~~7~.::^::.::..:!:  ..:^^:^!!!~~^:..:!:..:~!^:.~!:                       ~J. ..        ..   ^5!    :^   ...:.....  ...........:..:......::..     ..............::^~5557                            .  ^^^::::::^~^..^: :^^^^:.........:!~:.&#10;JJJ??7!~~^^^^::.............:^7!.^^..:~^.::....^^.:!!?.. .!^!~^^~~~~^.::^^:..:..^!!.    .::....:^^!7??~.....^!7~::~^.                       .!...          .7J.     .^   .7Y:    .........::::...      ...     ..:^^^^^^^^^~~!?JY5PGGY5^                             . .^^:::::::^~^..~..^^^^^...........~!^&#10;?!!??!~^^^:.................^:?!:^^..:~:.::...^^..:!!7.. :!^!~^^~~~:^.:.^^:..:..~^:::......:.....^~7?!!!~:....^!7!^~!.                     :JP55Y7!:      ~Y!       :.  ^5P^    .:::::::::..         ...    ..:~~~~~~~~!!!777J#B####GYY.    YJ^                       . .^^:.:::::^~:.^^..^^^^:...........^!&#10;!!7!7~:^:..................:^:?!:::..^~:.::..~^...~!!7.. ^~~!^^~~~::~...^^:..:..~^..:~~......:.:^^~~....:^~^.. .^7?!!7:                   757::?5?~?Y~..:??.        :.:JBG?7:    ....             ........:::::::::....::::^!?BBB###G5!    :P#5.                       . .^^:.:::::^^:.~:.:^^::............:&#10;7~!!7?!^:..................:::?~:^:..^~..::.~:..:.7~!7...!~!~^^~~:::^...^^^.....~^^^...^^:....::::~...    .:^:.  .^!77?.                 ^P7    .7?~~Y5??:       .:^YGGPYJJPB?                  .......:^^:..    ............^PBBB##BP:    YGG~                         . .:::.:::::^^::~..^^^::...........&#10;J7!~~7JJ^::................:::?~:^:..^~..:^~: .:.:7~!?. .!~7~^~~:::..:..^^~.....~~:......:::....^^....       .::... .^77.                !5~     .~?JJPG7     .~YG#BGJ^...:!BG.                .....:^::.            .........^GBB#BBP:.. ^55Y                           ..  .:::::::^::^^.:^^:::...........&#10;YY7~~~!77~^:...............:.:?!:^:..:~:.^^:..:: ~7~!?. .!~7^^!^:::..^..:^!....::........ .:^^^~~.......        ....  .!!:               ^5J.  ....~??JYBG!:^YB#BP?^.      ^BG.              .::::::.                 .......:.^GB#GP!....Y55!                            .    ^^:::::~::^::^^^:::..........&#10;5YJ!~~~!7?7^:..............:..7!:^:..:^::^:..::..!!~!?. .!!7^!^:::...:..:^~^..:!.............:~7^...   .....      ...   ~!~              .^!?77!!7Y5!~~7P##B##5!.          !GY                                         .......:.!B#GY:.. ~5YY.                             .    :^::^:^^.^^:^^^::::.........&#10;555?!!!!!!?J555?~:.........:..~!:^:..:^^^^:.:.. .!~~!J. .!77!~^:^:...:...^~~...^~:..... ...:::~^......      ...     ..  :.^!              .:..^!7~~~~!Y#G7^!BBPY!^:..     :55:                                         ..........J#GJ....Y55!                               .     :^^^:~^:^:^^^^:::.........&#10;5P55J77777?J5G#B5YJ~::.....:..:!^^:...^^::::... :!~~!J: .~7?!^^:^:....:..^^~....^:...   ..:.:^~....                 .   .. :!             :~!~^:....:?G!   :5B^^!7??Y555YYGG:                                           .........:BG!....5BG7                                .      .^^:~:^^:^:^^::^........&#10;Y55YJ!:...:^~!J~^~?5J7^:.......~^^^..:^^::^:....:!~~!Y^ :~?7~^~^::....^..^^~:..:^.... ...:.:^^:....                 .   ::  .~          ...:^.      ^B!  ...~B? ..:..::^~!~.                                             .........?P^....?BBY                                 ..      ^^^^:~:^::^^:::.......&#10;???7.           .~!!Y557:::....^~^^::^:^^^::....^!~~~J~ :~7~~^^^:::....:.:^~~..^:.......:::^^^....                 .    ~.   :.          ...        ?B:..    5B.  .                                                       ........:Y:..:.7PB5                               .  :.      :^~:^^^^::^::::......&#10;Y7:       ..    ..7!~~JBY^.::...~^^^^:.:^:.:....~~~~~J7 .!!~^::^^:::...:..^~^:.^.......::.::::...                      .:     .      .....          JB:      :BY                                                           ........7:..::Y555.                                 .^.      :~~^~:^::^^::^:.....&#10;?      .:~:.......:^~~~7GG! .~:.:~^^^..^^^.:.. .!~~~~?J..!7~^:::^^:::.....:^^^.:..:...:::.::^....                     .:             ...           .J#~       ~#7  .                                                        .......^:...:JBGP.                                  .^.      .!^!^^:::^^.:^.....&#10;    .....      ...  ..:~!P#J ~57^^^^:.^^.:^:....!~~~~7Y:.77~::^..^^:::..:.:^~^~:..::::::...:^...                     ..             ..            . :BP        7B~                                                          .......:^....!#BB^                                   .^...... ..::^^:::^::^:....&#10;..           .........::!!P#^ ~5Y~^^^^^...^:.. :7~~~^7Y~.7J^::^...:^:::..:.^~^^...::::::....:....                                  :.           .    ?B~        ?B~                                                          ......:^.....75G7...                                 .::::...      .::^^::::...&#10;         ...          ..^!!P7  7557^^^:....... :7~~~^!Y~.!5~:::....:^^::....~~^...::::......:....                                 ..           .     .J5^        7B!                                                         ......:J...... ..                                     .^^^::::.       ..::::..:&#10;      ...         ........~!!   J5Y::^^......  :?!~~~~!^:^57:^:......:^::::.^!:....::.......:....                                ..                   .?5^        ~P7                                                        ......^B:.....                                         .^:^:^^:.        ...^::.&#10;   ..          ...     ..:!7!^  ^55?  :^:.:..  ^?!~~~~^^^.J?^::........^:::::!.............:::...                               ..          .           !57        ^5J.                                                     .......7#?......                                         .:::......   ...   .^^:&#10;  ..        ...           :~7!^ .GP5.   :^...  ^?!~~^~^^~:!?~:^:........:::::^.......:::::.:::....                             ..         ..             :YJ.      .:?5!                                                   ........!BB:....J57.                                        .:::........      ^^:&#10;         ...        :!!~^:.:~7!  PBG:    ...   :?7~~~^::~~:?!~::..........::^:...:..::::::::::......                           :         ..               .75!     .. ^5Y:                                               .........:^Y#7... ~BBB~                                        .:^^::..   ..    ^^:&#10;       .:.        :?PGGPPY?!!77. PBB:      ..  :??~~~^::^!:!!~^^:...........:.....:.::::::.:::........                        :.        ..                  :YY:   ..  .757.                                          ............~:~BG... .Y55?                                           .:^^:    .....^^:&#10;       .        .7PGPJ77!!!7?J?..PBB.       .:..?J!~^::::~!^!^^^^:................:::::::.....:..........    .               .:        ..                    .~5?. .   ..:J5!                                ..  ............::::^^:.Y#7    75Y5.                                            .:^:      ..^^^&#10;       .      .~5GGP5Y7!~~~~!!?^.GBG.         . .!7~~:::.~!~^~^:^^:...........:.....:::::.....:...........   ....           .^.       ..                     ...757:    ...^5P~                         ... .... .....:::::^:::::!^:.:GG.   .5Y5!                                              .::     .:^~^&#10;             .7BP5PP55Y7~~^^~~!!:.!?.          .  .^~^^:.^!!^^^^:::......:.......:.....:::.....:........... ..::.....      .:~.  ..   :.                      .. ^55:  ... ..^YY^..                    ... ......:..::^^^^^^^^^^!~^~:.7#7    !5YY                                            ...:::.......~^&#10;~            :^J5J5555YY?!~^^^~!!:                  .::. ...             .::...:..:::..........:........... :::::.:.::......^^ ..... .:.                      . .^^JG7....  ..:7^.::.   ...........  ..:...::...::.:^^^^^^^^^^^~~^::~^:YB.   .YY5^                                                .:..  ..:^&#10;P!  .         .:~JJYY55YYJ!~^^^~~!^                   ..                   ::........:::........:.......... .::::..::^::::::~:.......^:...               ..  ....^~^^GY^::...~!77!~..:............ ......::::..:::::^^^^^^^^^^~~^^^::^^~GJ    ^55J                                                  .....~~~&#10;PB^  .         ..^7JJYY55YJ7~~^^^~!~.                  ...                  .:.....:....::.......:....:......:.:::.::^:::::^~..::::::^^:........................::^~.!!..~:..^!!~~!:.~~::::::::.........:::::..::::^^^^^^^^^^^~:^^^:.::::5~    ?55!                                                   ...~!!&#10;5BB~            ..:!JJJY55YY7~~~^^~??.           .        ..                ..::....::...........::....:::.......::.::^::::^~.:::::::^:^::...........:::....::..::~~^77^:!^:::~!!!^~!!..^:::::.:::.....::::^:..:::^^^^^^^^::^!^::^^^:.::.:J.   .Y55^                                                     ..^&#10;.5B?             ..:~?JJY55P?.!!!!~!?~.           .         .                .....::.:::..........^:..:..:::..::...:..:::::~^:::::::^^::^::::::::::::::...::::..::~.^777^.:^::^~!!!^!J~.:^::::::::::..:^:^^^..::::^^^^^^^^::7!~^::^^^.::: :~    :GBG:&#10; .:                ..:~!!!777:~~^^^^~.^                                         ...................^. ....... ........ ....:........::........................ ..::.^^^~^:::....^^^:.^~:............ .:...:. ........::::..:^^::....:....  ..    .~?J.&#10; */&#10;/*&#10; * powered by ANDRIY POPYK&#10; * in honor of MYSELF and SEGMENT DECOMPOSITION and N^(log(N)) and (Harry Potter and the Methods of Rationality) and Monkie D. Luffy&#10;*/&#10;#include &lt;bits/stdc++.h&gt;&#10;#include &lt;ext/pb_ds/assoc_container.hpp&gt;&#10;&#10;//#pragma GCC optimize(&quot;O3&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,fma&quot;)&#10;//#pragma GCC optimization (&quot;unroll-loops&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,sse,sse2,sse3,sse4,popcnt&quot;)&#10;&#10;using namespace std;&#10;using namespace __gnu_pbds;&#10;#define int long long&#10;#define float long double&#10;#define elif else if&#10;#define endl &quot;\n&quot;&#10;#define mod 1000000007&#10;#define pi acos(-1)&#10;#define eps 0.000000001&#10;#define inf 1000'000'000'000'000'000LL&#10;#define FIXED(a) cout &lt;&lt; fixed &lt;&lt; setprecision(a)&#10;#define all(x) x.begin(), x.end()&#10;#define rall(x) x.rbegin(), x.rend()&#10;#define time_init auto start = std::chrono::high_resolution_clock::now()&#10;#define time_report                                       \&#10;    auto end = std::chrono::high_resolution_clock::now(); \&#10;    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count() &lt;&lt; &quot; ms&quot; &lt;&lt; endl&#10;#define debug(x) \&#10;    { cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; }&#10;#define len(x) (int) x.size()&#10;#define sqr(x) ((x) * (x))&#10;#define cube(x) ((x) * (x) * (x))&#10;#define bit(x, i) (((x) &gt;&gt; (i)) &amp; 1)&#10;#define set_bit(x, i) ((x) | (1LL &lt;&lt; (i)))&#10;#define clear_bit(x, i) ((x) &amp; (~(1LL &lt;&lt; (i))))&#10;#define toggle_bit(x, i) ((x) ^ (1LL &lt;&lt; (i)))&#10;#define low_bit(x) ((x) &amp; (-(x)))&#10;#define count_bit(x) __builtin_popcountll(x)&#10;#define srt(x) sort(all(x))&#10;#define rsrt(x) sort(rall(x))&#10;#define mp make_pair&#10;#define maxel(x) (*max_element(all(x)))&#10;#define minel(x) (*min_element(all(x)))&#10;#define maxelpos(x) (max_element(all(x)) - x.begin())&#10;#define minelpos(x) (min_element(all(x)) - x.begin())&#10;#define sum(x) (accumulate(all(x), 0LL))&#10;#define product(x) (accumulate(all(x), 1LL, multiplies&lt;int&gt;()))&#10;#define gcd __gcd&#10;#define lcm(a, b) ((a) / gcd(a, b) * (b))&#10;#define rev(x) (reverse(all(x)))&#10;#define shift_left(x, k) (rotate(x.begin(), x.begin() + k, x.end()))&#10;#define shift_right(x, k) (rotate(x.rbegin(), x.rbegin() + k, x.rend()))&#10;#define is_sorted(x) (is_sorted_until(all(x)) == x.end())&#10;#define is_even(x) (((x) &amp;1) == 0)&#10;#define is_odd(x) (((x) &amp;1) == 1)&#10;#define pow2(x) (1LL &lt;&lt; (x))&#10;&#10;struct custom_hash {&#10;    static uint64_t splitmix64(uint64_t x) {&#10;        // http://xorshift.di.unimi.it/splitmix64.c&#10;        x += 0x9e3779b97f4a7c15;&#10;        x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;&#10;        x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;&#10;        return x ^ (x &gt;&gt; 31);&#10;    }&#10;&#10;    size_t operator()(uint64_t x) const {&#10;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();&#10;        return splitmix64(x + FIXED_RANDOM);&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;using min_heap = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using max_heap = priority_queue&lt;T, vector&lt;T&gt;, less&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_multiset = tree&lt;T, null_type, less_equal&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;template&lt;typename T&gt;&#10;using matrix = vector&lt;vector&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using graph = vector&lt;vector&lt;T&gt;&gt;;&#10;using hashmap = gp_hash_table&lt;int, int, custom_hash&gt;;&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; vect(int n, T val) {&#10;    return vector&lt;T&gt;(n, val);&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;T&gt;&gt; vect(int n, int m, T val) {&#10;    return vector&lt;vector&lt;T&gt;&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt; vect(int n, int m, int k, T val) {&#10;    return vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(n, vector&lt;vector&lt;T&gt;&gt;(m, vector&lt;T&gt;(k, val)));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt; vect(int n, int m, int k, int l, T val) {&#10;    return vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt;(n, vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(m, vector&lt;vector&lt;T&gt;&gt;(k, vector&lt;T&gt;(l, val))));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;matrix&lt;T&gt; new_matrix(int n, int m, T val) {&#10;    return matrix&lt;T&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;graph&lt;T&gt; new_graph(int n) {&#10;    return graph&lt;T&gt;(n);&#10;}&#10;&#10;template&lt;class T, class S&gt;&#10;inline bool chmax(T &amp;a, const S &amp;b) {&#10;    return (a &lt; b ? a = b, 1 : 0);&#10;}&#10;&#10;template&lt;class T, class S&gt;&#10;inline bool chmin(T &amp;a, const S &amp;b) {&#10;    return (a &gt; b ? a = b, 1 : 0);&#10;}&#10;&#10;using i8 = int8_t;&#10;using i16 = int16_t;&#10;using i32 = int32_t;&#10;using i64 = int64_t;&#10;using i128 = __int128_t;&#10;using u8 = uint8_t;&#10;using u16 = uint16_t;&#10;using u32 = uint32_t;&#10;using u64 = uint64_t;&#10;using u128 = __uint128_t;&#10;&#10;template&lt;typename T&gt;&#10;using vec = vector&lt;T&gt;;&#10;&#10;using pII = pair&lt;int, int&gt;;&#10;template&lt;typename T&gt;&#10;using enumerated = pair&lt;T, int&gt;;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".sm" value="signed main(){&#10;ios_base::sync_with_stdio(false);&#10;cin.tie(nullptr);&#10;cout.tie(nullptr);&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".query" value="int q;&#10;cin&gt;&gt;q;&#10;while(q--)&#10;    $name$();" description="" toReformat="true" toShortenFQNames="true">
    <variable name="name" expression="variableOfType()" defaultValue="solve" alwaysStopAt="true" />
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".vs" value="void solve(){&#10;    int n;&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".alphabet" value="&quot;abcdefghijklmnopqrstuvwxyz&quot;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".dsu" value="struct DSU {&#10;public:&#10;    DSU() : _n(0) {}&#10;    explicit DSU(int n) : _n(n), parent_or_size(n, -1) {}&#10;&#10;    int unite(int a, int b) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        assert(0 &lt;= b &amp;&amp; b &lt; _n);&#10;        int x = leader(a), y = leader(b);&#10;        if (x == y) return x;&#10;        if (-parent_or_size[x] &lt; -parent_or_size[y]) std::swap(x, y);&#10;        parent_or_size[x] += parent_or_size[y];&#10;        parent_or_size[y] = x;&#10;        return x;&#10;    }&#10;&#10;    bool one(int a, int b) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        assert(0 &lt;= b &amp;&amp; b &lt; _n);&#10;        return leader(a) == leader(b);&#10;    }&#10;&#10;    int leader(int a) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        if (parent_or_size[a] &lt; 0) return a;&#10;        return parent_or_size[a] = leader(parent_or_size[a]);&#10;    }&#10;&#10;    int size(int a) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        return -parent_or_size[leader(a)];&#10;    }&#10;&#10;    std::vector&lt;std::vector&lt;int&gt;&gt; groups() {&#10;        std::vector&lt;int&gt; leader_buf(_n), group_size(_n);&#10;        for (int i = 0; i &lt; _n; i++) {&#10;            leader_buf[i] = leader(i);&#10;            group_size[leader_buf[i]]++;&#10;        }&#10;        std::vector&lt;std::vector&lt;int&gt;&gt; result(_n);&#10;        for (int i = 0; i &lt; _n; i++) {&#10;            result[i].reserve(group_size[i]);&#10;        }&#10;        for (int i = 0; i &lt; _n; i++) {&#10;            result[leader_buf[i]].push_back(i);&#10;        }&#10;        result.erase(&#10;                std::remove_if(result.begin(), result.end(),&#10;                               [&amp;](const std::vector&lt;int&gt; &amp;v) { return v.empty(); }),&#10;                result.end());&#10;        return result;&#10;    }&#10;&#10;private:&#10;    int _n;&#10;    // root node: -1 * component size&#10;    // otherwise: parent&#10;    std::vector&lt;int&gt; parent_or_size;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".crt" value="// @param b `1 &lt;= b`&#10;// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 &lt;= x &lt; b/g&#10;constexpr std::pair&lt;long long, long long&gt; inv_gcd(long long a, long long b) {&#10;    a = safe_mod(a, b);&#10;    if (a == 0) return {b, 0};&#10;&#10;    // Contracts:&#10;    // [1] s - m0 * a = 0 (mod b)&#10;    // [2] t - m1 * a = 0 (mod b)&#10;    // [3] s * |m1| + t * |m0| &lt;= b&#10;    long long s = b, t = a;&#10;    long long m0 = 0, m1 = 1;&#10;&#10;    while (t) {&#10;        long long u = s / t;&#10;        s -= t * u;&#10;        m0 -= m1 * u;  // |m1 * u| &lt;= |m1| * s &lt;= b&#10;&#10;        // [3]:&#10;        // (s - t * u) * |m1| + t * |m0 - m1 * u|&#10;        // &lt;= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)&#10;        // = s * |m1| + t * |m0| &lt;= b&#10;&#10;        auto tmp = s;&#10;        s = t;&#10;        t = tmp;&#10;        tmp = m0;&#10;        m0 = m1;&#10;        m1 = tmp;&#10;    }&#10;    // by [3]: |m0| &lt;= b/g&#10;    // by g != b: |m0| &lt; b/g&#10;    if (m0 &lt; 0) m0 += b / s;&#10;    return {s, m0};&#10;}&#10;&#10;pair&lt;int, int&gt; crt(const std::vector&lt;long long&gt; &amp;r, const std::vector&lt;long long&gt; &amp;m) {&#10;    assert(r.size() == m.size());&#10;    int n = (int) (r.size());&#10;    int r0 = 0, m0 = 1;&#10;    for (int i = 0; i &lt; n; i++) {&#10;        assert(1 &lt;= m[i]);&#10;        long long r1 = safe_mod(r[i], m[i]), m1 = m[i];&#10;        if (m0 &lt; m1) {&#10;            std::swap(r0, r1);&#10;            std::swap(m0, m1);&#10;        }&#10;        if (m0 % m1 == 0) {&#10;            if (r0 % m1 != r1) return {0, 0};&#10;            continue;&#10;        }&#10;        // assume: m0 &gt; m1, lcm(m0, m1) &gt;= 2 * max(m0, m1)&#10;&#10;        // (r0, m0), (r1, m1) -&gt; (r2, m2 = lcm(m0, m1));&#10;        // r2 % m0 = r0&#10;        // r2 % m1 = r1&#10;        // -&gt; (r0 + x*m0) % m1 = r1&#10;        // -&gt; x*u0*g = r1-r0 (mod u1*g) (u0*g = m0, u1*g = m1)&#10;        // -&gt; x = (r1 - r0) / g * inv(u0) (mod u1)&#10;&#10;        // im = inv(u0) (mod u1) (0 &lt;= im &lt; u1)&#10;        long long g, im;&#10;        std::tie(g, im) = inv_gcd(m0, m1);&#10;&#10;        long long u1 = (m1 / g);&#10;        // |r1 - r0| &lt; (m0 + m1) &lt;= lcm(m0, m1)&#10;        if ((r1 - r0) % g) return {0, 0};&#10;&#10;        // u1 * u1 &lt;= m1 * m1 / g / g &lt;= m0 * m1 / g = lcm(m0, m1)&#10;        long long x = (r1 - r0) / g % u1 * im % u1;&#10;&#10;        // |r0| + |m0 * x|&#10;        // &lt; m0 + m0 * (u1 - 1)&#10;        // = m0 + m0 * m1 / g - m0&#10;        // = lcm(m0, m1)&#10;        r0 += x * m0;&#10;        m0 *= u1;  // -&gt; lcm(m0, m1)&#10;        if (r0 &lt; 0) r0 += m0;&#10;    }&#10;    return {r0, m0};&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".int_sqrt" value="int int_sqrt(int x) {&#10;    long long ans = 0;&#10;    for (int k = 1LL &lt;&lt; 30; k != 0; k /= 2) {&#10;        if ((ans + k) * (ans + k) &lt;= x) {&#10;            ans += k;&#10;        }&#10;    }&#10;    return ans;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".phi" value="int phi (int n) {&#10;&#9;int result = n;&#10;&#9;for (int i=2; i*i&lt;=n; ++i)&#10;&#9;&#9;if (n % i == 0) {&#10;&#9;&#9;&#9;while (n % i == 0)&#10;&#9;&#9;&#9;&#9;n /= i;&#10;&#9;&#9;&#9;result -= result / i;&#10;&#9;&#9;}&#10;&#9;if (n &gt; 1)&#10;&#9;&#9;result -= result / n;&#10;&#9;return result;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".sieve" value="class EratosthenesSieve {&#10;public:&#10;    vector&lt;bool&gt; sieve;&#10;    vector&lt;int&gt; primes;&#10;&#10;    EratosthenesSieve(int N = 1000000) {&#10;        sieve.resize((int) N, true);&#10;        sieve[0] = sieve[1] = false;&#10;        for (int i = 2; i &lt; (int) N; i++) {&#10;            if (sieve[i]) {&#10;                primes.push_back((int) i);&#10;                for (int j = i + i; j &lt; (int) N; j += i) {&#10;                    sieve[j] = false;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    bool isPrime(int n) {&#10;        if (n &gt;= sieve.size()) {&#10;            throw exception();&#10;        }&#10;        return sieve[n];&#10;    }&#10;};&#10;&#10;EratosthenesSieve sieve(1000000);" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".printer" value="template&lt;typename T, typename U&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair&lt;T, U&gt; &amp;p) {&#10;    os &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;)&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;v) {&#10;    os &lt;&lt; &quot;{&quot;;&#10;    for (int i = 0; i &lt; v.size(); ++i) {&#10;        if (i) os &lt;&lt; &quot;, &quot;;&#10;        os &lt;&lt; v[i];&#10;    }&#10;    os &lt;&lt; &quot;}&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const set&lt;T&gt; &amp;v) {&#10;    os &lt;&lt; &quot;[&quot;;&#10;    for (auto it = v.begin(); it != v.end(); ++it) {&#10;        if (it != v.begin()) os &lt;&lt; &quot;, &quot;;&#10;        os &lt;&lt; *it;&#10;    }&#10;    os &lt;&lt; &quot;]&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;typename T, typename U&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const map&lt;T, U&gt; &amp;v) {&#10;    os &lt;&lt; &quot;[&quot;;&#10;    for (auto it = v.begin(); it != v.end(); ++it) {&#10;        if (it != v.begin()) os &lt;&lt; &quot;, &quot;;&#10;        os &lt;&lt; it-&gt;first &lt;&lt; &quot; = &quot; &lt;&lt; it-&gt;second;&#10;    }&#10;    os &lt;&lt; &quot;]&quot;;&#10;    return os;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".median_finder" value="/**&#10; * @brief  A data structure that allows you to find the median in O(log(n)) time and O(n) memory&#10; * @author maksym&#10; * @date   2023-16-05&#10; * @note   You can add and delete elements from this structure&#10; * @note   You can get median in O(1) time&#10; * @note   If the size of the structure is even, then the median will be the pair of elements in the middle&#10; * @note   If the size of the structure is odd, then the median will be the middle element&#10; * @note   If the size of the structure is 0, then the median will be undefined&#10; * @param  T The type of elements in the structure&#10; * @param  Compare The type of comparator for elements in the structure&#10; */&#10;&#10;template&lt;typename T, typename Compare = less&lt;T&gt;&gt;&#10;class median_finder {&#10;&#10;    template&lt;typename Comp&gt;&#10;    class reverse_compare {&#10;    public:&#10;        Comp comp;&#10;&#10;        bool operator()(const T &amp;a, const T &amp;b) const {&#10;            return comp(b, a);&#10;        }&#10;    };&#10;&#10;private:&#10;    multiset&lt;T, Compare&gt; r;&#10;    multiset&lt;T, reverse_compare&lt;Compare&gt;&gt; l;&#10;    int sz = 0;&#10;&#10;    void balance() {&#10;        while (l.size() &gt; r.size()) {&#10;            r.insert(*l.begin());&#10;            l.erase(l.begin());&#10;        }&#10;        while (r.size() &gt; l.size() + 1) {&#10;            l.insert(*r.begin());&#10;            r.erase(r.begin());&#10;        }&#10;&#10;    }&#10;&#10;public:&#10;    void insert(T x) {&#10;        if (sz == 0) {&#10;            r.insert(x);&#10;        } else if (sz == 1) {&#10;            if (Compare()(x, *r.begin())) {&#10;                l.insert(x);&#10;            } else {&#10;                l.insert(*r.begin());&#10;                r.erase(r.begin());&#10;                r.insert(x);&#10;            }&#10;        } else {&#10;            if (Compare()(x, *r.begin())) {&#10;                l.insert(x);&#10;            } else {&#10;                r.insert(x);&#10;            }&#10;        }&#10;        sz++;&#10;        balance();&#10;    }&#10;&#10;    void erase(T x) {&#10;        if (r.find(x) != r.end()) {&#10;            r.erase(r.find(x));&#10;        } else {&#10;            l.erase(l.find(x));&#10;        }&#10;        sz--;&#10;        balance();&#10;    }&#10;&#10;    pair&lt;T, T&gt; getMedian() {&#10;        if (sz % 2 == 0) {&#10;            return {*l.begin(), *r.begin()};&#10;        } else {&#10;            return {*r.begin(), *r.begin()};&#10;        }&#10;    }&#10;&#10;    vector&lt;T&gt; getSorted() {&#10;        vector&lt;T&gt; ans;&#10;        for (auto it = l.rbegin(); it != l.rend(); it++) {&#10;            ans.push_back(*it);&#10;        }&#10;        for (auto it: r) {&#10;            ans.push_back(it);&#10;        }&#10;        return ans;&#10;    }&#10;&#10;&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".mo" value="&#10;struct query {&#10;    int l, r, id;&#10;};&#10;&#10;template&lt;typename T, typename U = T&gt;&#10;interface MoDataStructure {&#10;    virtual void add(T x, bool start) = 0;&#10;&#10;    virtual void remove(T x, bool start) = 0;&#10;&#10;    virtual U get() = 0;&#10;};&#10;&#10;template&lt;typename T, typename U = T&gt;&#10;class Mo {&#10;private:&#10;    vector&lt;query&gt; queries;&#10;    int block_size;&#10;    int n;&#10;    int q;&#10;    vector&lt;T&gt; v;&#10;&#10;public:&#10;    Mo(vector&lt;T&gt; &amp;v, vector&lt;query&gt; &amp;queries) {&#10;        this-&gt;v = v;&#10;        this-&gt;queries = queries;&#10;        n = v.size();&#10;        q = queries.size();&#10;        block_size = sqrt(n);&#10;    }&#10;&#10;    vector&lt;U&gt; solve(MoDataStructure&lt;T, U&gt; &amp;ds) {&#10;        vector&lt;U&gt; ans(q);&#10;        sort(all(queries), [](query a, query b) {&#10;            return a.r &lt; b.r;&#10;        });&#10;        int l = 0, r = -1;&#10;        for (auto &amp;q: queries) {&#10;            while (r &lt; q.r) {&#10;                ds.add(v[++r], false);&#10;            }&#10;            while (r &gt; q.r) {&#10;                ds.remove(v[r--], false);&#10;            }&#10;            while (l &lt; q.l) {&#10;                ds.remove(v[l++], true);&#10;            }&#10;            while (l &gt; q.l) {&#10;                ds.add(v[--l], true);&#10;            }&#10;            ans[q.id] = ds.get();&#10;        }&#10;        return ans;&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".adgq" value="const int DIM = 500005;&#10;vector&lt;$TYPE1$&gt; segment_tree[4 * DIM];&#10;bool ask[DIM];&#10;$TYPE2$ ask_val[DIM];&#10;$TYPE3$ ask_ans[DIM];&#10;&#10;&#10;struct update {&#10;&#10;};&#10;&#10;stack&lt;update&gt; updates;&#10;&#10;&#10;$TYPE3$ get(){&#10;    &#10;}&#10;&#10;void apply($TYPE4$) {&#10;    &#10;}&#10;&#10;&#10;void rollback() {&#10;&#10;}&#10;&#10;&#10;void add_segment(int node, int l, int r, int u, int v, $TYPE1$ val) {&#10;    if (v &lt; l || r &lt; u) return;&#10;    if (u &lt;= l &amp;&amp; r &lt;= v) {&#10;        segment_tree[node].push_back(val);&#10;        return;&#10;    }&#10;    int mid = (l + r) &gt;&gt; 1;&#10;    add_segment(node &lt;&lt; 1, l, mid, u, v, val);&#10;    add_segment(node &lt;&lt; 1 | 1, mid + 1, r, u, v, val);&#10;}&#10;&#10;void dfs(int node, int tl, int tr, int size) {&#10;&#10;    for (auto &amp;val: segment_tree[node]) {&#10;        apply($TEXT$);&#10;    }&#10;&#10;&#10;    if (tl == tr) {&#10;        if (ask[tl])&#10;            ask_ans[tl] = get();&#10;&#10;        return;&#10;    }&#10;&#10;    int mid = (tl + tr) &gt;&gt; 1;&#10;&#10;    dfs(node &lt;&lt; 1, tl, mid, updates.size());&#10;    dfs(node &lt;&lt; 1 | 1, mid + 1, tr, updates.size());&#10;    while (updates.size() &gt; size)&#10;        rollback();&#10;&#10;}&#10;" description="add delete get query" toReformat="false" toShortenFQNames="true">
    <variable name="TYPE1" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TYPE2" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TYPE3" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TYPE4" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TEXT" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".range_fenvik" value="template&lt;typename T&gt;&#10;struct range_fenvik {&#10;private:&#10;    vector&lt;T&gt; diff_tree;&#10;    vector&lt;T&gt; diff_mul_tree;&#10;&#10;    void _add(int id, T val) {&#10;        for (int i = id; i &lt; len(diff_tree); i += low_bit(i)) {&#10;            diff_tree[i] += val;&#10;            diff_mul_tree[i] += val * id;&#10;        }&#10;    }&#10;&#10;    void _add_range(int l, int r, T val) {&#10;        _add(l, val);&#10;        if (r + 1 &lt; len(diff_tree))&#10;            _add(r + 1, -val);&#10;    }&#10;&#10;    T _get(int id) {&#10;        T res = 0;&#10;        for (int i = id; i &gt; 0; i -= low_bit(i))&#10;            res += diff_tree[i] * (id + 1) - diff_mul_tree[i];&#10;        return res;&#10;    }&#10;&#10;&#10;public:&#10;    range_fenvik() = default;&#10;&#10;    explicit range_fenvik(int n) {&#10;        diff_tree.resize(n + 1, 0);&#10;        diff_mul_tree.resize(n + 1, 0);&#10;    }&#10;&#10;    explicit range_fenvik(const vector&lt;T&gt; &amp;a) {&#10;        diff_tree.resize(len(a) + 1, 0);&#10;        diff_mul_tree.resize(len(a) + 1, 0);&#10;        for (int i = 0; i &lt; len(a); ++i) {&#10;            add(i, a[i]);&#10;        }&#10;    }&#10;&#10;    void add(int id, T val) {&#10;        _add_range(id + 1, id + 1, val);&#10;    }&#10;&#10;    void add_range(int l, int r, T val) {&#10;        _add_range(l + 1, r + 1, val);&#10;    }&#10;&#10;&#10;    T get_pref(int id) {&#10;        return _get(id + 1);&#10;    }&#10;&#10;    T get(int x) {&#10;        return get(x, x);&#10;    }&#10;&#10;    T get(int l, int r) {&#10;        if (l == 0)&#10;            return _get(r + 1);&#10;        return _get(r + 1) - _get(l);&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".Fenvik2D" value="class Fenvik2D {&#10;    vector&lt;vector&lt;int&gt;&gt; fenvik;&#10;&#10;    int get(int x, int y) {&#10;        if (x &lt;= 0 || y &lt;= 0) return 0;&#10;        int res = 0;&#10;        for (int i = x; i &gt; 0; i -= low_bit(i)) {&#10;            for (int j = y; j &gt; 0; j -= low_bit(j)) {&#10;                res += fenvik[i][j];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;public:&#10;&#10;    Fenvik2D(int n, int m) {&#10;        fenvik.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;    }&#10;&#10;    void add(int x, int y, int v) {&#10;        for (int i = x; i &lt; len(fenvik); i += low_bit(i)) {&#10;            for (int j = y; j &lt; len(fenvik[0]); j += low_bit(j)) {&#10;                fenvik[i][j] += v;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    int get(int x1, int y1, int x2, int y2) {&#10;        return get(x2, y2) - get(x1 - 1, y2) - get(x2, y1 - 1) + get(x1 - 1, y1 - 1);&#10;    }&#10;&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".range_fenvik2d" value="template&lt;typename T&gt;&#10;struct range_fenvik2D {&#10;    int n, m;&#10;    vector&lt;vector&lt;T&gt;&gt; diff;&#10;    vector&lt;vector&lt;T&gt;&gt; diff_mul_x;&#10;    vector&lt;vector&lt;T&gt;&gt; diff_mul_y;&#10;    vector&lt;vector&lt;T&gt;&gt; diff_mul_xy;&#10;&#10;    void _add(int x, int y, T v) {&#10;        if (x &lt;= 0 || y &lt;= 0) return;&#10;        if (x &gt; n || y &gt; m) return;&#10;        for (int i = x; i &lt;= n; i += low_bit(i)) {&#10;            for (int j = y; j &lt;= m; j += low_bit(j)) {&#10;                diff[i][j] += v;&#10;                diff_mul_x[i][j] += v * x;&#10;                diff_mul_y[i][j] += v * y;&#10;                diff_mul_xy[i][j] += v * x * y;&#10;            }&#10;        }&#10;    }&#10;&#10;    T _get_pref(int x, int y) {&#10;        if (x &lt;= 0 || y &lt;= 0) return 0;&#10;        if (x &gt; n || y &gt; m) return 0;&#10;        T res = 0;&#10;        for (int i = x; i &gt; 0; i -= low_bit(i)) {&#10;            for (int j = y; j &gt; 0; j -= low_bit(j)) {&#10;                res += diff[i][j] * (x + 1) * (y + 1) - diff_mul_x[i][j] * (y + 1) - diff_mul_y[i][j] * (x + 1) +&#10;                       diff_mul_xy[i][j];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;    void _add_range(int x1, int y1, int x2, int y2, T v) {&#10;        _add(x1, y1, v);&#10;        _add(x1, y2 + 1, -v);&#10;        _add(x2 + 1, y1, -v);&#10;        _add(x2 + 1, y2 + 1, v);&#10;    }&#10;&#10;    T _get(int x1, int y1, int x2, int y2) {&#10;        return _get_pref(x2, y2) - _get_pref(x1 - 1, y2) - _get_pref(x2, y1 - 1) + _get_pref(x1 - 1, y1 - 1);&#10;    }&#10;&#10;public:&#10;    range_fenvik2D(int n, int m, T val = 0) : n(n), m(m) {&#10;        vector&lt;vector&lt;T&gt;&gt; a(n + 1, vector&lt;T&gt;(m + 1, val));&#10;        for (int i = 1; i &lt;= n; i++) {&#10;            a[i][0] = 0;&#10;        }&#10;        for (int i = 1; i &lt;= m; i++) {&#10;            a[0][i] = 0;&#10;        }&#10;        n = len(a) - 1;&#10;        m = len(a[0]) - 1;&#10;        diff.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        diff_mul_x.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        diff_mul_y.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        diff_mul_xy.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        for (int i = 1; i &lt;= n; i++) {&#10;            for (int j = 1; j &lt;= m; j++) {&#10;                _add(i, j, a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]);&#10;            }&#10;        }&#10;    }&#10;&#10;    explicit range_fenvik2D(const vector&lt;vector&lt;T&gt;&gt; &amp;b) {&#10;        n = len(b);&#10;        m = len(b[0]);&#10;        vector&lt;vector&lt;T&gt;&gt; a(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        for (int i = 1; i &lt;= n; i++) {&#10;            a[i][0] = 0;&#10;        }&#10;        for (int i = 1; i &lt;= m; i++) {&#10;            a[0][i] = 0;&#10;        }&#10;        for (int i = 1; i &lt;= n; i++) {&#10;            for (int j = 1; j &lt;= m; ++j) {&#10;                a[i][j] = b[i - 1][j - 1];&#10;            }&#10;        }&#10;        diff.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        diff_mul_x.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        diff_mul_y.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        diff_mul_xy.resize(n + 1, vector&lt;T&gt;(m + 1, 0));&#10;        for (int i = 1; i &lt;= n; i++) {&#10;            for (int j = 1; j &lt;= m; j++) {&#10;                _add(i, j, a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int x1, int y1, int x2, int y2) {&#10;        return _get(x1 + 1, y1 + 1, x2 + 1, y2 + 1);&#10;    }&#10;&#10;    void add(int x1, int y1, int x2, int y2, T v) {&#10;        _add_range(x1 + 1, y1 + 1, x2 + 1, y2 + 1, v);&#10;    }&#10;&#10;    void add(int x, int y, T v) {&#10;        _add_range(x + 1, y + 1, x + 1, y + 1, v);&#10;    }&#10;&#10;&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".min_coost_max_flow" value="struct edge {&#10;//    v -&gt; u&#10;    int v, u;&#10;    int capacity, flow;&#10;    int cost;&#10;};&#10;&#10;&#10;//edge edges[MAXN];&#10;vector&lt;edge&gt; edges;&#10;int N, M;&#10;&#10;&#10;graph&lt;int&gt; g;&#10;vector&lt;int&gt; phi;&#10;vector&lt;int&gt; dist, parent;&#10;&#10;&#10;void dijkstra(int s) {&#10;    dist.assign(phi.size(), inf);&#10;    parent.assign(phi.size(), -1);&#10;    dist[s] = 0;&#10;    min_heap&lt;pair&lt;int, int&gt;&gt; q;&#10;    q.emplace(0, s);&#10;    while (!q.empty()) {&#10;        auto cur = q.top();&#10;        q.pop();&#10;        int v = cur.second;&#10;        int d = cur.first;&#10;        if (d &gt; dist[v]) continue;&#10;        for (auto id: g[v]) {&#10;            int u = edges[id].u;&#10;            int w = edges[id].cost + phi[v] - phi[u];&#10;            if (edges[id].flow &lt; edges[id].capacity &amp;&amp; dist[v] + w &lt; dist[u]) {&#10;                dist[u] = dist[v] + w;&#10;                parent[u] = id;&#10;                q.emplace(dist[u], u);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;void min_cost(int need_flow = inf) {&#10;    int cost = 0;&#10;    int end = 2 * N + 1;&#10;    int start = 0;&#10;    while (true) {&#10;        dijkstra(start);&#10;        if (need_flow == 0) break;&#10;        if (dist[end] == inf) break;&#10;&#10;        for (int i = 0; i &lt; phi.size(); ++i) {&#10;            phi[i] += dist[i];&#10;        }&#10;        int cur_flow = need_flow;&#10;        for (int v = end; v != start; v = edges[parent[v]].v) {&#10;            int id = parent[v];&#10;            cur_flow = min(cur_flow, edges[id].capacity - edges[id].flow);&#10;        }&#10;        for (int v = end; v != start; v = edges[parent[v]].v) {&#10;            int id = parent[v];&#10;            edges[id].flow += cur_flow;&#10;            edges[id ^ 1].flow -= cur_flow;&#10;            cost += cur_flow * edges[id].cost;&#10;        }&#10;        need_flow -= cur_flow;&#10;    }&#10;    cout &lt;&lt; cost &lt;&lt; endl;&#10;}&#10;&#10;&#10;void add_edge(int v, int u, int capacity, int cost) {&#10;    edges.push_back({v, u, capacity, 0, cost});&#10;    edges.push_back({u, v, 0, 0, -cost});&#10;    g[v].push_back(edges.size() - 2);&#10;    g[u].push_back(edges.size() - 1);&#10;}&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".dinic" value="int SZ;&#10;&#10;struct edge {&#10;    int u, v, cap, flow;&#10;};&#10;&#10;vector&lt;edge&gt; edges;&#10;graph&lt;int&gt; g;&#10;&#10;&#10;vector&lt;int&gt; level, ptr;&#10;&#10;void add_edge(int u, int v, int cap) {&#10;    g[u].push_back(len(edges));&#10;    edges.push_back({u, v, cap, 0});&#10;    g[v].push_back(len(edges));&#10;    edges.push_back({v, u, 0, 0});&#10;}&#10;&#10;void clear() {&#10;    edges.clear();&#10;    g.clear();&#10;    level.clear();&#10;    ptr.clear();&#10;    SZ = 0;&#10;}&#10;&#10;void init(int n) {&#10;    SZ = n;&#10;    g.resize(SZ);&#10;    level.resize(SZ);&#10;    ptr.resize(SZ);&#10;}&#10;&#10;bool bfs(int s) {&#10;    level.assign(SZ, -1);&#10;    level[s] = 0;&#10;    queue&lt;int&gt; q;&#10;    q.push(s);&#10;    while (!q.empty()) {&#10;        int u = q.front();&#10;        q.pop();&#10;        for (int id: g[u]) {&#10;            int v = edges[id].v;&#10;            if (edges[id].cap - edges[id].flow &lt; 1 || level[v] != -1) continue;&#10;            level[v] = level[u] + 1;&#10;            q.push(v);&#10;        }&#10;    }&#10;    return level[SZ - 1] != -1;&#10;}&#10;&#10;void push(int id, int flow) {&#10;    edges[id].flow += flow;&#10;    edges[id ^ 1].flow -= flow;&#10;}&#10;&#10;int dfs(int u, int end, int flow) {&#10;    if (u == end || flow == 0) return flow;&#10;    for (; ptr[u] &lt; len(g[u]); ++ptr[u]) {&#10;        int id = g[u][ptr[u]];&#10;        int v = edges[id].v;&#10;        if (level[v] != level[u] + 1 || edges[id].cap - edges[id].flow &lt; 1) continue;&#10;        int pushed = dfs(v, end, min(flow, edges[id].cap - edges[id].flow));&#10;        if (pushed) {&#10;            push(id, pushed);&#10;            return pushed;&#10;        }&#10;    }&#10;    return 0;&#10;}&#10;&#10;&#10;int dinic(int start, int end) {&#10;    int flow = 0;&#10;    while (true) {&#10;        if (!bfs(start)) break;&#10;        ptr.assign(SZ, 0);&#10;        while (int pushed = dfs(start, end, inf)) {&#10;            flow += pushed;&#10;        }&#10;    }&#10;    return flow;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".preffsum" value="struct PrefixSum {&#10;    int n;&#10;    vector&lt;int&gt; pref;&#10;&#10;    explicit PrefixSum(const vector&lt;int&gt; &amp;a) {&#10;        n = len(a);&#10;        pref = vect(n, 0LL);&#10;        pref[0] = a[0];&#10;        for (int i = 1; i &lt; n; i++) {&#10;            pref[i] = pref[i - 1] + a[i];&#10;        }&#10;    }&#10;&#10;    int get(int l, int r) {&#10;        if (l == 0) {&#10;            return pref[r];&#10;        } else {&#10;            return pref[r] - pref[l - 1];&#10;        }&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".modimport" value="/*&#10;&#10;&#10;         ~??:   :!?J???????????????! .????????~  !?!~?^~!:7:?!~7?. .????????^                                   .:^^^^^:...............::................::::::............:.. ....&#10;         .YYY:    .^7JYYYYYYYYYY?!:  ~YYYYYYYYJ??: :J7^Y?~Y!~J! .7?JYYYYYYYYJ                                .::^^^~~^.................::^~~^:::...........:::^^^^:::::.......... ..:.&#10;         .YYYJ.   ..  .::^^^^:..     .7JJYYJYYYYY7~?^ .?. !! .?!!JYYYYYYYYY?~                             .:^:::^^~~..................^~7!^:.................:::::^^::.............  ..:.&#10;.:.      ~YYYY~  ~77:     .~~~:.       :7JYY?~^^JYYYJ?JJ!!?J??YYYY!^~!!~^:.                            .:::::^^~~!~::::^:::..........:!^................::^::::::::::::........   ....  ..:.&#10;YYJ!.  .!YYJJY?   ..   ...?YYYYY!.   .!JYYJY?. .JYYJYYYYYYYYYYJJYY:                                 .:::::^^^~^^^^^^^^:...........:~~~:...::::..........:^!??7~^:.............  .   ....   ..:..&#10;YYYYY??JYYYYYY?.......JYJYYYYYYYY?...7YYYYJJYYJYYYYJJJJYYYYYJJYYY!................................^^^:::^^^^^^^^^^::..............::...::........::......:::^~7?7~..............  ........    .^^:...................................................................................................&#10;JJJJYYYYJJYJYY!......:YYYYJJJJJYYY^.:YYYYJYYYYYYY~7YYYYYJ?JYYYYJ~...............................^~~^^^^:::^^^^^^......^^^:...............::::.....::::::::^^::.:^7?~.............   ....::.  .  .^~:....................................................................................................&#10;YYYYYYYYYYYYY7........!YYYYYYYJJYY~.^YYJJJYYYYYY!..:~7~:..:~7!^...   ........................:!7!~^^::::^^^^^^.....^!!^....................:~^::....:::^^^^^:::...:!?^.......  ..... .::.::.. ..  .:^:....................................................................................................&#10;^:~JY!:~^.~?~..........:!?JYYYYYYY^.:YYYYYYYY?!:.................     .....................:!7!!^^::::^^^^~~.. .:!J?^.............:........::^~^:..::::::::^^:......:!!:.....    ..^^. :~.:^:. ...  .^^:...................................................................................................&#10;   .^       ..............:^~!7?J?:..?J?7!~^:................     ...     ...............^!!~!~^:::::^^^~!^.  .!YJ~......::.......:.....:::::::^^:...::....::^::......^7~.        ..^!: .!::^:......  .^^:..................................................................................................&#10;        :   .     .^!7????7~^:...........:^~7?????~.........    .    .:    ........... :77!!7~^^^:::^^~!7^.. .JP7....:.:^:.......::.....:::::::::~::.........:^:........~!.         .:7!:.7^:^^...::.   :~^:................................................................................................&#10;      .:.. .      !YYYYYYYYYYYJ?^.....:?JJYYYYYY7:.   ..     .  ..  ..  ..............~7777?~^^^^^^^^!77^...:?5~......:^:........::......:::::..:^!::..........:^:.......^7:       ....!J~:?~:^^...:^..  .^^:...............................................................................................&#10;   ::.     .::    :YYYYYJJYYJYY7..:^:..7YYJYYYJY?   .. ...   .      ..  ............:777777~~~^^^^^~7??~...:?J:......:^:.........^..............::^7::..........:^:.......:7^     ......^?77J!^~~:..:~...  ^~^:.............................................................................................&#10;    :       .    ..!YYJYJYJYYJ~..!JYJ!:.~JYYYJYJ?~...    :  ...   ..    ...........~?7?7!7~~~~~~^^~7??7...:JJ.::.....^!..........~...............~.~!.:...........:^....   .7~    .......^??7J7~!!...~~...  ^~^:............................................................................................&#10;     :.   .:.   ...?YYYYYYYJ!:.^JYYYYYJ~.:!JYY7.  .:.    .:    .....:..^77~~.....:!77J7!?~~!^~~^^!??J?:...JJ:^!......~~..........~:..............!:.?^.:...........:^.     ..!~   ........^??7?77?!..:7~...  :~^:...........................................................................................&#10;     :..   .     ..^!7???!^:..!YYYYJYYYY7..:^77.    ......     ...:!JJ7JYYYY:...:77?J!!?~~!~^!~^~????!...JY:~7!:..:..!~..........^~............. ~~ :Y............. .:. ......!~  .........^??77777~..!?^.....:~^:..........................................................................................&#10;                 ............~YYYYYJYYYYY~......   .  ..  .. .....~JYYY!!7?YJ?!^77JJ!!J!^!7~!!^~?????:..75^^777:.^..^!~.........::7............. ^J. 77.......    .. .:.::.....7: ..........!7777!!7^.~?7:......~^:.........................................................................................&#10;       ....   ...............!YJYJYYYJJYY7..........      .........!JJ7:.:?YYYJ77JY!!J?^~7!~!~~?????7:.^P!^7!7?..~..!!!....::...^.!^.............:5: .5:.....     .....:^^^....:7. .........:!77!!!!7::?7~..:.:..~::........................................................................................&#10;   ...............:^:...:^^...?YYYYJJYYY?:........................~JYYY??JJY!77?5Y!!?J~^~777!~7J????!~.5?^77777.^~.:7!!^...^....~:.7.........:....5~. ?Y..:.............^~!^....:! ..........^7!!~!!!~:7~!:.:::: .~^:.......................................................................................&#10;  .~~:^7~......:~!YYYJ!?YYY7~:.^7!:.:~7^...........................^77~!YYJJ7~?P5!!?Y7^^~7?7~!J?77777^75~!777?7.7~.^7!!!:::!....^~.^!:......:~....P?..:P~.:7^.....:..:...~!?~^...~^ ..........~~~~^~!!^!^~^..^~!. :~::......................................................................................&#10; :YYYYYYYJ:... !YYJ?!~7!~?JYY7........:.........::.........   .    .....:~:~~?P5!!75J^^~~7?7!?J777777^P?!77!!?7:?^.^7!!!~^~7..^.:^^:!7:.....^!:..:GJ:..JY:.!Y^...:^^::~...!??~^...7.........:.:!^~~.^77!^:!..^!7:  :^::.....................................................................................&#10;:?Y7!??!7YJ777!~JJ^~!~~~!!^?Y~.....::!YY?~....~?YY7::......  .  .  .......^~?P5!!!Y5!^^~!7?77Y?77777!?P777!!777^J^.~7!!!~~7?..7:.^:!^!~.....!7:..~GY:..~G!:.JY:...~!!7~~..:???7~..^7 ^.......:.!~^~~.:77^.!:.^7?~   ^^:.....................................................................................&#10;J77~^7!~~!~7YYYYY~!7^. .^7!^JYJ^..:YYY!~~.~..~.~~!YYY^...   .   ..   ....:~75Y!~~75J^^^~~7?7YY777777!5Y?7!!!77?!J~.~7!!!~~7?^:?~.::.?~~.....!?^..7GY~::.PJ!^:5J:..^7!7J7^..~J??7!..!::!..:...:.^7^^!^.:!!:^^.!J?!    ^^:....................................................................................&#10;!:7!~^^^!7~^JYJYY?^!!^:^!!^?YYJ^...77:::!77?7777:::!?....   . ...    ....~!57!~~!Y5~^^~~~??75?777!77!5J?!!!!7!??J~.~7!!!!!!?7~??:.~.~J~^...:77~..JGY!^~.?B!?^!P?:.:7!~??~..:?J7777::7.7!:.~...:.?~^^!:.:7~:^:77?7.  . :::...................................................................................&#10;:!7~:  .^~7^^JYYYY?7~~7~~77JYY!......:!?77~^^~77?7:..........    .......~~Y~~~^^7P?^^^~~~?7J5!~!!!7!75?77!!!7!7JJ~.~?!!!!!7YJ77?!.^:^7?~^:.:77!:.PGY7^J.:PY~?^YY7^:^!!!Y7^.:~5?7777:!::7!^!7^.~:^?~~!!..~7::!?~!7.  .  ^^:..................................................................................&#10;!~7!~:::~!!^JY7:::^YJJYJJY~:::...:^..!?7!:    .!7?7:.^:................^^J~:~^^^?5~^^~~~~?75Y~~!!!7~?J777!!7777??~.!Y~!!!!75Y7777^.^~!~~7^:~777~!BPJ?^P:.7Y7!7~G?!~~!!~~Y!::^?P!?!!7!!.!~!7??77!:77:^7^..7!~7!.^7:  :...^^:.................................................................................&#10;J^~!!!!!~~!~JYJ. ..~J?!7?^.::..:7YJ.:7?7!.    .!7??:.JY?:.............:^!!:~^^^~YJ^^^~~~~?7P?~~!!!7~J?777!!7777??~.!G!~!!!75Y!!7J7::7!!:!!!!!!!!PP5J?^B!.!!J!!!?G!~~~::.~Y~:~~55!?~!7J.~~~~~!7J?:!?!.^7^.:7!7::~7^. ~:.: ^^^................................................................................&#10;YYYJ^!77^?YYYYY:.^...^.::.~??~.:7YY~.~7?7!^:.^~7??~.^YY7:.............~^!.~~^^^~5!^^~~~~~7?G7~~~!!7~J?7777777!7J?!.!B7~~!!!YJ!!7J!~.!7!~^.?Y7!!?BJ577^BJ.~~~7~!!P5~~^....7J^~~!G??7^~J7:~^~~~~7J^^?7!.:!~.!7?.^7^!..?~ ^^ :~^:..............................................................................&#10;!YYYYJ!7YYYY!:^::..::^. .^.:^...^JYY~.^~!J7??7?7~^.~YYY^.............^^~.:~^^^^75~^^~~~~~!?G!~~~!!!~J77777!7777YJ~.~G7~~!!!5?!!JJ!!^:7!!^^77JYJPP!57!~Y5:^~:~~~!7BJ~^:...:?7~~~YG!Y~^~J.~^^~~~~?~:?77~..7!!?7.^Y:!:^J^  ?! :~^:.............................................................................&#10; :~~^....^^^..^. :~7?!~ ::.......:^^:.. ^.~^:!.^  .:^::....~?~!!....:^^:.~~^^^^YY^^^^~~~!!?P~~~~!!!!J77?77777775J~.^P!~~!!75?!!5?!!!:^7!~7?!!!YBPJY7!~!J~^~.:^^^~?GJ~^:::.:7~~~!G7??^^J:^~^~~~~7~:~?77:..7YJ?:~Y::!?J:. .Y?..~^:............................................................................&#10;   ...........:::.:~~^. :^..............77?!~?!7..........~JJ7JJ^...~^:.:!^^^^~P?^^^^~~~!!J5~~~~~!!757?777777775?!.^P!!~~!7P7!7P7!!!~:~7757!!^PP?YP5?!~!!^~..:^^^^?5?^::::.^~~~~YY~Y~^7!:~^~~~~!^::?77!::.?P5:~J..?J?:.. ~7Y~.^^^...........................................................................&#10;   .............^.  .:.::...............:?J77JJ^..........^!?J77^..^^:.:^!^^^^!P7^^^^~~~!!Y5~~~~~~!?57?77777777P?!.^5~~~~!J5!!YP!!!!!~:~J5!~.?#7!!7?JJ!~7!^.  .^^^:!7?^::...^~~~!Y!7?^^J:~~~~~~~^:.7777^:~:YG:!?..?J7... .~^Y?.:~^:.........................................................................&#10;   ..............::::........................:..............::.....~:..:~~^^^^?P!^^^^^~~!!5Y^~~~~~!?P7?77?77777P?~.^Y^^!~!YJ~!GJ~~~!~!~.77^.^GJ!!!!7!!~:!7!....^~~!!?YY7!!~~^7!!!Y?!?!^?~~~~~~~~^..~?77!.!7~G7?!..7?!.... ^^^?5~.^~:........................................................................&#10;   ...............................................................^^:.::~~^^^~?5!^^^^^~~!!PY^~~~~~!JP??77J7777?P7~.^?:.^!!57~?B7~~~~~!!?::.:55!!!!!7!!^.:!J?!~^^^:7!^~!7~::^^^?!!???J7~7Y7~~~~~^^..:J777^.!JYGP^..7?!......!^:~YJ::~^:......................................................................&#10;   ...............................................................~^:.::!^^^^~7P!^^^^^^^!!GJ^~~~~~~JG?7!?J7777?5!^.~7:..^J5~~5P~~~~~~!YG:..?P7!!!!!!7!^..^^^..   .:7!:^^~~::::~7^~!~!~!!GY~~^~^^^...J7!77^:~5PP^..7!7^.:.. :^^::757::~:.....................................................................&#10;   ..............................................................^^^  :^!^^^^~7P!^^^^^^^!7GJ^~~^~~~?G??7Y?777!JY~^.~~....!?^?G?~^^^~~JB!.:^~!!7!!!!~7!^  .::.     ..!!^^::^^:::~7^7^~!^7GP!~^~::^...J?7~!7~^!PG!::7:7!.^:...:^^^:^JY~:^~:...................................................................&#10;   ..............................................................~^: ..:!^^^^~?P7^^^^^^~!7GJ^^~^^~~?GJ?75777!!YY~:.~:... ^~7P5~^^^^~?GJ.:~??::!!~~!!7?^   .^:       .~~^^:.:^::.~7!!:!!~GG~~^^..:.. ?J!~:^7!~?GY!~?.~?:^^....:^^^::~JJ^:^^:.................................................................&#10;   ..........................:::::............................  .~^:::.^~^^^^~JP7^^^^^^!!7G5~^~^^~~7BY7JP777!!5?~^^!!!~:.!!7Y7^^^^^7G5::77?J?!^~~~~!~Y7 .  .^.       .:^:~^.:~~::~?7.:!^YB~~^^..... 7Y!~^.:?YJYP??7.:?~~^!....:^^^:::~JJ~:^^................................................................&#10;   .........................^: : .:.:........................   :~^....^~^^^^7YP?~^^^^^!!7GP~~~^^^~!GP?Y5777!JP?7^^~:...~!:.7^^^^:7P5^:J??!!YY!^~~~~~!5.    .:   ...::::^^^~^^^~^:^J7.:~~G^~^^..... ~5!^^::.^YPGJJ~.:^?!.?^....:^^^::::^?J!^^^:.............................................................&#10;   ........................::. ..  :^........................   ~~^..:.^~^^^^JYGJ~^^^^^!!7PP!~~~^^~~PG?557??7Y?:::~:.  :~. :~^:::!5Y~~5?7!~!!YY^:^~^^^J^     .::^::^~7JY5PPGGGP5YJ7~7^.:~J^~^^..... ^5?~^^^!:.7GPJ::~:?~.~?. ...:^::^:::.:7?7~~^:...........................................................&#10;   ................     ...:::. ...~............................!!~^::.~!^^^^YYGJ^~~^^^!?7PG7~~~^^~~JBJPP?7~!?~::^!.  .:  .~^:::JY!!?57!!!~~~!YY:.:~~^^~.     :^!YGB####BBBB##B#&amp;#B#P?!^~7^~^^....  ^5?7~^:^J!:?GJ.^7:?~..?7.....^^::^:::..:!?7!!~:.........................................................&#10;   ................     .....:::::::...........................:7!~:...^!^~^~5YGY^~~~^^~??PGJ~~~^^!~!G5P57!~7!^:^7~       ^^::^^^7JJ77~~~!!~~~~JJ...^~^^:   .!PBGY?5P55PGB#&amp;B: :#&amp;P!JGGGPY~~^^...   :5J?7^^::YJ!55.77:?~..~J7.....:^..::::....~7?77~:.......................................................&#10;   ................................. .    .....................~7~!..:.~7~~~!PJBY^^~~^^~?J5G5~~~~^~!~5GP57~~!~::!7.      ^::::. ^7!7!~~~~^~~~~~~??. .:^^^. .!PJ~::YBGGBB#&amp;&amp;&amp;B^.7&amp;&amp;&amp;5:^5GGP5?~:.     .5Y???^::^JPJ5^J!^?^:..?J!.....::..:^:::....:!???7~:....................................................&#10;   .................................   .  .....................7!^!^.:.~?!!~7GJB5^^~~~^~?55PP!~~~^:7~7BP57~!~^:~7:   ...~^~~^..^^. .^!~^^^^^^~~^^!!.. .:^^..:  .:^#&amp;&amp;&amp;#BBBG#PPB&amp;&amp;&amp;&amp;&amp;!:^PPY?J7~:..   .Y5????~^~7PG5YY~J?:^..^JJ!......::.:^:::......~7???!^..................................................&#10;   ........................ ......... .  ......................?~:7^.::^?!7~J5Y#P^^!~~^~?5GPGJ^~~~^^7~5GP7~^^:^~~.::^~^!!^^^^^^.     .:^:..:^^^^^^^^..  .:^.   .^^B&amp;&amp;&amp;BG5PBB#PP#BB#&amp;~.:55~!^:..      ?5J?777!~7YGGBYJ57.^:..!JJ!......::.:^:::.......^!???7~:...............................................&#10;   ......................       ...............................J^.!^.::^?7?!??PGG!^7~~~^?YGPG5~~~~^:!77G57~^^^^~!JPB#BG##B#BBB5^.       .:. ..:^^^^^^:.   .::   . ~&amp;###Y7YBBGJJBBG#B.  ^^:!:...  ..  !5J?^!!~77?YGGYY5J.~^...7JJ!.......:::^^:::........^7???!^:............................................&#10;   ....................  ..  . ...............................:J:.^~..:^??J77!GYPJ^Y!~!^?YBGPG!~!~~^^?7JP~:^^~JB&amp;#B#BBBBGB#Y:!#&amp;Y^        ..    .::^^^:..   ..     J#BG57!~!~!75PBB^   .::!. ..  ... ^5YJ^:77^!JJYG5P?J:!!....?JJ7...:^..:::^^:::.........:~7??7~:..........................................&#10;   ......................       ...................  .   .....:J:.:!..:^??YJ!!B?YP^Y?!!~!YGGPGJ^!~^^^^??J^~!Y#&amp;#J~PPPGG##&amp;#! :#&amp;B!.                 ..:::.          ?B57:.....^?P5^    .:^~  :.  ....:5YY!::?Y~~J5PGY~J:~!....:JJJ?:..:!^..:^^^^^^...........:!7??7~:.......................................&#10;   ......................   ............. ........   . ..   ..:J..:~^.:^?JYJ~JB?J5!?Y77!!YPGGGP~!7~^^^^?77~?##G~:^####&amp;&amp;###BPB#&amp;&amp;P.                     ...          ~57:....:7J!...   ..!^ .^.  ::.::5YJ?^..75?~JGG!!J:^~.:...^YJJJ^...!?^..:^^^^^:............^!7J?7^:....................................&#10;   ....................................    .   ....  . ..   ..:J..:.^::^!JYJ^PP?JYJ~P7?7!YPPPGG7~?!^^^^^7!!GBB7:::5&amp;&amp;&amp;##GP5G#BB#G#^                                   .~^^^^^^^::...   .:!. .~. .^:.!^YY??7:..!YY~JP^J7:^7.:....~YJJJ~...~J7:.:^^^^^:..............^!7J?!^..................................&#10;   ..................................   ..  .  ....       ....:J:.:. ^^^^YYJ?GJ?JJY~5Y7?!?GP55BY~7?~~^^^:!7YGB7:::^P&amp;#GGB?JG#BY5G#!                                 ... ............  ..~^. :~...^:.J^YYJ??7^:.^J5~?!5^:~7:.:....!YJJY7...:JJ~..:^^^^:................:!??7~:...............................&#10;   .................................   ..   .  ........ .......?:.:. ^~^:JYYP5?JJJY7!G???7PGPYGG~!J7~~^^:^?~!?J^^^. ~BBPPY77!^:^?P~                               ..................  ..!.. ^~...~:.5~?YJ?77?!:.:JY!5?.:!!::::..::!PJ?YJ^. .7J!^:.:^^^:..................:!??7~:............................&#10;   ....................................  .     ................?:..::^^:^?5GG5JJYYYJ~YG?J?YGPY5G?~YJ7~^^^:^7~^:...    ~PP57.....!5^                              ..................  ..^....!~...~:.5~^YJJ?!7J?~::JJG~.~?!::^:::::.?G??J57. .^?!~^:.:^^:....................^!??7~:.........................&#10;   ....................................    ........:^::~.......!^..::^:..~5GG5JYYYJJ?^PPJJJGG55PY~?P?!^^^^.^7~!:        ^7?~::^~~^...                            .................   ..^ . :7^...!^.Y7.JJJJ!~7JY?77PY::7!7:~7:::::^.PGJ7?YY^. .!!^^^:.::::.....................:!??7~:......................&#10;   .............................................~::~.  ^^.^^.  ^~..^^^.:::5BGYYYYJ?J?~7BPYJYG5555~!P57~^^^^.~!^7^.    ....^^::.........                           ..............     .:  . ~7^:..!^.JJ.7JJJ?~^^75YJ5P^J!J?^~5~::::^:^GG5?7J57. .:~^::::.:::.......................:~7?!^:...................&#10;   ............................................^^   ...   .~...:7..:^:.::?BBPYYYY?J?77!JGPYJPP555!~YG?!~^^^^.~^^7^..  ...................     ..                     .......        .:   ..77^:.:!~.?Y.~JJJJ7^~!!5Y5P5!!5?:~PY::::^^.7GGPJ77YY^. .^~^::^:.::.........................:~77!^.................&#10;   .............................................~:   ^:  .^^....?..^^..:~PGBPYYYJ??77?G!YPPYYP55P7~?B57~^^^~~.^^~~:......................                                           .   ..:Y7^:.:7~:?5::JJJJJ~:!?7YPP7.~Y7:^5P7::^^^:.5PPG57!?Y?:...:^::^^:.::..........................:~77~:..............&#10;   ............................................^~  ..  .. .!... !::^:.:^JGBPGYYY???77PG57Y5P55P55?^!GP?7~^^^!~.^^^~.....................                                           .    ..~57^:.:7!:?Y!.7JJJJJ^:~J?5P^.7Y!^~Y55^:^:^^.^GPPGPJ!!?Y~....:^^^^^::::...........................:~77~:...........&#10;   .............................................:::~:  ~^::.....:~:^..:!YGPY55YJ?77!JG5P57?Y5P555J^~PP?7!~^^~7!.~^^~. .................                                           .    .:.J57^^.:77^?JJ.~J??JJJ~:^J5P!:YJ~!7JYPY:::^^^.7GPPPP5?!!??:....^^^^^::.:::...........................:~7!^.........&#10;   .................................................::::.........~^: .^!PBJ5YYYJ77!7PP555Y??JY5GPJ~~5PJ!7~^^^!J!.!^^!: ..............                                            .    :7.:PY?^^::7?!??5^:J????JJ!::JGY7P7!J!JY5P?:::^^:.YP55555Y7!!?!.....^^^^::..:::............................:~7!:......&#10;   ............................................................. ^!..~~YGP75YYJ?7!!YP555YJJJJJJ5GY~~Y5?!J!~^^~75~.7~:^:  .                                                           !J!.7GJ?~^::?J?J7Y7.7????J7?!^:YGGJ?YJ!YJJ5P!.::^^.:PP5555Y5J7!!!:.....^^^:::..:::.............................^77~:...&#10;   ..............................................................^~ ^^?G577PYJJ7!!?P555YJJJJJJJY55!~Y5?!Y7~^^^!?P^:YJ??^                          ..      ..                       :???^:5PJJ~^^:?JYJ7?J.~????J!~77~!PP?YJ!5YJJJ5P~.::^:.!GP5J55YY5J7!!^.....:^^^::...::::............................:~77^.&#10;   ..................................:?J?^~^....................:^:^^!PJ7!?PYJ?7!!Y555YJJJJJJ??J5Y!~J5?!?Y~~^^~7JG^:YJJY~                         ..                             .7J7??:7GYJJ!^^^?J5J77Y~:?777J?^!~!JJ5JJ7J5YYJ?YPP^..:::.?GPPJJ5YJJYJ7!~:... ..^^^:....::::.............................:!7&#10;   ................................:7?JJJJYJ^...................^^^^~5?^?~JPY??7!?555YJJJYJ????Y5Y!^?5?7!57~~^^7?P5~^5J?Y7.                                                    :!??7777:YPJJ?7^~~JJ5J7!J?:7777?J~:7!^?YY!5J5JYYJ?YP5:..:::.YPPPY?JYJ?JYJ7!~:... ..^^:......:^:..............................&#10;   ................................:?J?JJJJ?:..................:^~^^J7:!7~YP5?7775555J?JY??????YYJ!^?577~JY~~~^~7JY?^^5?7JJ^                                                 :^!7777!7!^5Y7J??~^~JYYJ7!7J:~?777J7^:7J!YJJ5Y5JJYY??YGY....:.:5PP55J7JYJ?JJJ7!~....  .:^:.....::^:............................&#10;   ..................................~JY7!?!...................^!:^7!::?~~YP5?77?555J?JY?????7JYJ?7^7P77~757~~^^77Y!?~^YJ??Y?^.                                           .:^::~!77!!?^75?7J??!~~?PYJ7!!J~:?!!!7?!^:!JY?5Y5YJJ?YY??YGJ....:.:5PP5YY77JJ???JJ?7~....  .:^:.....::^:..........................&#10;   ....................................:......................:~:^!~::^7~~JP5??7Y55Y??YJ??7777JY?77^!57!~~JJ!~~^!7?77?!^YJ7YJ??7~:.                                    .:^::::.~!!!!!7:J57!?J77~~7G5J7!!??:?!!!!7?7!^~YY5JPJJJ??YY??5G7......:5P5YJ5?!7?J?7??7?7~:...  .:^^.....:::.........................&#10;   ...........................................................^:^!~:::~!^~JP5JJJ5YYJ?JJ?77777?JJ77?~~Y7!!^7J!7~^~7!?777!~YJJJ777777!!^:..                           .:^:::::...^!~~~~~~YJ7!7J7?~~7YGJ!!!7J^?!!!!!!!77!?5?YJJJJJ7?YY??5G!......:5P5YJYY7!7??777!!7?~....  .:^::....:::.......................&#10;   .........................................................:::~!^:::.J~^~?P55YYYYY?JY?777777?J?!!?~~J?!!^!?777~~!!77!!!!7YYJ777!!!!777!!!~^::..                ..:^:::::.......Y5YJ?~!?J!~!???!!!!G5!!!!Y~J!~!!!7?JY5P5555GGGP5JJ5Y??5P~......:55YY?J5J!!7??777~~7?~....   .:^:.....::.....................&#10;   ........................................................:::~!^:::.7J^^^7PPP55YY?JJJ7777!!7?J!!!7!^??~~~~7?~?7~!7!?!!~~!7YJ?!!!!!!!!!!!!!!77!!!:::....    ..::^::::::.........7GGGG~77J!^~!7??7~~7P7!!!Y7J!!7?Y5GGBB#BB##BBBG5JJYP5J?5P^......:55JY?75P?!!7?77?!^^!7^.....  .:::.....:....................&#10;   .......................................................:.^!!^:::.~J?^^^7PPPPYYJ?JJ7!!!!!!7JJ!!!77^?J~~~^!?!!J7!7!7!~~~!!!JJ?7~~!!!!~~~!!!!!~!?::::::^^::^^:::::::............:PGG5:??J7!!!!7??~~~JJ~!~JJY7?JJYPGBB###G##B##BG5J?5GG5J5P^.:....:Y5??77YGY7!!77777~::~7^.....  .:::.....:..................&#10;   .....................................................:..~!!^^^^:~7?7^^^!PPPPYJ?JJ?!!!!!!!?5!!~!!7^7J~~~^~!7~?J??7!7~~~~~!!!7J7!~~~~~~~!~~!7J5J:::::::::::::::.......... ......~GG5:??JJ!?~~77?7~~~Y!~!JJPPG5JJP####BGP5GBBBBB#BPY5BBBP55^.:....:YY7?7!JPGJ!!!777?7~::!7~.....  ..::......................&#10;   ...................................................::.:!~~~:..:^~~J!^^^~5P5PYJ?J?7!!!!!~7YY~!~!!7~!J~^~^^~!~~JYJ?77~^~~~!!!~~7??!~~~^!!!7?5GBJ:::::::::::::.........      .....!GY:?~?Y7Y!.^!??7~~!J!!JJGBBG5B#BBBBGPPYJPGBGP5PGBG5GBBYJ5^.:.....JY77!!?5GP?!!!7777!^:^~!~:....   .::....:...............&#10;   ..................................................:..~7^^~~  .^:^~J!^^^~JGPPJJ???!!!~~~!7J7~~~!!!~^?!^^^^~~!~!YYJ?!7^^~~!~~~~^^~777~~~775BBBB!::::::::............         .....~7:77JY?Y^...!7?7~~!77YYBBBB##PGBBP5PP?7JYPBBGYJJ55YGPJ7J5^.:.....7Y!!!!?5PG57!!!7777~^:^^~~:....   .:::...:.............&#10;   ...................................................:!!^.:~: .:^:~~??^^^^7PGPJ???7~~~~~~!77!~~~!!!~^7?^^^^^~~~~!J5J!7!^~^~~~^^^^^^~~!!7??YGBB?::::..............              ...:^:77?5Y7.....~7J?!~!JPJYPGBPJJGBPJJ5P?!7JYYPBGJJJ??YP5J7?Y^.^.....~J!!~~7Y5GPY!!!!777!~^:^^~^:....   .::::.::...........&#10;   ...............................................:..^7~:::^~. .^.~~~?J~^^^~JGPJ???!~~~~~~7!7~!~~!~!^:~7!^^^^^^~^~~755?7~^^^^~^^^^^:...:JY??YY~.................                  .:^:!!!PY:......~7?J?!!J7^~~~^!Y55JJ??Y??!7JY7JYYYYY?7YGPJ77Y~:^:....^7!~~~7JYPP5J!!!!777!^^^^^:::.....  ..::..:..........&#10;   ................................................:!7^::::~~  ^.^~~!J77^^^:7PBJ??7~~~~~~!7^!~~^~~~!^^^!!~^^^::^~^~~~?Y5J~^^~^^^:......:JJ!~~..................                   :^^:^JYP!........~7~!??777~^^~YGGP7J?7?YJ?!7Y?!7YGGGGJ7YGPJ77J!:~:....:!!~~~7JYPPP5?!!!!!!!~^^^^...:.....  ..::.::........&#10;   ............................................:..^!!^::^::~^ :::!~~??!Y!^^.~JBY77!~~~~~~7^^~~~^~~~~^^^^!~^^^^::^^^~~^^~Y57:.::. .......??~^~................                    .^^^^:J5~?:.......:~J^.~??77!^^~7??7J?!!JJY?!JJ77~JBBG777JPPY7!J7^~~.....~!~~~!JYYP5PY!!!!!!~^^^^:..........   .:::^:......&#10;^. .............................................:~~~~::^:.^~::^.~~~777~?Y^^..75G77!^^^~~!!.!^~^~~~!^^^^:^7~^^^::::^^~~~^:^???::.........!7~^~:....                              :^^^^7~!7.!!::::::^:!GP!..^7???7~^~7?7~^^^~~~~!7!7!~7P?777!JPP?!!J?~!7. ...~!~~~!JJ7555Y7!!!!~~^^^^:..........    .:^^:.....&#10;!^.:......................................... .^^^~~:.::..~~:^.^!~!7!!!~G7^^.:?GJ7!^^^~~7^^!^~^~~~^^^^:::~7!^.....:^^!~~~^.:!:^.........:?!^~:...                              .^^:^75J~?!:?^::::^^!~!YY~:...~7?J?YY!~~~~~~~~~~^^^^^^^^~7YYJ55Y77!?Y!7?: ...^!~~~!??^JJJJ!!!!!!~^:^^:...........   .:~~^....&#10;^:.::........................................:~^^~^..^:...~^^.:7!!?7!!7:5P~^:.~?P7!^^^~~!:~~~~~~~:.......:~77~^:.:::^^7?!~~:..:::........~?~^~^                        .     .:^:^~?5Y^:7?!~?^::^^!BP7?!^~~:....^!7???7!!!~~~~~~~~^^^^^::~?PGG5?!7!?Y77J^....^!~~^!?7:7?7?~~!!!~~~^:^^:...........  .::~!^..&#10;^..::.......................................~~:^~^..^:...:~~:.~7^!?!!!7~~G?~:..~?Y!~^~~7~:~~~^:::.....:::::^~!7!^:..:::!5J7!~^^~!~::::::::77^^^.                      .      :^::~J5?::^^~777J^^^!GP~7?~~!!7YY~:...::~!7???77!!!~~~~~~!!!!!7?7JY!~7!?5?7J!... ^!~^~!?!.!7!7~^~!!~~!~::^^:........... .:.:!7^&#10;...:....................................:::!^:^~~..::....^!~.:?~^?!!!!!?:YJ!^...~??~^~~7^^~^....:..:::::::::^^:~77!~::::^J5?7777???!^::^~~!?7^^^.                    .     .:::^!Y5!::::^^:^~7J~^5P!~?5J777JJ7~~~^:......::^^^~~~~~!!!!!!77~^::~7~~7!?5J7J7:.. :~~^~!7^ ~7~7?!^^!!~!!^.:^:.............:..:7&#10;.  ....................................::^~::^~~..::.....~!:.7!:!?!!!!?J^^Y~!:...~?7~~!!::.........::.....:::^^^^~!7??7!~^!???5J?77777~:.::~?7^^:                  .:.    .^:::75Y^..:::::^^^^:7BP7~~!J!!!!~~^~~~~~~^^^^::........:::^^~~~^::....^^~7!75J!?J~....~~^~!!. ~!~75Y!^~!~~!~:.^^:............:. .&#10;^^:...................................::~~.::~~:.::......~~ :7:.?!~!!7J^~:7?^!.  .~!~~7^:......:...^.......::.:^^::^^~7?JY?!!7PB?7?7777!:.. .::^^^.               ::  ...::^^^?GY:.........:^::^!~~!~~J~~^::...:::::::::::::::^^^^^^^^^:::.........:~7!7Y?!7?7:. .^~^~!~. ^!~!5Y7~!7!~~!^..^:............:.&#10;!~:..................................:^!^.::^!:.::.......!..!^.~7~!!!J7.^~:?~^~.  .^~^!:...........:............::..::::^~?J?!!??J5YYY?77^.      .^:....       .::.  .  :^::^5B?.....    ....7G~......^:........              ....^::::::.....  ....:~!!7J7!~7?!:. :~^~!^..^~^!5Y!~!7?!~!~..:^:...........:.&#10;^.   ...  .....:.:::................:^!:.:::~^..^:......:~ :~..7~~!!J?~.^^^:?~^~^. .:~~:..     ........................::^^^:^!!77JJ7~::^~^..      ..:::.    ...      .....:5G^          .  ?G!...:.................. ..... ....:JG5P!......~^.    ..:~!!!?!~~~!?!: .~^~!: .^~^!YY7~~!??!~!^ .^^:..........:&#10;:. ..     :^...   .^^::.............~!..::.~~..^:.......^:.^:.~!~!!J??::^^^^~?^:~!:  .~!~:.  .........           .............::!!^~!!~^^^^^:::...    .^^::..         .   :5J.         ....^~:                          ........YB#PGG.     ~55?.     :~!~!7!~^^~!7!..~^~~. .^~^~!!!~~~7J7~!~. :^^..........&#10;~^^.      ::::     .^:^............!J..::.^~:.::........:..:..7~~~7?77.:^^^^^!?^:^!~. .:!!~:.      .:.          ............ ....~J:.^^^~!~^^^^::^..:^~!!~!~.            ~57          .:...          ....                       ..^7Y5?      J55!..    .^7~~7~^^^^~7?~:^^~~. .^^:^^^~!!~~?J!~!: .:^:........&#10;?7^::.....:^:.    .:::^...........75:.::.:~^.::....... .: .:.~~~~!?!7~.^^^^^~^!7^^^!~:. .^!!^:.    .:.       ....              . .JY..:......::^^~77!!!^...^!~.        .?5^         .:.. .......::^^^..                            ^YY5:     !557 ...    ^7~~!~^^:^^~7?!!^~^ ..^::^^:^^~~~7J?!!^...^:.......&#10;??77!^:::^~^:....::::::..........!P~.::..~~..::.. .... :.....!~~~?!!7:.^^^^~^^^~!^^~ .... .^~^^^:.  ..                    ....... :PJ..^..........:~~~^^^:..:!7^.     :JJ.         .:..............                               .:JY5!     ^55J   ....  :!!~!~:^:^^^~77!~~: ..^..^^^^^:^~!?J7!~...:^:.....&#10; .~777!~^^^^::^::::::...........^57..^:.^~:.::. . .....:... ^~~~77~!7..^:^^~^:^~~~~:    ... .^~:::^:::              ...............~GJ.:^...........^^^:^^:::.^7~:   ^5?         .:....:::...            .....                    .:?55?     :55Y      ... .~~~!^::::^^^!7!~^. ..^..^^^^:::::!JJ!~:...^::...&#10;.  ...::::........:::..........:5J:.::.:~~..^:... ... :: ...!~~!?~~!!.:^:^^^^:::~~7:      ... .^~^..^~^.       .....................^7. ...  .       :^:::..:::^7!:.7G~        ..:.::^~^..         ...::^!~:.                     ..?55J     :YYY.        ....^~7^^:::^^^~!!~^...:^..^^^^.::..:7J7!^...:^:..&#10;!!^::::::.......:.::::.........?Y~.::..^~:.::........:?... ^!^~7!^!!!.::::^::::::~~~^:..  ..... .:~^..^^~^.  .................   .    ^?. ..          ^^..:  .::^7!!P:       ...:::^^:.       ...::::.....      ..               ..:?5YY.    :YYY.           ....^^^::::^^^~~~^...^:..^^^::^:...:7J!~...:^^.&#10;777!~~^^^::::::.:::^:::.......:J7:.^:..~~.:^:.......^?7....~~~!7^~!!!.:::^^.:::::^7~!!!~~^^:.......:~^:..:!~:..............           .Y?  ..         .~^... ...:!?!^        .::::..    ......:::...           .......         ....:75YY.    ^BGY.             ..  .:::::^^^^~~^...^..:^^:.^:.....:!7!:...^^&#10;?77!!!~~^^^:::::^:::::........!7!.:^..^~:.::.......~!J~ . .!^~7~^~!7!.:::::.::.::~~^~!!!!~~^:.........^~^.:^~!^..........              .7?. ..         .!:......!5!!!.      .::......::^:......           ....::..          ......::?5YY.    7B#5                .   .^^::^^^^^~^...^..:^^::^.......:~!^...^&#10;J??7!!!~~^^^:^^^::::.........^7!^.::..~~..^:.....:~~7J^ . ^~^!!^^~!7!.:::::.::.::~..:^~~~~~~~~^:.......:^~~:.:~!^.....                   !5^ ..         ~!.. .:JJ. .!:   ..:..::::::.........      ....::^^^^~:.    .............::^Y55J      :?!                 ..  :^^::::::^~^..:^..^^::^:........^!~...&#10;YJ??77!!~^^^^^:::... ........^77::^:..~^.:^.....:~:~!J: ..!~~!^^^~~7~.::^::.::..:!:  ..:^^:^!!!~~^:..:!:..:~!^:.~!:                       ~J. ..        ..   ^5!    :^   ...:.....  ...........:..:......::..     ..............::^~5557                            .  ^^^::::::^~^..^: :^^^^:.........:!~:.&#10;JJJ??7!~~^^^^::.............:^7!.^^..:~^.::....^^.:!!?.. .!^!~^^~~~~^.::^^:..:..^!!.    .::....:^^!7??~.....^!7~::~^.                       .!...          .7J.     .^   .7Y:    .........::::...      ...     ..:^^^^^^^^^~~!?JY5PGGY5^                             . .^^:::::::^~^..~..^^^^^...........~!^&#10;?!!??!~^^^:.................^:?!:^^..:~:.::...^^..:!!7.. :!^!~^^~~~:^.:.^^:..:..~^:::......:.....^~7?!!!~:....^!7!^~!.                     :JP55Y7!:      ~Y!       :.  ^5P^    .:::::::::..         ...    ..:~~~~~~~~!!!777J#B####GYY.    YJ^                       . .^^:.:::::^~:.^^..^^^^:...........^!&#10;!!7!7~:^:..................:^:?!:::..^~:.::..~^...~!!7.. ^~~!^^~~~::~...^^:..:..~^..:~~......:.:^^~~....:^~^.. .^7?!!7:                   757::?5?~?Y~..:??.        :.:JBG?7:    ....             ........:::::::::....::::^!?BBB###G5!    :P#5.                       . .^^:.:::::^^:.~:.:^^::............:&#10;7~!!7?!^:..................:::?~:^:..^~..::.~:..:.7~!7...!~!~^^~~:::^...^^^.....~^^^...^^:....::::~...    .:^:.  .^!77?.                 ^P7    .7?~~Y5??:       .:^YGGPYJJPB?                  .......:^^:..    ............^PBBB##BP:    YGG~                         . .:::.:::::^^::~..^^^::...........&#10;J7!~~7JJ^::................:::?~:^:..^~..:^~: .:.:7~!?. .!~7~^~~:::..:..^^~.....~~:......:::....^^....       .::... .^77.                !5~     .~?JJPG7     .~YG#BGJ^...:!BG.                .....:^::.            .........^GBB#BBP:.. ^55Y                           ..  .:::::::^::^^.:^^:::...........&#10;YY7~~~!77~^:...............:.:?!:^:..:~:.^^:..:: ~7~!?. .!~7^^!^:::..^..:^!....::........ .:^^^~~.......        ....  .!!:               ^5J.  ....~??JYBG!:^YB#BP?^.      ^BG.              .::::::.                 .......:.^GB#GP!....Y55!                            .    ^^:::::~::^::^^^:::..........&#10;5YJ!~~~!7?7^:..............:..7!:^:..:^::^:..::..!!~!?. .!!7^!^:::...:..:^~^..:!.............:~7^...   .....      ...   ~!~              .^!?77!!7Y5!~~7P##B##5!.          !GY                                         .......:.!B#GY:.. ~5YY.                             .    :^::^:^^.^^:^^^::::.........&#10;555?!!!!!!?J555?~:.........:..~!:^:..:^^^^:.:.. .!~~!J. .!77!~^:^:...:...^~~...^~:..... ...:::~^......      ...     ..  :.^!              .:..^!7~~~~!Y#G7^!BBPY!^:..     :55:                                         ..........J#GJ....Y55!                               .     :^^^:~^:^:^^^^:::.........&#10;5P55J77777?J5G#B5YJ~::.....:..:!^^:...^^::::... :!~~!J: .~7?!^^:^:....:..^^~....^:...   ..:.:^~....                 .   .. :!             :~!~^:....:?G!   :5B^^!7??Y555YYGG:                                           .........:BG!....5BG7                                .      .^^:~:^^:^:^^::^........&#10;Y55YJ!:...:^~!J~^~?5J7^:.......~^^^..:^^::^:....:!~~!Y^ :~?7~^~^::....^..^^~:..:^.... ...:.:^^:....                 .   ::  .~          ...:^.      ^B!  ...~B? ..:..::^~!~.                                             .........?P^....?BBY                                 ..      ^^^^:~:^::^^:::.......&#10;???7.           .~!!Y557:::....^~^^::^:^^^::....^!~~~J~ :~7~~^^^:::....:.:^~~..^:.......:::^^^....                 .    ~.   :.          ...        ?B:..    5B.  .                                                       ........:Y:..:.7PB5                               .  :.      :^~:^^^^::^::::......&#10;Y7:       ..    ..7!~~JBY^.::...~^^^^:.:^:.:....~~~~~J7 .!!~^::^^:::...:..^~^:.^.......::.::::...                      .:     .      .....          JB:      :BY                                                           ........7:..::Y555.                                 .^.      :~~^~:^::^^::^:.....&#10;?      .:~:.......:^~~~7GG! .~:.:~^^^..^^^.:.. .!~~~~?J..!7~^:::^^:::.....:^^^.:..:...:::.::^....                     .:             ...           .J#~       ~#7  .                                                        .......^:...:JBGP.                                  .^.      .!^!^^:::^^.:^.....&#10;    .....      ...  ..:~!P#J ~57^^^^:.^^.:^:....!~~~~7Y:.77~::^..^^:::..:.:^~^~:..::::::...:^...                     ..             ..            . :BP        7B~                                                          .......:^....!#BB^                                   .^...... ..::^^:::^::^:....&#10;..           .........::!!P#^ ~5Y~^^^^^...^:.. :7~~~^7Y~.7J^::^...:^:::..:.^~^^...::::::....:....                                  :.           .    ?B~        ?B~                                                          ......:^.....75G7...                                 .::::...      .::^^::::...&#10;         ...          ..^!!P7  7557^^^:....... :7~~~^!Y~.!5~:::....:^^::....~~^...::::......:....                                 ..           .     .J5^        7B!                                                         ......:J...... ..                                     .^^^::::.       ..::::..:&#10;      ...         ........~!!   J5Y::^^......  :?!~~~~!^:^57:^:......:^::::.^!:....::.......:....                                ..                   .?5^        ~P7                                                        ......^B:.....                                         .^:^:^^:.        ...^::.&#10;   ..          ...     ..:!7!^  ^55?  :^:.:..  ^?!~~~~^^^.J?^::........^:::::!.............:::...                               ..          .           !57        ^5J.                                                     .......7#?......                                         .:::......   ...   .^^:&#10;  ..        ...           :~7!^ .GP5.   :^...  ^?!~~^~^^~:!?~:^:........:::::^.......:::::.:::....                             ..         ..             :YJ.      .:?5!                                                   ........!BB:....J57.                                        .:::........      ^^:&#10;         ...        :!!~^:.:~7!  PBG:    ...   :?7~~~^::~~:?!~::..........::^:...:..::::::::::......                           :         ..               .75!     .. ^5Y:                                               .........:^Y#7... ~BBB~                                        .:^^::..   ..    ^^:&#10;       .:.        :?PGGPPY?!!77. PBB:      ..  :??~~~^::^!:!!~^^:...........:.....:.::::::.:::........                        :.        ..                  :YY:   ..  .757.                                          ............~:~BG... .Y55?                                           .:^^:    .....^^:&#10;       .        .7PGPJ77!!!7?J?..PBB.       .:..?J!~^::::~!^!^^^^:................:::::::.....:..........    .               .:        ..                    .~5?. .   ..:J5!                                ..  ............::::^^:.Y#7    75Y5.                                            .:^:      ..^^^&#10;       .      .~5GGP5Y7!~~~~!!?^.GBG.         . .!7~~:::.~!~^~^:^^:...........:.....:::::.....:...........   ....           .^.       ..                     ...757:    ...^5P~                         ... .... .....:::::^:::::!^:.:GG.   .5Y5!                                              .::     .:^~^&#10;             .7BP5PP55Y7~~^^~~!!:.!?.          .  .^~^^:.^!!^^^^:::......:.......:.....:::.....:........... ..::.....      .:~.  ..   :.                      .. ^55:  ... ..^YY^..                    ... ......:..::^^^^^^^^^^!~^~:.7#7    !5YY                                            ...:::.......~^&#10;~            :^J5J5555YY?!~^^^~!!:                  .::. ...             .::...:..:::..........:........... :::::.:.::......^^ ..... .:.                      . .^^JG7....  ..:7^.::.   ...........  ..:...::...::.:^^^^^^^^^^^~~^::~^:YB.   .YY5^                                                .:..  ..:^&#10;P!  .         .:~JJYY55YYJ!~^^^~~!^                   ..                   ::........:::........:.......... .::::..::^::::::~:.......^:...               ..  ....^~^^GY^::...~!77!~..:............ ......::::..:::::^^^^^^^^^^~~^^^::^^~GJ    ^55J                                                  .....~~~&#10;PB^  .         ..^7JJYY55YJ7~~^^^~!~.                  ...                  .:.....:....::.......:....:......:.:::.::^:::::^~..::::::^^:........................::^~.!!..~:..^!!~~!:.~~::::::::.........:::::..::::^^^^^^^^^^^~:^^^:.::::5~    ?55!                                                   ...~!!&#10;5BB~            ..:!JJJY55YY7~~~^^~??.           .        ..                ..::....::...........::....:::.......::.::^::::^~.:::::::^:^::...........:::....::..::~~^77^:!^:::~!!!^~!!..^:::::.:::.....::::^:..:::^^^^^^^^::^!^::^^^:.::.:J.   .Y55^                                                     ..^&#10;.5B?             ..:~?JJY55P?.!!!!~!?~.           .         .                .....::.:::..........^:..:..:::..::...:..:::::~^:::::::^^::^::::::::::::::...::::..::~.^777^.:^::^~!!!^!J~.:^::::::::::..:^:^^^..::::^^^^^^^^::7!~^::^^^.::: :~    :GBG:&#10; .:                ..:~!!!777:~~^^^^~.^                                         ...................^. ....... ........ ....:........::........................ ..::.^^^~^:::....^^^:.^~:............ .:...:. ........::::..:^^::....:....  ..    .~?J.&#10; */&#10;/*&#10;* powered by ANDRIY POPYK&#10;* in honor of MYSELF and SEGMENT DECOMPOSITION and N^(log(N)) and (Harry Potter and the Methods of Rationality) and Monkie D. Luffy&#10;*/&#10;&#10;#include &lt;bits/stdc++.h&gt;&#10;#include &lt;ext/pb_ds/assoc_container.hpp&gt;&#10;&#10;//#pragma GCC optimize(&quot;O3&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,fma&quot;)&#10;//#pragma GCC optimization (&quot;unroll-loops&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,sse,sse2,sse3,sse4,popcnt&quot;)&#10;&#10;using namespace std;&#10;using namespace __gnu_pbds;&#10;#define float long double&#10;#define elif else if&#10;#define endl &quot;\n&quot;&#10;//#define mod 1000000007&#10;#define pi acos(-1)&#10;#define eps 0.000000001&#10;#define inf 1000000000000&#10;#define FIXED(a) cout &lt;&lt; fixed &lt;&lt; setprecision(a)&#10;#define all(x) x.begin(), x.end()&#10;#define rall(x) x.rbegin(), x.rend()&#10;#define time_init auto start = std::chrono::high_resolution_clock::now()&#10;#define time_report                                       \&#10;    auto end = std::chrono::high_resolution_clock::now(); \&#10;    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count() &lt;&lt; &quot; ms&quot; &lt;&lt; endl&#10;#define debug(x) \&#10;    { cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; }&#10;#define len(x) (int) x.size()&#10;#define sqr(x) ((x) * (x))&#10;#define cube(x) ((x) * (x) * (x))&#10;#define bit(x, i) (((x) &gt;&gt; (i)) &amp; 1)&#10;#define set_bit(x, i) ((x) | (1LL &lt;&lt; (i)))&#10;#define clear_bit(x, i) ((x) &amp; (~(1LL &lt;&lt; (i))))&#10;#define toggle_bit(x, i) ((x) ^ (1LL &lt;&lt; (i)))&#10;#define low_bit(x) ((x) &amp; (-(x)))&#10;#define count_bit(x) __builtin_popcountll(x)&#10;#define srt(x) sort(all(x))&#10;#define rsrt(x) sort(rall(x))&#10;#define mp make_pair&#10;#define maxel(x) (*max_element(all(x)))&#10;#define minel(x) (*min_element(all(x)))&#10;#define maxelpos(x) (max_element(all(x)) - x.begin())&#10;#define minelpos(x) (min_element(all(x)) - x.begin())&#10;#define sum(x) (accumulate(all(x), 0LL))&#10;#define product(x) (accumulate(all(x), 1LL, multiplies&lt;int&gt;()))&#10;#define gcd __gcd&#10;#define lcm(a, b) ((a) / gcd(a, b) * (b))&#10;#define rev(x) (reverse(all(x)))&#10;#define shift_left(x, k) (rotate(x.begin(), x.begin() + k, x.end()))&#10;#define shift_right(x, k) (rotate(x.rbegin(), x.rbegin() + k, x.rend()))&#10;#define is_sorted(x) (is_sorted_until(all(x)) == x.end())&#10;#define is_even(x) (((x) &amp;1) == 0)&#10;#define is_odd(x) (((x) &amp;1) == 1)&#10;#define pow2(x) (1LL &lt;&lt; (x))&#10;&#10;struct custom_hash {&#10;    static uint64_t splitmix64(uint64_t x) {&#10;        // http://xorshift.di.unimi.it/splitmix64.c&#10;        x += 0x9e3779b97f4a7c15;&#10;        x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;&#10;        x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;&#10;        return x ^ (x &gt;&gt; 31);&#10;    }&#10;&#10;    size_t operator()(uint64_t x) const {&#10;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();&#10;        return splitmix64(x + FIXED_RANDOM);&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;using min_heap = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using max_heap = priority_queue&lt;T, vector&lt;T&gt;, less&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_multiset = tree&lt;T, null_type, less_equal&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;using hashmap = gp_hash_table&lt;int, int, custom_hash&gt;;&#10;template&lt;typename T&gt;&#10;using matrix = vector&lt;vector&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using graph = vector&lt;vector&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using vec = vector&lt;T&gt;;&#10;&#10;namespace internal {&#10;&#10;#ifndef _MSC_VER&#10;    template&lt;class T&gt;&#10;    using is_signed_int128 =&#10;            typename std::conditional&lt;std::is_same&lt;T, __int128_t&gt;::value ||&#10;                                      std::is_same&lt;T, __int128&gt;::value,&#10;                    std::true_type,&#10;                    std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int128 =&#10;            typename std::conditional&lt;std::is_same&lt;T, __uint128_t&gt;::value ||&#10;                                      std::is_same&lt;T, unsigned __int128&gt;::value,&#10;                    std::true_type,&#10;                    std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using make_unsigned_int128 =&#10;            typename std::conditional&lt;std::is_same&lt;T, __int128_t&gt;::value,&#10;                    __uint128_t,&#10;                    unsigned __int128&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_integral = typename std::conditional&lt;std::is_integral&lt;T&gt;::value ||&#10;                                                  is_signed_int128&lt;T&gt;::value ||&#10;                                                  is_unsigned_int128&lt;T&gt;::value,&#10;            std::true_type,&#10;            std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_signed_int = typename std::conditional&lt;(is_integral&lt;T&gt;::value &amp;&amp;&#10;                                                     std::is_signed&lt;T&gt;::value) ||&#10;                                                    is_signed_int128&lt;T&gt;::value,&#10;            std::true_type,&#10;            std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int =&#10;            typename std::conditional&lt;(is_integral&lt;T&gt;::value &amp;&amp;&#10;                                       std::is_unsigned&lt;T&gt;::value) ||&#10;                                      is_unsigned_int128&lt;T&gt;::value,&#10;                    std::true_type,&#10;                    std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using to_unsigned = typename std::conditional&lt;&#10;            is_signed_int128&lt;T&gt;::value,&#10;            make_unsigned_int128&lt;T&gt;,&#10;            typename std::conditional&lt;std::is_signed&lt;T&gt;::value,&#10;                    std::make_unsigned&lt;T&gt;,&#10;                    std::common_type&lt;T&gt;&gt;::type&gt;::type;&#10;&#10;#else&#10;&#10;    template&lt;class T&gt;&#10;    using is_integral = typename std::is_integral&lt;T&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_signed_int =&#10;            typename std::conditional&lt;is_integral&lt;T&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int =&#10;            typename std::conditional&lt;is_integral&lt;T&gt;::value &amp;&amp;&#10;                                              std::is_unsigned&lt;T&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using to_unsigned = typename std::conditional&lt;is_signed_int&lt;T&gt;::value,&#10;                                                  std::make_unsigned&lt;T&gt;,&#10;                                                  std::common_type&lt;T&gt;&gt;::type;&#10;&#10;#endif&#10;&#10;    template&lt;class T&gt;&#10;    using is_signed_int_t = std::enable_if_t&lt;is_signed_int&lt;T&gt;::value&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int_t = std::enable_if_t&lt;is_unsigned_int&lt;T&gt;::value&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using to_unsigned_t = typename to_unsigned&lt;T&gt;::type;&#10;&#10;}// namespace internal&#10;&#10;&#10;namespace internal {&#10;&#10;    // @param m `1 &lt;= m`&#10;    // @return x mod m&#10;    constexpr long long safe_mod(long long x, long long m) {&#10;        x %= m;&#10;        if (x &lt; 0) x += m;&#10;        return x;&#10;    }&#10;&#10;    // Fast modular multiplication by barrett reduction&#10;    // Reference: https://en.wikipedia.org/wiki/Barrett_reduction&#10;    // NOTE: reconsider after Ice Lake&#10;    struct barrett {&#10;        unsigned int _m;&#10;        unsigned long long im;&#10;&#10;        // @param m `1 &lt;= m`&#10;        explicit barrett(unsigned int m) : _m(m), im((unsigned long long) (-1) / m + 1) {}&#10;&#10;        // @return m&#10;        unsigned int umod() const { return _m; }&#10;&#10;        // @param a `0 &lt;= a &lt; m`&#10;        // @param b `0 &lt;= b &lt; m`&#10;        // @return `a * b % m`&#10;        unsigned int mul(unsigned int a, unsigned int b) const {&#10;            // [1] m = 1&#10;            // a = b = im = 0, so okay&#10;&#10;            // [2] m &gt;= 2&#10;            // im = ceil(2^64 / m)&#10;            // -&gt; im * m = 2^64 + r (0 &lt;= r &lt; m)&#10;            // let z = a*b = c*m + d (0 &lt;= c, d &lt; m)&#10;            // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im&#10;            // c*r + d*im &lt; m * m + m * im &lt; m * m + 2^64 + m &lt;= 2^64 + m * (m + 1) &lt; 2^64 * 2&#10;            // ((ab * im) &gt;&gt; 64) == c or c + 1&#10;            unsigned long long z = a;&#10;            z *= b;&#10;#ifdef _MSC_VER&#10;            unsigned long long x;&#10;            _umul128(z, im, &amp;x);&#10;#else&#10;            unsigned long long x =&#10;                    (unsigned long long) (((unsigned __int128) (z) * im) &gt;&gt; 64);&#10;#endif&#10;            unsigned long long y = x * _m;&#10;            return (unsigned int) (z - y + (z &lt; y ? _m : 0));&#10;        }&#10;    };&#10;&#10;    // @param n `0 &lt;= n`&#10;    // @param m `1 &lt;= m`&#10;    // @return `(x ** n) % m`&#10;    constexpr long long pow_mod_constexpr(long long x, long long n, int m) {&#10;        if (m == 1) return 0;&#10;        unsigned int _m = (unsigned int) (m);&#10;        unsigned long long r = 1;&#10;        unsigned long long y = safe_mod(x, m);&#10;        while (n) {&#10;            if (n &amp; 1) r = (r * y) % _m;&#10;            y = (y * y) % _m;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return r;&#10;    }&#10;&#10;    // Reference:&#10;    // M. Forisek and J. Jancina,&#10;    // Fast Primality Testing for Integers That Fit into a Machine Word&#10;    // @param n `0 &lt;= n`&#10;    constexpr bool is_prime_constexpr(int n) {&#10;        if (n &lt;= 1) return false;&#10;        if (n == 2 || n == 7 || n == 61) return true;&#10;        if (n % 2 == 0) return false;&#10;        long long d = n - 1;&#10;        while (d % 2 == 0) d /= 2;&#10;        constexpr long long bases[3] = {2, 7, 61};&#10;        for (long long a: bases) {&#10;            long long t = d;&#10;            long long y = pow_mod_constexpr(a, t, n);&#10;            while (t != n - 1 &amp;&amp; y != 1 &amp;&amp; y != n - 1) {&#10;                y = y * y % n;&#10;                t &lt;&lt;= 1;&#10;            }&#10;            if (y != n - 1 &amp;&amp; t % 2 == 0) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    template&lt;int n&gt;&#10;    constexpr bool is_prime = is_prime_constexpr(n);&#10;&#10;    // @param b `1 &lt;= b`&#10;    // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 &lt;= x &lt; b/g&#10;    constexpr std::pair&lt;long long, long long&gt; inv_gcd(long long a, long long b) {&#10;        a = safe_mod(a, b);&#10;        if (a == 0) return {b, 0};&#10;&#10;        // Contracts:&#10;        // [1] s - m0 * a = 0 (mod b)&#10;        // [2] t - m1 * a = 0 (mod b)&#10;        // [3] s * |m1| + t * |m0| &lt;= b&#10;        long long s = b, t = a;&#10;        long long m0 = 0, m1 = 1;&#10;&#10;        while (t) {&#10;            long long u = s / t;&#10;            s -= t * u;&#10;            m0 -= m1 * u;// |m1 * u| &lt;= |m1| * s &lt;= b&#10;&#10;            // [3]:&#10;            // (s - t * u) * |m1| + t * |m0 - m1 * u|&#10;            // &lt;= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)&#10;            // = s * |m1| + t * |m0| &lt;= b&#10;&#10;            auto tmp = s;&#10;            s = t;&#10;            t = tmp;&#10;            tmp = m0;&#10;            m0 = m1;&#10;            m1 = tmp;&#10;        }&#10;        // by [3]: |m0| &lt;= b/g&#10;        // by g != b: |m0| &lt; b/g&#10;        if (m0 &lt; 0) m0 += b / s;&#10;        return {s, m0};&#10;    }&#10;&#10;    // Compile time primitive root&#10;    // @param m must be prime&#10;    // @return primitive root (and minimum in now)&#10;    constexpr int primitive_root_constexpr(int m) {&#10;        if (m == 2) return 1;&#10;        if (m == 167772161) return 3;&#10;        if (m == 469762049) return 3;&#10;        if (m == 754974721) return 11;&#10;        if (m == 998244353) return 3;&#10;        int divs[20] = {};&#10;        divs[0] = 2;&#10;        int cnt = 1;&#10;        int x = (m - 1) / 2;&#10;        while (x % 2 == 0) x /= 2;&#10;        for (int i = 3; (long long) (i) * i &lt;= x; i += 2) {&#10;            if (x % i == 0) {&#10;                divs[cnt++] = i;&#10;                while (x % i == 0) {&#10;                    x /= i;&#10;                }&#10;            }&#10;        }&#10;        if (x &gt; 1) {&#10;            divs[cnt++] = x;&#10;        }&#10;        for (int g = 2;; g++) {&#10;            bool ok = true;&#10;            for (int i = 0; i &lt; cnt; i++) {&#10;                if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {&#10;                    ok = false;&#10;                    break;&#10;                }&#10;            }&#10;            if (ok) return g;&#10;        }&#10;    }&#10;&#10;    template&lt;int m&gt;&#10;    constexpr int primitive_root = primitive_root_constexpr(m);&#10;&#10;    // @param n `n &lt; 2^32`&#10;    // @param m `1 &lt;= m &lt; 2^32`&#10;    // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)&#10;    unsigned long long floor_sum_unsigned(unsigned long long n,&#10;                                          unsigned long long m,&#10;                                          unsigned long long a,&#10;                                          unsigned long long b) {&#10;        unsigned long long ans = 0;&#10;        while (true) {&#10;            if (a &gt;= m) {&#10;                ans += n * (n - 1) / 2 * (a / m);&#10;                a %= m;&#10;            }&#10;            if (b &gt;= m) {&#10;                ans += n * (b / m);&#10;                b %= m;&#10;            }&#10;&#10;            unsigned long long y_max = a * n + b;&#10;            if (y_max &lt; m) break;&#10;            // y_max &lt; m * (n + 1)&#10;            // floor(y_max / m) &lt;= n&#10;            n = (unsigned long long) (y_max / m);&#10;            b = (unsigned long long) (y_max % m);&#10;            std::swap(m, a);&#10;        }&#10;        return ans;&#10;    }&#10;&#10;}// namespace internal&#10;&#10;&#10;namespace internal {&#10;&#10;    struct modint_base {&#10;    };&#10;    struct static_modint_base : modint_base {&#10;    };&#10;&#10;    template&lt;class T&gt;&#10;    using is_modint = std::is_base_of&lt;modint_base, T&gt;;&#10;    template&lt;class T&gt;&#10;    using is_modint_t = std::enable_if_t&lt;is_modint&lt;T&gt;::value&gt;;&#10;&#10;}// namespace internal&#10;&#10;template&lt;int m, std::enable_if_t&lt;(1 &lt;= m)&gt; * = nullptr&gt;&#10;struct static_modint : internal::static_modint_base {&#10;    using mint = static_modint;&#10;&#10;public:&#10;    static constexpr int mod() { return m; }&#10;&#10;    static mint raw(int v) {&#10;        mint x;&#10;        x._v = v;&#10;        return x;&#10;    }&#10;&#10;    static_modint() : _v(0) {}&#10;&#10;    template&lt;class T, internal::is_signed_int_t&lt;T&gt; * = nullptr&gt;&#10;    static_modint(T v) {&#10;        long long x = (long long) (v % (long long) (umod()));&#10;        if (x &lt; 0) x += umod();&#10;        _v = (unsigned int) (x);&#10;    }&#10;&#10;    template&lt;class T, internal::is_unsigned_int_t&lt;T&gt; * = nullptr&gt;&#10;    static_modint(T v) {&#10;        _v = (unsigned int) (v % umod());&#10;    }&#10;&#10;    unsigned int val() const { return _v; }&#10;&#10;    mint &amp;operator++() {&#10;        _v++;&#10;        if (_v == umod()) _v = 0;&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator--() {&#10;        if (_v == 0) _v = umod();&#10;        _v--;&#10;        return *this;&#10;    }&#10;&#10;    mint operator++(int) {&#10;        mint result = *this;&#10;        ++*this;&#10;        return result;&#10;    }&#10;&#10;    mint operator--(int) {&#10;        mint result = *this;&#10;        --*this;&#10;        return result;&#10;    }&#10;&#10;    mint &amp;operator+=(const mint &amp;rhs) {&#10;        _v += rhs._v;&#10;        if (_v &gt;= umod()) _v -= umod();&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator-=(const mint &amp;rhs) {&#10;        _v -= rhs._v;&#10;        if (_v &gt;= umod()) _v += umod();&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator*=(const mint &amp;rhs) {&#10;        unsigned long long z = _v;&#10;        z *= rhs._v;&#10;        _v = (unsigned int) (z % umod());&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator/=(const mint &amp;rhs) { return *this = *this * rhs.inv(); }&#10;&#10;    mint operator+() const { return *this; }&#10;&#10;    mint operator-() const { return mint() - *this; }&#10;&#10;    mint pow(long long n) const {&#10;        assert(0 &lt;= n);&#10;        mint x = *this, r = 1;&#10;        while (n) {&#10;            if (n &amp; 1) r *= x;&#10;            x *= x;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return r;&#10;    }&#10;&#10;    mint inv() const {&#10;        if (prime) {&#10;            assert(_v);&#10;            return pow(umod() - 2);&#10;        } else {&#10;            auto eg = internal::inv_gcd(_v, m);&#10;            assert(eg.first == 1);&#10;            return eg.second;&#10;        }&#10;    }&#10;&#10;    friend mint operator+(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) += rhs;&#10;    }&#10;&#10;    friend mint operator-(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) -= rhs;&#10;    }&#10;&#10;    friend mint operator*(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) *= rhs;&#10;    }&#10;&#10;    friend mint operator/(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) /= rhs;&#10;    }&#10;&#10;    friend bool operator==(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v == rhs._v;&#10;    }&#10;&#10;    friend bool operator!=(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v != rhs._v;&#10;    }&#10;&#10;private:&#10;    unsigned int _v;&#10;&#10;    static constexpr unsigned int umod() { return m; }&#10;&#10;    static constexpr bool prime = internal::is_prime&lt;m&gt;;&#10;};&#10;&#10;template&lt;int id&gt;&#10;struct dynamic_modint : internal::modint_base {&#10;    using mint = dynamic_modint;&#10;&#10;public:&#10;    static int mod() { return (int) (bt.umod()); }&#10;&#10;    static void set_mod(int m) {&#10;        assert(1 &lt;= m);&#10;        bt = internal::barrett(m);&#10;    }&#10;&#10;    static mint raw(int v) {&#10;        mint x;&#10;        x._v = v;&#10;        return x;&#10;    }&#10;&#10;    dynamic_modint() : _v(0) {}&#10;&#10;    template&lt;class T, internal::is_signed_int_t&lt;T&gt; * = nullptr&gt;&#10;    dynamic_modint(T v) {&#10;        long long x = (long long) (v % (long long) (mod()));&#10;        if (x &lt; 0) x += mod();&#10;        _v = (unsigned int) (x);&#10;    }&#10;&#10;    template&lt;class T, internal::is_unsigned_int_t&lt;T&gt; * = nullptr&gt;&#10;    dynamic_modint(T v) {&#10;        _v = (unsigned int) (v % mod());&#10;    }&#10;&#10;    unsigned int val() const { return _v; }&#10;&#10;    mint &amp;operator++() {&#10;        _v++;&#10;        if (_v == umod()) _v = 0;&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator--() {&#10;        if (_v == 0) _v = umod();&#10;        _v--;&#10;        return *this;&#10;    }&#10;&#10;    mint operator++(int) {&#10;        mint result = *this;&#10;        ++*this;&#10;        return result;&#10;    }&#10;&#10;    mint operator--(int) {&#10;        mint result = *this;&#10;        --*this;&#10;        return result;&#10;    }&#10;&#10;    mint &amp;operator+=(const mint &amp;rhs) {&#10;        _v += rhs._v;&#10;        if (_v &gt;= umod()) _v -= umod();&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator-=(const mint &amp;rhs) {&#10;        _v += mod() - rhs._v;&#10;        if (_v &gt;= umod()) _v -= umod();&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator*=(const mint &amp;rhs) {&#10;        _v = bt.mul(_v, rhs._v);&#10;        return *this;&#10;    }&#10;&#10;    mint &amp;operator/=(const mint &amp;rhs) { return *this = *this * rhs.inv(); }&#10;&#10;    mint operator+() const { return *this; }&#10;&#10;    mint operator-() const { return mint() - *this; }&#10;&#10;    mint pow(long long n) const {&#10;        assert(0 &lt;= n);&#10;        mint x = *this, r = 1;&#10;        while (n) {&#10;            if (n &amp; 1) r *= x;&#10;            x *= x;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return r;&#10;    }&#10;&#10;    mint inv() const {&#10;        auto eg = internal::inv_gcd(_v, mod());&#10;        assert(eg.first == 1);&#10;        return eg.second;&#10;    }&#10;&#10;    friend mint operator+(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) += rhs;&#10;    }&#10;&#10;    friend mint operator-(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) -= rhs;&#10;    }&#10;&#10;    friend mint operator*(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) *= rhs;&#10;    }&#10;&#10;    friend mint operator/(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) /= rhs;&#10;    }&#10;&#10;    friend bool operator==(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v == rhs._v;&#10;    }&#10;&#10;    friend bool operator!=(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v != rhs._v;&#10;    }&#10;&#10;private:&#10;    unsigned int _v;&#10;    static internal::barrett bt;&#10;&#10;    static unsigned int umod() { return bt.umod(); }&#10;};&#10;&#10;template&lt;int id&gt;&#10;internal::barrett dynamic_modint&lt;id&gt;::bt(998244353);&#10;&#10;using modint998244353 = static_modint&lt;998244353&gt;;&#10;using modint1000000007 = static_modint&lt;1000000007&gt;;&#10;using modint = dynamic_modint&lt;-1&gt;;&#10;&#10;namespace internal {&#10;&#10;    template&lt;class T&gt;&#10;    using is_static_modint = std::is_base_of&lt;internal::static_modint_base, T&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_static_modint_t = std::enable_if_t&lt;is_static_modint&lt;T&gt;::value&gt;;&#10;&#10;    template&lt;class&gt;&#10;    struct is_dynamic_modint : public std::false_type {&#10;    };&#10;    template&lt;int id&gt;&#10;    struct is_dynamic_modint&lt;dynamic_modint&lt;id&gt;&gt; : public std::true_type {&#10;    };&#10;&#10;    template&lt;class T&gt;&#10;    using is_dynamic_modint_t = std::enable_if_t&lt;is_dynamic_modint&lt;T&gt;::value&gt;;&#10;&#10;}// namespace internal&#10;&#10;&#10;using mint = modint998244353;&#10;&#10;#define int long long&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; vect(int n, T val) {&#10;    return vector&lt;T&gt;(n, val);&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;T&gt;&gt; vect(int n, int m, T val) {&#10;    return vector&lt;vector&lt;T&gt;&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt; vect(int n, int m, int k, T val) {&#10;    return vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(n, vector&lt;vector&lt;T&gt;&gt;(m, vector&lt;T&gt;(k, val)));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt; vect(int n, int m, int k, int l, T val) {&#10;    return vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt;(n, vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(m, vector&lt;vector&lt;T&gt;&gt;(k, vector&lt;T&gt;(l, val))));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;matrix&lt;T&gt; new_matrix(int n, int m, T val) {&#10;    return matrix&lt;T&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;graph&lt;T&gt; new_graph(int n) {&#10;    return graph&lt;T&gt;(n);&#10;}&#10;&#10;template&lt;class T, class S&gt;&#10;inline bool chmax(T &amp;a, const S &amp;b) {&#10;    return (a &lt; b ? a = b, 1 : 0);&#10;}&#10;&#10;template&lt;class T, class S&gt;&#10;inline bool chmin(T &amp;a, const S &amp;b) {&#10;    return (a &gt; b ? a = b, 1 : 0);&#10;}&#10;&#10;using i8 = int8_t;&#10;using i16 = int16_t;&#10;using i32 = int32_t;&#10;using i64 = int64_t;&#10;using u8 = uint8_t;&#10;using u16 = uint16_t;&#10;using u32 = uint32_t;&#10;using u64 = uint64_t;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".sparsetable" value="template&lt;typename it&gt;&#10;struct SparseTable {&#10;&#10;    using T = typename remove_reference&lt;decltype(*declval&lt;it&gt;())&gt;::type;&#10;    vector&lt;vector&lt;T&gt;&gt; t;&#10;    function&lt;T(T, T)&gt; f;&#10;    vector&lt;int&gt; log;&#10;&#10;    SparseTable() = default;&#10;&#10;    SparseTable(it first, it last, function&lt;T(T, T)&gt; op) : t(1), f(op) {&#10;        int n = distance(first, last);&#10;        t.assign(32 - __builtin_clz(n), vector&lt;T&gt;(n));&#10;        t[0].assign(first, last);&#10;        //       calc log&#10;        log.resize(n + 1);&#10;        for (int i = 2; i &lt;= n; i++)&#10;            log[i] = log[i / 2] + 1;&#10;&#10;        for (int i = 1; i &lt; t.size(); i++)&#10;            for (int j = 0; j &lt; n - (1 &lt;&lt; i) + 1; j++)&#10;                t[i][j] = f(t[i - 1][j], t[i - 1][j + (1 &lt;&lt; (i - 1))]);&#10;    }&#10;&#10;    // returns f(a[l..r]) in O(1) time&#10;    T get(int l, int r) {&#10;        int h = log[r - l + 1];&#10;        return f(t[h][l], t[h][r - (1 &lt;&lt; h) + 1]);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".Matrix" value="template&lt;typename T, size_t n, size_t m&gt;&#10;class Matrix {&#10;    array&lt;array&lt;T, m&gt;, n&gt; mat{};&#10;&#10;    [[nodiscard]] static bool is_square() {&#10;        return n == m;&#10;    }&#10;&#10;&#10;public:&#10;    static Matrix&lt;T, n, m&gt; identity() {&#10;        if (!is_square())&#10;            throw runtime_error(&quot;Matrix is not square&quot;);&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            res[i][i] = 1;&#10;        return res;&#10;    }&#10;&#10;    Matrix() = default;&#10;&#10;    explicit Matrix(const array&lt;array&lt;T, m&gt;, n&gt; &amp;mat) : mat(mat) {}&#10;&#10;    explicit Matrix(const vector&lt;vector&lt;T&gt;&gt; &amp;mat) {&#10;        if (mat.size() != n || mat[0].size() != m)&#10;            throw runtime_error(&quot;Matrix has wrong size&quot;);&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                this-&gt;mat[i][j] = mat[i][j];&#10;    }&#10;&#10;    explicit Matrix(const initializer_list&lt;initializer_list&lt;T&gt;&gt; &amp;mat) {&#10;        if (mat.size() != n || mat.begin()-&gt;size() != m)&#10;            throw runtime_error(&quot;Matrix has wrong size&quot;);&#10;        int i = 0;&#10;        for (const auto &amp;row: mat) {&#10;            int j = 0;&#10;            for (const auto &amp;x: row) {&#10;                this-&gt;mat[i][j] = x;&#10;                j++;&#10;            }&#10;            i++;&#10;        }&#10;    }&#10;&#10;    array&lt;T, m&gt; &amp;operator[](int i) {&#10;        return mat[i];&#10;    }&#10;&#10;    const array&lt;T, m&gt; &amp;operator[](int i) const {&#10;        return mat[i];&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator+(const Matrix&lt;T, n, m&gt; &amp;other) const {&#10;&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] + other[i][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator-(const Matrix&lt;T, n, m&gt; &amp;other) const {&#10;        if (mat.size() != other.size() || mat[0].size() != other[0].size())&#10;            throw runtime_error(&quot;Matrix has wrong size&quot;);&#10;&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] - other[i][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator-() {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = -mat[i][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator*(const T &amp;other) const {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] * other;&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator/(const T &amp;other) const {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] / other;&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator%(const T &amp;other) const {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] % other;&#10;        return res;&#10;    }&#10;&#10;&#10;    template&lt;size_t k&gt;&#10;    Matrix&lt;T, n, m&gt; operator*(const Matrix&lt;T, m, k&gt; &amp;other) const {&#10;        Matrix&lt;T, n, k&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; k; j++)&#10;                for (int l = 0; l &lt; m; l++)&#10;                    res[i][j] += mat[i][l] * other[l][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator^(int k) const {&#10;        if (!is_square())&#10;            throw runtime_error(&quot;Matrix is not square&quot;);&#10;        Matrix&lt;T, n, m&gt; res = identity();&#10;        Matrix&lt;T, n, m&gt; a = *this;&#10;        while (k) {&#10;            if (k &amp; 1)&#10;                res = res * a;&#10;            a = a * a;&#10;            k &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;&#10;&#10;    Matrix&lt;T, n, m&gt; operator+=(const Matrix&lt;T, n, m&gt; &amp;other) {&#10;        return *this = *this + other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator-=(const Matrix&lt;T, n, m&gt; &amp;other) {&#10;        return *this = *this - other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator*=(const T &amp;other) {&#10;        return *this = *this * other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator/=(const T &amp;other) {&#10;        return *this = *this / other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator%=(const T &amp;other) {&#10;        return *this = *this % other;&#10;    }&#10;&#10;&#10;    Matrix&lt;T, n, m&gt; operator^=(const int &amp;other) {&#10;        return *this = *this ^ other;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".wavelet" value="class WaveletTree {&#10;    int low, high;&#10;    WaveletTree *left, *right;&#10;    vector&lt;int&gt; freq;&#10;&#10;public:&#10;    WaveletTree(vec&lt;int&gt;::iterator from, vec&lt;int&gt;::iterator to, int _low, int _high) : low(_low), high(_high) {&#10;        if (from &gt; to) return;&#10;        if (low == high) return;&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        auto lowerThanMid = [mid](int x) { return x &lt;= mid; };&#10;        freq.reserve(to - from + 1);&#10;        freq.push_back(0);&#10;        for (auto it = from; it != to; it++) {&#10;            freq.push_back(freq.back() + lowerThanMid(*it));&#10;        }&#10;        auto pivot = stable_partition(from, to, lowerThanMid);&#10;&#10;        if (from != pivot) {&#10;            left = new WaveletTree(from, pivot, low, mid);&#10;        }&#10;        if (pivot != to) {&#10;            right = new WaveletTree(pivot, to, mid + 1, high);&#10;        }&#10;    }&#10;&#10;&#10;    int equal(int l, int r, int k) {&#10;        if (l &gt; r || k &lt; low || k &gt; high) return 0;&#10;        if (low == high) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        if (k &lt;= mid) return left-&gt;equal(lb + 1, rb, k);&#10;        return right-&gt;equal(l - lb, r - rb, k);&#10;    }&#10;&#10;    int smaller(int l, int r, int k) {&#10;        if (l &gt; r || k &lt;= low) return 0;&#10;        if (k &gt; high) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;smaller(lb + 1, rb, k) + right-&gt;smaller(l - lb, r - rb, k);&#10;    }&#10;&#10;    int smaller_equal(int l, int r, int k) {&#10;        if (l &gt; r || k &lt; low) return 0;&#10;        if (k &gt;= high) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;smaller_equal(lb + 1, rb, k) + right-&gt;smaller_equal(l - lb, r - rb, k);&#10;    }&#10;&#10;    int bigger(int l, int r, int k) {&#10;        if (l &gt; r || k &gt;= high) return 0;&#10;        if (k &lt; low) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;bigger(lb + 1, rb, k) + right-&gt;bigger(l - lb, r - rb, k);&#10;    }&#10;&#10;    int bigger_equal(int l, int r, int k) {&#10;        if (l &gt; r || k &gt; high) return 0;&#10;        if (k &lt;= low) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;bigger_equal(lb + 1, rb, k) + right-&gt;bigger_equal(l - lb, r - rb, k);&#10;    }&#10;&#10;    int kth(int l, int r, int k) {&#10;        if (l &gt; r) return -1;&#10;        if (r - l + 1 &lt; k)&#10;            throw runtime_error(&quot;kth element doesn't exist&quot;);&#10;        if (low == high) return low;&#10;        int left_part = freq[r] - freq[l - 1];&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        if (k &lt;= left_part) return left-&gt;kth(lb + 1, rb, k);&#10;        return right-&gt;kth(l - lb, r - rb, k - left_part);&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".BitBor" value="template&lt;i32 bitCount&gt;&#10;struct DynamicBitBor {&#10;    struct vertex {&#10;        i32 next[2]{};&#10;        i32 cnt;&#10;&#10;        vertex() {&#10;            next[0] = next[1] = -1;&#10;            cnt = 0;&#10;        }&#10;    };&#10;    vector&lt;vertex&gt; bor;&#10;    void createVertex() {&#10;        bor.emplace_back();&#10;    }&#10;&#10;    void addToVertex(i32 v, i32 x) {&#10;        createVertex();&#10;        bor[v].next[x] = bor.size() - 1;&#10;    }&#10;&#10;public:&#10;    DynamicBitBor() {&#10;        bor.emplace_back();&#10;    }&#10;&#10;    void insert(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt++;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            if (bor[v].next[x] == -1) {&#10;                addToVertex(v, x);&#10;            }&#10;            v = bor[v].next[x];&#10;            bor[v].cnt++;&#10;        }&#10;    }&#10;&#10;    void remove(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt--;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            v = bor[v].next[x];&#10;            bor[v].cnt--;&#10;        }&#10;        bor[v].removeTerminal();&#10;    }&#10;    int countPref(int pref, int sz) {&#10;        int v = 0;&#10;        for (int i = bitCount - 1; i &gt;= bitCount - sz; i--) {&#10;            int bit = bit(pref, i);&#10;            if (bor[v].next[bit] == -1) {&#10;                return 0;&#10;            }&#10;            v = bor[v].next[bit];&#10;        }&#10;        return bor[v].cnt;&#10;    }&#10;&#10;    int count(int value) {&#10;        return countPref(value, bitCount);&#10;    }&#10;&#10;    bool contains(int value) {&#10;        return count(value) &gt; 0;&#10;    }&#10;&#10;    void clear() {&#10;        bor.clear();&#10;        bor.emplace_back();&#10;    }&#10;&#10;&#10;    int maxXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit ^ 1] != -1) {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            } else {&#10;                v = bor[v].next[bit];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int minXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit] != -1) {&#10;                v = bor[v].next[bit];&#10;            } else {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int size() {&#10;        return bor[0].cnt;&#10;    }&#10;};&#10;&#10;&#10;template&lt;i32 bitCount, int maxSize&gt;&#10;struct StaticBitBor {&#10;    struct vertex {&#10;        i32 next[2]{};&#10;        i32 cnt;&#10;&#10;        vertex() {&#10;            next[0] = next[1] = -1;&#10;            cnt = 0;&#10;        }&#10;    };&#10;    vertex bor[maxSize];&#10;    int ptr = 0;&#10;    void createVertex() {&#10;        bor[ptr++] = vertex();&#10;    }&#10;&#10;    void addToVertex(i32 v, i32 x) {&#10;        createVertex();&#10;        bor[v].next[x] = ptr - 1;&#10;    }&#10;&#10;public:&#10;    StaticBitBor() {&#10;        createVertex();&#10;    }&#10;&#10;    void insert(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt++;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            if (bor[v].next[x] == -1) {&#10;                addToVertex(v, x);&#10;            }&#10;            v = bor[v].next[x];&#10;            bor[v].cnt++;&#10;        }&#10;    }&#10;&#10;    void remove(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt--;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            v = bor[v].next[x];&#10;            bor[v].cnt--;&#10;        }&#10;        bor[v].removeTerminal();&#10;    }&#10;    int countPref(int pref, int sz) {&#10;        int v = 0;&#10;        for (int i = bitCount - 1; i &gt;= bitCount - sz; i--) {&#10;            int bit = bit(pref, i);&#10;            if (bor[v].next[bit] == -1) {&#10;                return 0;&#10;            }&#10;            v = bor[v].next[bit];&#10;        }&#10;        return bor[v].cnt;&#10;    }&#10;&#10;    int count(int value) {&#10;        return countPref(value, bitCount);&#10;    }&#10;&#10;    bool contains(int value) {&#10;        return count(value) &gt; 0;&#10;    }&#10;&#10;    void clear() {&#10;        ptr = 0;&#10;        createVertex();&#10;    }&#10;&#10;&#10;    int maxXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit ^ 1] != -1) {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            } else {&#10;                v = bor[v].next[bit];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int minXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit] != -1) {&#10;                v = bor[v].next[bit];&#10;            } else {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int size() {&#10;        return bor[0].cnt;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".hullTrick" value="struct line {&#10;    float k{}, b{};&#10;    line() = default;&#10;    line(int k, int b) : k(k), b(b) {}&#10;    float operator()(float x) const {&#10;        return k * x + b;&#10;    }&#10;};&#10;&#10;float cross(line l1, line l2) {&#10;    return (l2.b - l1.b) / (l1.k - l2.k);&#10;}&#10;&#10;struct HullTrickMin {&#10;    deque&lt;line&gt; lines;&#10;&#10;    void addLine(line l) {&#10;        while (len(lines) &gt;= 2) {&#10;            line l1 = lines[len(lines) - 2];&#10;            line l2 = lines[len(lines) - 1];&#10;            if (cross(l1, l2) &gt; cross(l2, l)) {&#10;                lines.pop_back();&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        lines.push_back(l);&#10;    }&#10;&#10;    //n*log(n)&#10;    float getMin(float x) {&#10;        int l = 0, r = len(lines) - 1;&#10;        while (l &lt; r) {&#10;            int m = (l + r) / 2;&#10;            if (lines[m](x) &gt; lines[m + 1](x)) {&#10;                l = m + 1;&#10;            } else {&#10;                r = m;&#10;            }&#10;        }&#10;        return lines[l](x);&#10;    }&#10;};&#10;&#10;struct HullTrickMax {&#10;    vector&lt;line&gt; lines;&#10;&#10;    // Helper function to check if a line is redundant&#10;    static bool isRedundant(const line &amp;l1, const line &amp;l2, const line &amp;l3) {&#10;        return cross(l1, l3) &lt;= cross(l1, l2);&#10;    }&#10;&#10;    // Add a line to the convex lines&#10;    void addLine(line l) {&#10;        while (lines.size() &gt;= 2 &amp;&amp; isRedundant(lines[len(lines) - 2], lines[len(lines) - 1], l)) {&#10;            lines.pop_back();&#10;        }&#10;        lines.push_back(l);&#10;    }&#10;&#10;    // Get the maximum value for a given x coordinate&#10;    float getMax(float x) {&#10;        int left = 0, right = len(lines) - 1;&#10;        while (left &lt; right) {&#10;            int mid = (left + right) / 2;&#10;            if (lines[mid](x) &lt; lines[mid + 1](x))&#10;                left = mid + 1;&#10;            else&#10;                right = mid;&#10;        }&#10;        return lines[left](x);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".rand" value="#ifdef LOCAL&#10;mt19937 randEngine(0);&#10;#else&#10;mt19937 randEngine(chrono::steady_clock::now().time_since_epoch().count());&#10;#endif&#10;&#10;int randInt(int l, int r) {&#10;    return uniform_int_distribution&lt;int&gt;(l, r)(randEngine);&#10;}&#10;float randFloat(float l, float r) {&#10;    return uniform_real_distribution&lt;float&gt;(l, r)(randEngine);&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".hashing" value="template&lt;i128 p, i128 md&gt;&#10;struct Hashing {&#10;    vector&lt;i128&gt; p_pow;&#10;    vector&lt;i128&gt; h;&#10;&#10;&#10;    Hashing() = default;&#10;&#10;    explicit Hashing(const string &amp;s) {&#10;        int n = len(s);&#10;        p_pow.resize(n);&#10;        h.resize(n);&#10;        p_pow[0] = 1;&#10;        for (int i = 1; i &lt; n; ++i) {&#10;            p_pow[i] = (p_pow[i - 1] * p);&#10;            p_pow[i] %= md;&#10;        }&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            h[i] = ((s[i] - 'a' + 1) * p_pow[i]);&#10;            h[i] %= md;&#10;            if (i)&#10;                h[i] = (h[i] + h[i - 1]);&#10;            h[i] %= md;&#10;        }&#10;    }&#10;&#10;    i128 get(int l, int r) {&#10;        if (r &lt; l)&#10;            return 0;&#10;        int res = h[r];&#10;        if (l)&#10;            res = (res - h[l - 1]);&#10;        res %= md;&#10;        res += md;&#10;        res %= md;&#10;        res = (res * p_pow[len(h) - l - 1]);&#10;        res %= md;&#10;        return res;&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".convex" value="struct line {&#10;    int k, b;&#10;    line() : k(0), b(0) {}&#10;    line(int k, int b) : k(k), b(b) {}&#10;    int operator()(int x) const {&#10;        return k * x + b;&#10;    }&#10;};&#10;&#10;template&lt;typename comparer_func, typename compressor_func, typename validator_func&gt;&#10;struct LiChaoTree {&#10;    comparer_func comparer;&#10;    compressor_func compressor;&#10;    validator_func validator;&#10;    vector&lt;line&gt; tree;&#10;    int default_value{};&#10;    size_t sizeTree{};&#10;    void add_line(line l, int v, int tl, int tr) {&#10;        int tm = (tl + tr) &gt;&gt; 1;&#10;        bool left = comparer(l(compressor(tl)), tree[v](compressor(tl)));&#10;        bool mid = comparer(l(compressor(tm)), tree[v](compressor(tm)));&#10;        if (mid) {&#10;            swap(l, tree[v]);&#10;        }&#10;        if (tl == tr) {&#10;            return;&#10;        }&#10;        if (left != mid) {&#10;            add_line(l, v * 2, tl, tm);&#10;        } else {&#10;            add_line(l, v * 2 + 1, tm + 1, tr);&#10;        }&#10;    }&#10;&#10;    int func(int a, int b) {&#10;        if (comparer(a, b)) {&#10;            return a;&#10;        }&#10;        return b;&#10;    }&#10;&#10;&#10;    int get(int v, int tl, int tr, int x) {&#10;        if (tl == tr) {&#10;            return tree[v](x);&#10;        }&#10;        int tm = (tl + tr) &gt;&gt; 1;&#10;        if (x &lt;= tm) {&#10;            return func(tree[v](x), get(v * 2, tl, tm, x));&#10;        } else {&#10;            return func(tree[v](x), get(v * 2 + 1, tm + 1, tr, x));&#10;        }&#10;    }&#10;&#10;&#10;public:&#10;    LiChaoTree(int from, int to, int default_value_, comparer_func comparer, compressor_func compressor, validator_func validator) : comparer(comparer), compressor(std::move(compressor)), validator(validator) {&#10;        default_value = default_value_;&#10;        if (from &gt; to) {&#10;            swap(from, to);&#10;        }&#10;        sizeTree = to - from + 1;&#10;        tree.resize((sizeTree + 5) * 4, line(0, default_value));&#10;    }&#10;&#10;    void add_line(line l) {&#10;        add_line(l, 1, 0, sizeTree - 1);&#10;    }&#10;&#10;    int get(int x) {&#10;        if (!validator(x))&#10;            throw runtime_error(&quot;invalid x&quot;);&#10;        return get(1, 0, sizeTree - 1, compressor(x));&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".lichao" value="//LiChaoTree start&#10;&#10;struct line {&#10;    int k, b;&#10;    line() : k(0), b(0) {}&#10;    line(int k, int b) : k(k), b(b) {}&#10;    int operator()(int x) const {&#10;        return k * x + b;&#10;    }&#10;};&#10;&#10;&#10;auto comparer = [](int a, int b) { return a &lt; b; };&#10;auto compressor = [](int a) { return a; };&#10;auto validator = [](int a) { return true; };&#10;&#10;vector&lt;line&gt; liChaoTree;&#10;int default_value{};&#10;size_t sizeTree{};&#10;//    res lines witch we have deleted&#10;void add_line(line l, int v, int tl, int tr, vector&lt;pair&lt;int, line&gt;&gt; &amp;changed) {&#10;    int tm = (tl + tr) &gt;&gt; 1;&#10;    bool left = comparer(l(compressor(tl)), liChaoTree[v](compressor(tl)));&#10;    bool mid = comparer(l(compressor(tm)), liChaoTree[v](compressor(tm)));&#10;    if (mid) {&#10;        swap(l, liChaoTree[v]);&#10;        changed.emplace_back(v, l);&#10;    }&#10;    if (tl == tr) {&#10;        return;&#10;    }&#10;    if (left != mid) {&#10;        add_line(l, v * 2, tl, tm, changed);&#10;    } else {&#10;        add_line(l, v * 2 + 1, tm + 1, tr, changed);&#10;    }&#10;}&#10;&#10;int func(int a, int b) {&#10;    if (comparer(a, b)) {&#10;        return a;&#10;    }&#10;    return b;&#10;}&#10;&#10;&#10;int get(int v, int tl, int tr, int x) {&#10;    if (tl == tr) {&#10;        return liChaoTree[v](x);&#10;    }&#10;    int tm = (tl + tr) &gt;&gt; 1;&#10;    if (x &lt;= compressor(tm)) {&#10;        return func(liChaoTree[v](x), get(v * 2, tl, tm, x));&#10;    } else {&#10;        return func(liChaoTree[v](x), get(v * 2 + 1, tm + 1, tr, x));&#10;    }&#10;}&#10;&#10;void init(int from, int to, int default_value_) {&#10;    default_value = default_value_;&#10;    if (from &gt; to) {&#10;        swap(from, to);&#10;    }&#10;    sizeTree = to - from + 1;&#10;    liChaoTree.resize((sizeTree + 5) * 4, line(0, default_value));&#10;}&#10;&#10;vector&lt;pair&lt;int, line&gt;&gt; add_line(line l) {&#10;    vector&lt;pair&lt;int, line&gt;&gt; res;&#10;    add_line(l, 1, 0, sizeTree - 1, res);&#10;    return res;&#10;}&#10;&#10;&#10;void forcePush(vector&lt;pair&lt;int, line&gt;&gt; &amp;changed) {&#10;    for (auto &amp;i: changed) {&#10;        liChaoTree[i.first] = i.second;&#10;    }&#10;    changed.clear();&#10;}&#10;&#10;int get(int x) {&#10;    if (!validator(x))&#10;        throw runtime_error(&quot;invalid x&quot;);&#10;    return get(1, 0, sizeTree - 1, compressor(x));&#10;}&#10;//LiChaoTree end" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".segmentTree" value="template&lt;typename T&gt;&#10;class setter {&#10;public:&#10;    T operator()(T a, T b) {&#10;        return b;&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;class minimum {&#10;public:&#10;    T operator()(T a, T b) {&#10;        if (a &lt; b) return a;&#10;        return b;&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;class maximum {&#10;public:&#10;    T operator()(T a, T b) {&#10;        if (a &gt; b) return a;&#10;        return b;&#10;    }&#10;};&#10;&#10;&#10;template&lt;typename T, size_t max_size, class Combiner, class Updater, auto identity&gt;&#10;class LazySegmentTree {&#10;private:&#10;    array&lt;T, 4 * max_size&gt; tree;&#10;    array&lt;T, 4 * max_size&gt; lazy;&#10;    array&lt;bool, 4 * max_size&gt; lazy_flag;&#10;    Combiner combiner;&#10;    Updater updater;&#10;    T identity_element = identity();&#10;    int n;&#10;    void push(int node, int l, int r) {&#10;        if (lazy_flag[node]) {&#10;            tree[node] = updater(tree[node], lazy[node]);&#10;            if (l != r) {&#10;                lazy[2 * node + 1] = updater(lazy[2 * node + 1], lazy[node]);&#10;                lazy[2 * node + 2] = updater(lazy[2 * node + 2], lazy[node]);&#10;                lazy_flag[2 * node + 1] = lazy_flag[2 * node + 2] = true;&#10;            }&#10;            lazy[node] = identity_element;&#10;            lazy_flag[node] = false;&#10;        }&#10;    }&#10;&#10;    void update(int node, int l, int r, int ql, int qr, T val) {&#10;        push(node, l, r);&#10;        if (l &gt; qr || r &lt; ql) {&#10;            return;&#10;        }&#10;        if (l &gt;= ql &amp;&amp; r &lt;= qr) {&#10;            lazy[node] = updater(lazy[node], val);&#10;            lazy_flag[node] = true;&#10;            push(node, l, r);&#10;            return;&#10;        }&#10;        int mid = (l + r) / 2;&#10;        update(2 * node + 1, l, mid, ql, qr, val);&#10;        update(2 * node + 2, mid + 1, r, ql, qr, val);&#10;        tree[node] = combiner(tree[2 * node + 1], tree[2 * node + 2]);&#10;    }&#10;&#10;    T get(int node, int l, int r, int ql, int qr) {&#10;        push(node, l, r);&#10;        if (l &gt; qr || r &lt; ql) {&#10;            return identity_element;&#10;        }&#10;        if (l &gt;= ql &amp;&amp; r &lt;= qr) {&#10;            return tree[node];&#10;        }&#10;        int mid = (l + r) / 2;&#10;        T left = get(2 * node + 1, l, mid, ql, qr);&#10;        T right = get(2 * node + 2, mid + 1, r, ql, qr);&#10;        return combiner(left, right);&#10;    }&#10;&#10;    void build(vector&lt;T&gt; &amp;v, int node, int l, int r) {&#10;        if (l == r) {&#10;            tree[node] = v[l];&#10;            return;&#10;        }&#10;        int mid = (l + r) / 2;&#10;        build(v, 2 * node + 1, l, mid);&#10;        build(v, 2 * node + 2, mid + 1, r);&#10;        tree[node] = combiner(tree[2 * node + 1], tree[2 * node + 2]);&#10;    }&#10;&#10;public:&#10;    LazySegmentTree() {&#10;        n = max_size;&#10;        fill(all(lazy_flag), false);&#10;        fill(all(tree), identity_element);&#10;        fill(all(lazy), identity_element);&#10;    }&#10;    void build(int _n) {&#10;        n = _n;&#10;        build(vect(n, identity_element), 0, 0, n - 1);&#10;    }&#10;    void build(vector&lt;T&gt; &amp;v) {&#10;        n = v.size();&#10;        build(v, 0, 0, n - 1);&#10;    }&#10;&#10;    void update(int l, int r, T val) {&#10;        update(0, 0, n - 1, l, r, val);&#10;    }&#10;&#10;    void update(int i, T val) {&#10;        update(0, 0, n - 1, i, i, val);&#10;    }&#10;&#10;    T get(int l, int r) {&#10;        return get(0, 0, n - 1, l, r);&#10;    }&#10;&#10;    T get(int i) {&#10;        return get(0, 0, n - 1, i, i);&#10;    }&#10;};&#10;int countr_zero(unsigned int n) {&#10;#ifdef _MSC_VER&#10;    unsigned long index;&#10;    _BitScanForward(&amp;index, n);&#10;    return index;&#10;#else&#10;    return __builtin_ctz(n);&#10;#endif&#10;}&#10;unsigned int bit_ceil(unsigned int n) {&#10;    unsigned int x = 1;&#10;    while (x &lt; (unsigned int) (n)) x *= 2;&#10;    return x;&#10;}&#10;&#10;template&lt;typename T, size_t max_size, class Combiner, class Updater, auto identity&gt;&#10;class SegmentTree {&#10;private:&#10;    vector&lt;T&gt; tree;&#10;    Combiner combiner;&#10;    Updater updater;&#10;    T identity_element = identity();&#10;    int __n, size, log;&#10;    void update(int k) { tree[k] = combiner(tree[2 * k], tree[2 * k + 1]); }&#10;&#10;public:&#10;    void build(vector&lt;T&gt; &amp;v) {&#10;        __n = len(v);&#10;        size = (int) bit_ceil(__n);&#10;        log = countr_zero((unsigned int) size);&#10;        tree.resize(2 * size, identity_element);&#10;        for (int i = 0; i &lt; __n; i++) {&#10;            tree[size + i] = v[i];&#10;        }&#10;        for (int i = size - 1; i &gt; 0; i--) {&#10;            update(i);&#10;        }&#10;    }&#10;&#10;    void update(int pos, T val) {&#10;        assert(0 &lt;= pos &amp;&amp; pos &lt; __n);&#10;        pos += size;&#10;        tree[pos] = updater(tree[pos], val);&#10;        for (int i = 1; i &lt;= log; i++) {&#10;            update(pos &gt;&gt; i);&#10;        }&#10;    }&#10;&#10;    T get(int l, int r) {&#10;        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; __n);&#10;        l += size;&#10;        r += size;&#10;        r++;&#10;        T left = identity_element;&#10;        T right = identity_element;&#10;        while (l &lt; r) {&#10;            if (l &amp; 1) {&#10;                left = combiner(left, tree[l++]);&#10;            }&#10;            if (r &amp; 1) {&#10;                right = combiner(tree[--r], right);&#10;            }&#10;            l &gt;&gt;= 1;&#10;            r &gt;&gt;= 1;&#10;        }&#10;        return combiner(left, right);&#10;    }&#10;&#10;    T get(int pos) {&#10;        assert(0 &lt;= pos &amp;&amp; pos &lt; __n);&#10;        return tree[size + pos];&#10;    }&#10;    &#10;};&#10;&#10;&#10;int identity() {&#10;    return 0;&#10;}&#10;&#10;struct reverser {&#10;    int operator()(int a, int b) {&#10;        if (a == 1)&#10;            return 0;&#10;        return 1;&#10;    }&#10;};&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".lca" value="struct LCA {&#10;private:&#10;    graph&lt;int&gt; g;&#10;    int root, n;&#10;    vector&lt;int&gt; depth, tin, tout;&#10;    vector&lt;vector&lt;int&gt;&gt; up;&#10;    int timer;&#10;    const int MAX_LOG = 20;&#10;&#10;    void build_dfs(int v, int p, int d) {&#10;        depth[v] = d;&#10;        tin[v] = timer++;&#10;        up[v][0] = p;&#10;        for (int i = 1; i &lt; MAX_LOG; ++i) {&#10;            if (up[v][i - 1] != -1) {&#10;                up[v][i] = up[up[v][i - 1]][i - 1];&#10;            }&#10;        }&#10;        for (auto &amp;to: g[v]) {&#10;            if (to != p) {&#10;                build_dfs(to, v, d + 1);&#10;            }&#10;        }&#10;        tout[v] = timer++;&#10;    }&#10;&#10;public:&#10;    LCA(graph&lt;int&gt; &amp;g, int root = 0) : g(g), root(root) {&#10;        n = len(g);&#10;        depth = tin = tout = vector&lt;int&gt;(n);&#10;        timer = 0;&#10;        up = vect&lt;int&gt;(n, MAX_LOG, -1);&#10;        build_dfs(root, root, 0);&#10;    }&#10;&#10;&#10;    bool is_ancestor(int u, int v) {&#10;        return tin[u] &lt;= tin[v] &amp;&amp; tout[u] &gt;= tout[v];&#10;    }&#10;&#10;    int lca(int u, int v) {&#10;        if (is_ancestor(u, v)) {&#10;            return u;&#10;        }&#10;        if (is_ancestor(v, u)) {&#10;            return v;&#10;        }&#10;        for (int i = MAX_LOG - 1; i &gt;= 0; --i) {&#10;            if (!is_ancestor(up[u][i], v)) {&#10;                u = up[u][i];&#10;            }&#10;        }&#10;        return up[u][0];&#10;    }&#10;&#10;    int dist(int u, int v) {&#10;        return depth[u] + depth[v] - 2 * depth[lca(u, v)];&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".mo3d" value="struct query {&#10;    int l, r;&#10;    int t;&#10;    int id;&#10;};&#10;&#10;struct update {&#10;    int pos;&#10;    int val;&#10;    int prev;&#10;    int time;&#10;};&#10;vector&lt;int&gt; a;&#10;int blockSize;&#10;&#10;&#10;bool cmp(query &amp;x, query &amp;y) {&#10;    if (x.l / blockSize != y.l / blockSize)&#10;        return x.l / blockSize &lt; y.l / blockSize;&#10;    if (x.r / blockSize != y.r / blockSize)&#10;        return x.r / blockSize &lt; y.r / blockSize;&#10;    return x.t &lt; y.t;&#10;}&#10;&#10;&#10;int curL = 0, curR = -1;&#10;int curT = 0;&#10;int curAns = 0;&#10;int K;&#10;int M;&#10;vector&lt;int&gt; cnt;&#10;&#10;void add(int pos) {&#10;    if (cnt[a[pos]] == K - 1) {&#10;        curAns++;&#10;    }&#10;    if (cnt[a[pos]] == K) {&#10;        curAns--;&#10;    }&#10;    cnt[a[pos]]++;&#10;}&#10;void remove(int pos) {&#10;    if (cnt[a[pos]] == K + 1) {&#10;        curAns++;&#10;    }&#10;    if (cnt[a[pos]] == K) {&#10;        curAns--;&#10;    }&#10;    cnt[a[pos]]--;&#10;}&#10;&#10;void apply(int pos, int val) {&#10;    if (pos &gt;= curL &amp;&amp; pos &lt;= curR) {&#10;        remove(pos);&#10;        a[pos] = val;&#10;        add(pos);&#10;    } else {&#10;        a[pos] = val;&#10;    }&#10;}&#10;&#10;&#10;signed main() {&#10;    ios_base::sync_with_stdio(false);&#10;    cin.tie(nullptr);&#10;    cout.tie(nullptr);&#10;    int q;&#10;    int n;&#10;    cin &gt;&gt; n &gt;&gt; M &gt;&gt; q &gt;&gt; K;&#10;    cnt.resize(M + 1, 0);&#10;    a = vect(n, 0LL);&#10;    for (int i = 0; i &lt; n; i++) {&#10;        cin &gt;&gt; a[i];&#10;    }&#10;    auto aCP = a;&#10;    blockSize = pow(n, 2.0 / 3.0);&#10;    if (K == 0) {&#10;        curAns = M;&#10;    }&#10;    vector&lt;query&gt; queries;&#10;    vector&lt;update&gt; updates;&#10;    for (int i = 0; i &lt; q; i++) {&#10;        int type;&#10;        cin &gt;&gt; type;&#10;        if (type == 1) {&#10;            int l, r;&#10;            cin &gt;&gt; l &gt;&gt; r;&#10;            l--;&#10;            r--;&#10;            queries.push_back({l, r, len(updates), len(queries)});&#10;        } else {&#10;            int pos, val;&#10;            cin &gt;&gt; pos &gt;&gt; val;&#10;            pos--;&#10;            updates.push_back({pos, val, a[pos], len(updates)});&#10;            a[pos] = val;&#10;        }&#10;    }&#10;    a = aCP;&#10;    sort(all(queries), cmp);&#10;    vector&lt;int&gt; ans(len(queries));&#10;    for (auto [l, r, t, id]: queries) {&#10;        while (curT &lt; t) {&#10;            auto [pos, val, prev, time] = updates[curT];&#10;            apply(pos, val);&#10;            curT++;&#10;        }&#10;        while (curT &gt; t) {&#10;            curT--;&#10;            auto [pos, val, prev, time] = updates[curT];&#10;            apply(pos, prev);&#10;        }&#10;&#10;        while (curL &gt; l) {&#10;            curL--;&#10;            add(curL);&#10;        }&#10;        while (curR &lt; r) {&#10;            curR++;&#10;            add(curR);&#10;        }&#10;        while (curL &lt; l) {&#10;            remove(curL);&#10;            curL++;&#10;        }&#10;&#10;        while (curR &gt; r) {&#10;            remove(curR);&#10;            curR--;&#10;        }&#10;        ans[id] = curAns;&#10;    }&#10;    for (auto &amp;x: ans) {&#10;        cout &lt;&lt; x &lt;&lt; endl;&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".comb" value="template&lt;typename T&gt;&#10;struct Factorials {&#10;    vector&lt;T&gt; fact;&#10;    explicit Factorials(int n) {&#10;        fact.resize(n + 1);&#10;        fact[0] = 1;&#10;        for (int i = 1; i &lt;= n; ++i) {&#10;            fact[i] = fact[i - 1] * i;&#10;        }&#10;    }&#10;&#10;    T operator()(int n) {&#10;        return fact[n];&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;struct Catalans {&#10;    vector&lt;T&gt; cat;&#10;    explicit Catalans(int n) {&#10;        cat.resize(n + 1);&#10;        cat[0] = 1;&#10;        for (int i = 1; i &lt;= n; ++i) {&#10;            cat[i] = cat[i - 1] * (4 * i - 2) / (i + 1);&#10;        }&#10;    }&#10;&#10;    T operator()(int n) {&#10;        return cat[n];&#10;    }&#10;};&#10;&#10;Factorials&lt;mint&gt; fact(2e5 + 5);&#10;&#10;mint C(int n, int k) {&#10;    if (k &lt; 0 || k &gt; n) return 0;&#10;    return fact(n) / (fact(k) * fact(n - k));&#10;}&#10;&#10;mint A(int n, int k) {&#10;    if (k &lt; 0 || k &gt; n) return 0;&#10;    return fact(n) / fact(n - k);&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".point" value="template&lt;typename T&gt;&#10;struct Point {&#10;    T x, y;&#10;&#10;    Point() : x(0), y(0) {}&#10;    Point(T x, T y) : x(x), y(y) {}&#10;    explicit Point(pair&lt;T, T&gt; p) : x(p.first), y(p.second) {}&#10;    Point(const Point&lt;T&gt; &amp;p) : x(p.x), y(p.y) {}&#10;    Point(Point&lt;T&gt; &amp;&amp;p)  noexcept : x(p.x), y(p.y) {}&#10;    Point&lt;T&gt; &amp;operator=(const Point&lt;T&gt; &amp;p) {&#10;        x = p.x;&#10;        y = p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator=(Point&lt;T&gt; &amp;&amp;p) noexcept {&#10;        x = p.x;&#10;        y = p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator+=(const Point&lt;T&gt; &amp;p) {&#10;        x += p.x;&#10;        y += p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator-=(const Point&lt;T&gt; &amp;p) {&#10;        x -= p.x;&#10;        y -= p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator*=(const T &amp;k) {&#10;        x *= k;&#10;        y *= k;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator/=(const T &amp;k) {&#10;        x /= k;&#10;        y /= k;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; operator+(const Point&lt;T&gt; &amp;p) const {&#10;        return Point&lt;T&gt;(*this) += p;&#10;    }&#10;    Point&lt;T&gt; operator-(const Point&lt;T&gt; &amp;p) const {&#10;        return Point&lt;T&gt;(*this) -= p;&#10;    }&#10;    Point&lt;T&gt; operator*(const T &amp;k) const {&#10;        return Point&lt;T&gt;(*this) *= k;&#10;    }&#10;    Point&lt;T&gt; operator/(const T &amp;k) const {&#10;        return Point&lt;T&gt;(*this) /= k;&#10;    }&#10;    bool operator==(const Point&lt;T&gt; &amp;p) const {&#10;        return x == p.x &amp;&amp; y == p.y;&#10;    }&#10;    bool operator!=(const Point&lt;T&gt; &amp;p) const {&#10;        return x != p.x || y != p.y;&#10;    }&#10;    bool operator&lt;(const Point&lt;T&gt; &amp;p) const {&#10;        return x &lt; p.x || (x == p.x &amp;&amp; y &lt; p.y);&#10;    }&#10;    bool operator&gt;(const Point&lt;T&gt; &amp;p) const {&#10;        return x &gt; p.x || (x == p.x &amp;&amp; y &gt; p.y);&#10;    }&#10;    bool operator&lt;=(const Point&lt;T&gt; &amp;p) const {&#10;        return x &lt;= p.x || (x == p.x &amp;&amp; y &lt;= p.y);&#10;    }&#10;    bool operator&gt;=(const Point&lt;T&gt; &amp;p) const {&#10;        return x &gt;= p.x || (x == p.x &amp;&amp; y &gt;= p.y);&#10;    }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Point&lt;T&gt; &amp;p) {&#10;        is &gt;&gt; p.x &gt;&gt; p.y;&#10;        return is;&#10;    }&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point&lt;T&gt; &amp;p) {&#10;        os &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;&#10;        return os;&#10;    }&#10;};&#10;typedef Point&lt;int&gt; ipoint;&#10;typedef Point&lt;float&gt; fpoint;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".factorize" value="vec&lt;int&gt; factorize(int x) {&#10;    vec&lt;int&gt; ans;&#10;    for (int i = 2; i * i &lt;= x; ++i) {&#10;        if (x % i == 0) {&#10;            ans.push_back(i);&#10;            while (x % i == 0) {&#10;                x /= i;&#10;            }&#10;        }&#10;    }&#10;    if (x &gt; 1) {&#10;        ans.push_back(x);&#10;    }&#10;    return ans;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".dividers" value="vec&lt;int&gt; dividers(int x) {&#10;    if (x == 1) return {};&#10;    vec&lt;int&gt; ans;&#10;    for (int i = 1; i * i &lt;= x; ++i) {&#10;        if (x % i == 0) {&#10;            ans.push_back(i);&#10;            if (i * i != x) ans.push_back(x / i);&#10;        }&#10;    }&#10;    return ans;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".scc" value="struct SCC {&#10;private:&#10;    graph&lt;int&gt; g;&#10;    graph&lt;int&gt; g_rev;&#10;    vec&lt;bool&gt; used;&#10;public:&#10;    int n;&#10;&#10;&#10;    graph&lt;int&gt; condensation;&#10;    vec&lt;int&gt; ordered;&#10;    vec&lt;int&gt; comp;&#10;    vec&lt;vec&lt;int&gt;&gt; components;&#10;&#10;    void top_sort(int v) {&#10;        used[v] = true;&#10;        for (auto u: g[v]) {&#10;            if (!used[u]) {&#10;                top_sort(u);&#10;            }&#10;        }&#10;        ordered.push_back(v);&#10;    }&#10;&#10;    void build_comp(int v, int k) {&#10;        used[v] = true;&#10;        comp[v] = k;&#10;        for (auto u: g_rev[v]) {&#10;            if (!used[u]) {&#10;                build_comp(u, k);&#10;            }&#10;        }&#10;    }&#10;&#10;    explicit SCC(graph&lt;int&gt; &amp;g) {&#10;        this-&gt;n = len(g);&#10;        init();&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            for (auto u: g[i]) {&#10;                add_edge(i, u);&#10;            }&#10;        }&#10;    }&#10;&#10;    void add_edge(int v, int u) {&#10;        g[v].push_back(u);&#10;        g_rev[u].push_back(v);&#10;    }&#10;&#10;    void init() {&#10;        g = new_graph&lt;int&gt;(n);&#10;        g_rev = new_graph&lt;int&gt;(n);&#10;        used = vect&lt;bool&gt;(n, false);&#10;        ordered.clear();&#10;        comp = vect&lt;int&gt;(n, -1);&#10;        components.clear();&#10;        condensation.clear();&#10;    }&#10;&#10;    int build_components() {&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            if (!used[i]) {&#10;                top_sort(i);&#10;            }&#10;        }&#10;        rev(ordered);&#10;        used = vect&lt;bool&gt;(n, false);&#10;        int k = 0;&#10;        for (auto v: ordered) {&#10;            if (!used[v]) {&#10;                build_comp(v, k++);&#10;            }&#10;        }&#10;        components = vect&lt;vec&lt;int&gt;&gt;(k, vec&lt;int&gt;());&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            components[comp[i]].push_back(i);&#10;        }&#10;        return k;&#10;    }&#10;&#10;    void build_condensation() {&#10;        int k = len(components);&#10;        vec&lt;set&lt;int&gt;&gt; cond(k);&#10;        for (int i = 0; i &lt; k; ++i) {&#10;            for (auto v: components[i]) {&#10;                for (auto u: g[v]) {&#10;                    if (comp[u] != i) {&#10;                        cond[i].insert(comp[u]);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        condensation = new_graph&lt;int&gt;(k);&#10;        for (int i = 0; i &lt; k; ++i) {&#10;            for (auto u: cond[i]) {&#10;                condensation[i].push_back(u);&#10;            }&#10;        }&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".centroidDecomp" value="struct edge {&#10;    int to, w;&#10;};&#10;&#10;graph&lt;edge&gt; g;&#10;vec&lt;int&gt; sizes;&#10;vec&lt;bool&gt; removed;&#10;&#10;void calc_sizes(int v, int p) {&#10;    sizes[v] = 1;&#10;    for (auto [u, w]: g[v]) {&#10;        if (u == p) continue;&#10;        if (removed[u]) continue;&#10;        calc_sizes(u, v);&#10;        sizes[v] += sizes[u];&#10;    }&#10;}&#10;&#10;int n;&#10;int sz = 0;&#10;&#10;int find_centroid(int v, int p) {&#10;    for (auto [u, w]: g[v]) {&#10;        if (u == p) continue;&#10;        if (removed[u]) continue;&#10;        if (sizes[u] &gt; sz / 2) return find_centroid(u, v);&#10;    }&#10;    return v;&#10;}&#10;&#10;vec&lt;vec&lt;int&gt;&gt; centroidParents;&#10;&#10;void fill_centroid(int v, int p, int c) {&#10;    centroidParents[c].push_back(v);&#10;    for (auto [u, w]: g[v]) {&#10;        if (u == p) continue;&#10;        if (removed[u]) continue;&#10;        fill_centroid(u, v, c);&#10;    }&#10;}&#10;&#10;void calc_stat(int centroid){&#10;    &#10;}&#10;&#10;&#10;void decompose(int v) {&#10;    calc_sizes(v, -1);&#10;    sz = sizes[v];&#10;    int centroid = find_centroid(v, -1);&#10;    fill_centroid(v, -1, centroid);&#10;    calc_stat(centroid);&#10;    removed[centroid] = true;&#10;    for (auto [u, w]: g[centroid]) {&#10;        if (removed[u]) continue;&#10;        decompose(u);&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".basis" value="struct basis {&#10;    vec&lt;int&gt; base;&#10;&#10;    bool add(int x) {&#10;        for (auto i: base) {&#10;            chmin(x, x ^ i);&#10;        }&#10;        if (x == 0) return false;&#10;        for (auto &amp;i: base) {&#10;            chmin(i, i ^ x);&#10;        }&#10;        base.push_back(x);&#10;        return true;&#10;    }&#10;&#10;    int get_max() {&#10;        int ans = 0;&#10;        for (auto i: base) {&#10;            chmax(ans, ans ^ i);&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    bool check(int x) {&#10;        for (auto i: base) {&#10;            chmin(x, x ^ i);&#10;        }&#10;        return x == 0;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".lis" value="int lis(vec&lt;int&gt; &amp;v) {&#10;    vec&lt;int&gt; d(len(v) + 1, inf);&#10;    d[0] = -inf;&#10;    for (int i = 0; i &lt; len(v); i++) {&#10;        int l = upper_bound(all(d), v[i]) - d.begin();&#10;        if (d[l - 1] &lt; v[i] and v[i] &lt; d[l])&#10;            d[l] = v[i];&#10;    }&#10;    for (int i = len(v); i &gt;= 0; i--) {&#10;        if (d[i] != inf)&#10;            return i;&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".mmstack" value="template&lt;typename T&gt;&#10;struct min_stack {&#10;    stack&lt;pair&lt;T, T&gt;&gt; st;&#10;&#10;    void push(T x) {&#10;        if (st.empty()) {&#10;            st.push({x, x});&#10;        } else {&#10;            st.push({x, min(x, st.top().second)});&#10;        }&#10;    }&#10;&#10;    void pop() {&#10;        st.pop();&#10;    }&#10;&#10;    T best() {&#10;        return st.top().second;&#10;    }&#10;&#10;    T top() {&#10;        return st.top().first;&#10;    }&#10;&#10;    bool empty() {&#10;        return st.empty();&#10;    }&#10;&#10;    int size() {&#10;        return st.size();&#10;    }&#10;&#10;    void clear() {&#10;        while (!st.empty()) {&#10;            st.pop();&#10;        }&#10;    }&#10;    &#10;    &#10;};&#10;&#10;template&lt;typename T&gt;&#10;struct max_stack {&#10;    stack&lt;pair&lt;T, T&gt;&gt; st;&#10;&#10;    void push(T x) {&#10;        if (st.empty()) {&#10;            st.push({x, x});&#10;        } else {&#10;            st.push({x, max(x, st.top().second)});&#10;        }&#10;    }&#10;&#10;    void pop() {&#10;        st.pop();&#10;    }&#10;&#10;    T best() {&#10;        return st.top().second;&#10;    }&#10;&#10;    T top() {&#10;        return st.top().first;&#10;    }&#10;&#10;    bool empty() {&#10;        return st.empty();&#10;    }&#10;&#10;    int size() {&#10;        return st.size();&#10;    }&#10;&#10;    void clear() {&#10;        while (!st.empty()) {&#10;            st.pop();&#10;        }&#10;    }&#10;&#10;&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".mmqueue" value="template&lt;typename T&gt;&#10;struct min_queue {&#10;    min_stack&lt;T&gt; st1, st2;&#10;&#10;    void push(T x) {&#10;        st1.push(x);&#10;    }&#10;&#10;    void pop() {&#10;        if (st2.empty()) {&#10;            while (!st1.empty()) {&#10;                st2.push(st1.top());&#10;                st1.pop();&#10;            }&#10;        }&#10;        st2.pop();&#10;    }&#10;&#10;    T best() {&#10;        if (st1.empty()) {&#10;            return st2.best();&#10;        } else if (st2.empty()) {&#10;            return st1.best();&#10;        } else {&#10;            return min(st1.best(), st2.best());&#10;        }&#10;    }&#10;&#10;    T front() {&#10;        if (st2.empty()) {&#10;            while (!st1.empty()) {&#10;                st2.push(st1.top());&#10;                st1.pop();&#10;            }&#10;        }&#10;        return st2.top();&#10;    }&#10;&#10;    bool empty() {&#10;        return st1.empty() &amp;&amp; st2.empty();&#10;    }&#10;&#10;    int size() {&#10;        return st1.size() + st2.size();&#10;    }&#10;&#10;    void clear() {&#10;        st1.clear();&#10;        st2.clear();&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;struct max_queue {&#10;    max_stack&lt;T&gt; st1, st2;&#10;&#10;    void push(T x) {&#10;        st1.push(x);&#10;    }&#10;&#10;    void pop() {&#10;        if (st2.empty()) {&#10;            while (!st1.empty()) {&#10;                st2.push(st1.top());&#10;                st1.pop();&#10;            }&#10;        }&#10;        st2.pop();&#10;    }&#10;&#10;    T best() {&#10;        if (st1.empty()) {&#10;            return st2.best();&#10;        } else if (st2.empty()) {&#10;            return st1.best();&#10;        } else {&#10;            return max(st1.best(), st2.best());&#10;        }&#10;    }&#10;&#10;    T front() {&#10;        if (st2.empty()) {&#10;            while (!st1.empty()) {&#10;                st2.push(st1.top());&#10;                st1.pop();&#10;            }&#10;        }&#10;        return st2.top();&#10;    }&#10;&#10;    bool empty() {&#10;        return st1.empty() &amp;&amp; st2.empty();&#10;    }&#10;&#10;    int size() {&#10;        return st1.size() + st2.size();&#10;    }&#10;&#10;    void clear() {&#10;        st1.clear();&#10;        st2.clear();&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".s_time" value="class s_time {&#10;public:&#10;    int h, m, s;&#10;&#10;&#10;    int to_seconds() const {&#10;        return h * 3600 + m * 60 + s;&#10;    }&#10;&#10;    int operator-(const s_time &amp;other) {&#10;        return to_seconds() - other.to_seconds() + (to_seconds() &lt; other.to_seconds() ? 3600 * 24 : 0);&#10;    }&#10;&#10;    s_time operator+(int seconds) {&#10;        return s_time((to_seconds() + seconds) % (3600 * 24));&#10;    }&#10;&#10;    s_time operator+=(int seconds) {&#10;        return *this = *this + seconds;&#10;    }&#10;&#10;&#10;    s_time(int h, int m, int s) : h(h), m(m), s(s) {}&#10;&#10;    s_time() : s_time(0, 0, 0) {}&#10;&#10;    s_time(int seconds) : s_time(seconds / 3600, (seconds % 3600) / 60, seconds % 60) {}&#10;&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, s_time &amp;t) {&#10;        char c;&#10;        is &gt;&gt; t.h &gt;&gt; c &gt;&gt; t.m &gt;&gt; c &gt;&gt; t.s;&#10;        return is;&#10;    }&#10;&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const s_time &amp;t) {&#10;        if (t.h &lt; 10) os &lt;&lt; 0;&#10;        os &lt;&lt; t.h &lt;&lt; &quot;:&quot;;&#10;        if (t.m &lt; 10) os &lt;&lt; 0;&#10;        os &lt;&lt; t.m &lt;&lt; &quot;:&quot;;&#10;        if (t.s &lt; 10) os &lt;&lt; 0;&#10;        os &lt;&lt; t.s;&#10;        return os;&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".powers" value="template&lt;typename T&gt;&#10;struct Powers {&#10;    vec&lt;T&gt; powers;&#10;&#10;    Powers(const T base, const int maxN) {&#10;        powers.resize(maxN + 1);&#10;        powers[0] = 1;&#10;        for (int i = 1; i &lt;= maxN; ++i) {&#10;            powers[i] = powers[i - 1] * base;&#10;        }&#10;    }&#10;&#10;    T operator()(const int i) const {&#10;        return powers[i];&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".count_bits" value="int count_bits(int x) {&#10;    if (x &lt;= 0)&#10;        return 0;&#10;    int ans = 0;&#10;    for (int bId = 0; bId &lt; 63; ++bId) {&#10;        int curAns = 0;&#10;        int tX = x;&#10;        if (bit(x, bId)) {&#10;            curAns += (x &amp; (pow2(bId) - 1)) + 1;&#10;        }&#10;        tX &amp;= (((pow2(62) - 1) &gt;&gt; (bId + 1)) &lt;&lt; (bId + 1));&#10;        curAns += tX / 2;&#10;        ans += curAns;&#10;    }&#10;    return ans;&#10;}&#10;&#10;int count_bits(int l, int r) {&#10;    return count_bits(r) - count_bits(l - 1);&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".fenvik" value="template&lt;typename T&gt;&#10;struct fenvik {&#10;private:&#10;    vec&lt;T&gt; tree;&#10;    vec&lt;T&gt; arr;&#10;    int n{};&#10;&#10;//    r is from 0 to n - 1&#10;    T get(int r) {&#10;        T res = 0;&#10;        for (; r &gt;= 0; r = (r &amp; (r + 1)) - 1) {&#10;            res += tree[r];&#10;        }&#10;        return res;&#10;    }&#10;&#10;&#10;public:&#10;    fenvik() = default;&#10;&#10;    explicit fenvik(int n, T val = 0) {&#10;        this-&gt;n = n;&#10;        tree.resize(n);&#10;        arr.resize(n);&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            add(i, val);&#10;        }&#10;    }&#10;&#10;    explicit fenvik(const vec&lt;int&gt; &amp;v) {&#10;        this-&gt;n = v.size();&#10;        tree.resize(n);&#10;        arr.resize(n);&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            add(i, v[i]);&#10;        }&#10;    }&#10;&#10;    T get(int l, int r) {&#10;        if (l == 0) return get(r);&#10;        return get(r) - get(l - 1);&#10;    }&#10;&#10;    void add(int i, T val) {&#10;        arr[i] += val;&#10;        for (; i &lt; n; i = (i | (i + 1))) {&#10;            tree[i] += val;&#10;        }&#10;    }&#10;&#10;    void set(int i, T val) {&#10;        add(i, val - arr[i]);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".bridges" value="struct Bridges {&#10;private:&#10;    graph&lt;pair&lt;int, int&gt;&gt; g;&#10;    vector&lt;int&gt; tin, fup;&#10;    vector&lt;bool&gt; used;&#10;    int timer;&#10;&#10;&#10;    void build_dfs(int v, int p = -1, int edge_idx = -1) {&#10;        used[v] = true;&#10;        tin[v] = fup[v] = timer++;&#10;        for (auto [u, id]: g[v]) {&#10;            if (u == p) {&#10;                continue;&#10;            }&#10;            if (used[u]) {&#10;                fup[v] = min(fup[v], tin[u]);&#10;            } else {&#10;                build_dfs(u, v, id);&#10;                fup[v] = min(fup[v], fup[u]);&#10;            }&#10;        }&#10;        if (p != -1 and fup[v] &gt; tin[p]) {&#10;            is_bridge[edge_idx] = true;&#10;            bridges.insert(edge_idx);&#10;        }&#10;    }&#10;&#10;    void build_components_dfs(int v, int comp) {&#10;        components[v] = comp;&#10;        for (auto [u, id]: g[v]) {&#10;            if (components[u] == -1 and !is_bridge[id]) {&#10;                build_components_dfs(u, comp);&#10;            }&#10;        }&#10;    }&#10;&#10;public:&#10;    set&lt;int&gt; bridges;&#10;    vec&lt;bool&gt; is_bridge;&#10;    vec&lt;int&gt; components;&#10;    int components_count;&#10;    graph&lt;int&gt; condensation;&#10;&#10;    Bridges(graph&lt;int&gt; &amp;gt) {&#10;        vec&lt;pair&lt;int, int&gt;&gt; edges;&#10;        for (int i = 0; i &lt; len(gt); ++i) {&#10;            for (auto &amp;to: gt[i]) {&#10;                if (i &lt; to) {&#10;                    edges.emplace_back(i, to);&#10;                }&#10;            }&#10;        }&#10;        g = graph&lt;pair&lt;int, int&gt;&gt;(len(gt));&#10;        int idx = 0;&#10;        for (auto &amp;edge: edges) {&#10;            g[edge.first].emplace_back(edge.second, idx);&#10;            g[edge.second].emplace_back(edge.first, idx);&#10;            ++idx;&#10;        }&#10;        tin = fup = vector&lt;int&gt;(len(g));&#10;        used = vector&lt;bool&gt;(len(g));&#10;        timer = 0;&#10;        is_bridge = vec&lt;bool&gt;(idx);&#10;        for (int i = 0; i &lt; len(g); ++i) {&#10;            if (!used[i]) {&#10;                build_dfs(i);&#10;            }&#10;        }&#10;    }&#10;&#10;    void build_components() {&#10;        components = vec&lt;int&gt;(len(g), -1);&#10;        components_count = 0;&#10;        for (int i = 0; i &lt; len(g); ++i) {&#10;            if (components[i] == -1) {&#10;                build_components_dfs(i, components_count++);&#10;            }&#10;        }&#10;    }&#10;&#10;    void build_condensation() {&#10;        condensation = graph&lt;int&gt;(components_count);&#10;        vec&lt;set&lt;int&gt;&gt; edges(components_count);&#10;        for (int i = 0; i &lt; len(g); ++i) {&#10;            for (auto &amp;to: g[i]) {&#10;                if (components[i] != components[to.first]) {&#10;                    edges[components[i]].insert(components[to.first]);&#10;                }&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; components_count; ++i) {&#10;            for (auto &amp;to: edges[i]) {&#10;                condensation[i].push_back(to);&#10;            }&#10;        }&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".option" value="template&lt;typename T&gt;&#10;struct option {&#10;    T val;&#10;    bool is_empty;&#10;&#10;    option() : is_empty(true) {}&#10;&#10;    option(T val) : val(val), is_empty(false) {}&#10;&#10;    option&lt;T&gt; &amp;operator=(T _val) {&#10;        this-&gt;val = _val;&#10;        this-&gt;is_empty = false;&#10;        return *this;&#10;    }&#10;&#10;    option&lt;T&gt; &amp;operator=(option&lt;T&gt; _val) {&#10;        this-&gt;val = _val;&#10;        this-&gt;is_empty = false;&#10;        return *this;&#10;    }&#10;&#10;    T operator*() {&#10;        if (is_empty) {&#10;            throw runtime_error(&quot;option is none&quot;);&#10;        }&#10;        return val;&#10;    }&#10;&#10;&#10;    bool operator==(option&lt;T&gt; _val) {&#10;        if (is_empty and _val.is_empty) {&#10;            return true;&#10;        }&#10;        if (is_empty or _val.is_empty) {&#10;            return false;&#10;        }&#10;        return val == _val.val;&#10;    }&#10;&#10;    bool operator!=(option&lt;T&gt; _val) {&#10;        return !(*this == _val);&#10;    }&#10;&#10;    bool is_some() {&#10;        return !is_empty;&#10;    }&#10;&#10;    bool is_none() {&#10;        return is_empty;&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".st.add-max" value="struct SegmentTree {&#10;private:&#10;    int n{};&#10;    vec&lt;int&gt; t;&#10;    vec&lt;int&gt; push_t;&#10;&#10;    void init(int _n) {&#10;        n = _n;&#10;        t.clear();&#10;        push_t.clear();&#10;        t.resize(4 * n, 0);&#10;        push_t.resize(4 * n, 0);&#10;    }&#10;&#10;    void push(int v, int tl, int tr) {&#10;        if (push_t[v] == 0) return;&#10;        if (tl != tr) {&#10;            push_t[2 * v] += push_t[v];&#10;            t[2 * v] += push_t[v];&#10;            push_t[2 * v + 1] += push_t[v];&#10;            t[2 * v + 1] += push_t[v];&#10;        }&#10;        push_t[v] = 0;&#10;    }&#10;&#10;&#10;    int get(int v, int tl, int tr, int l, int r) {&#10;        push(v, tl, tr);&#10;        int tm = (tl + tr) / 2;&#10;        if (tl == l &amp;&amp; tr == r) {&#10;            return t[v];&#10;        }&#10;        if (l &gt; tm) {&#10;            return get(2 * v + 1, tm + 1, tr, l, r);&#10;        }&#10;        if (r &lt;= tm) {&#10;            return get(2 * v, tl, tm, l, r);&#10;        }&#10;        return max(get(2 * v, tl, tm, l, tm), get(2 * v + 1, tm + 1, tr, tm + 1, r));&#10;    }&#10;&#10;    void update(int v, int tl, int tr, int l, int r, int val) {&#10;        push(v, tl, tr);&#10;        if (tl == l &amp;&amp; tr == r) {&#10;            push_t[v] += val;&#10;            t[v] += val;&#10;            push(v, tl, tr);&#10;            return;&#10;        }&#10;        int tm = (tl + tr) / 2;&#10;        if (l &gt; tm) {&#10;            update(2 * v + 1, tm + 1, tr, l, r, val);&#10;        } elif (r &lt;= tm) {&#10;            update(2 * v, tl, tm, l, r, val);&#10;        } else {&#10;            update(2 * v, tl, tm, l, tm, val);&#10;            update(2 * v + 1, tm + 1, tr, tm + 1, r, val);&#10;        }&#10;        t[v] = max(t[2 * v], t[2 * v + 1]);&#10;    }&#10;&#10;public:&#10;    SegmentTree(int _n) {&#10;        init(_n);&#10;    }&#10;&#10;    void reset(int _n) {&#10;        init(_n);&#10;    }&#10;&#10;    int get(int l, int r) {&#10;        return get(1, 0, n - 1, l, r);&#10;    }&#10;&#10;    int operator()(int l, int r) {&#10;        return get(l, r);&#10;    }&#10;&#10;    void update(int l, int r, int val) {&#10;        update(1, 0, n - 1, l, r, val);&#10;    }&#10;&#10;    void set(int x, int val) {&#10;        int cur = get(x, x);&#10;        update(x, x, val - cur);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".blockcuttree" value="struct BlockCutTree {&#10;public:&#10;    graph&lt;int&gt; g;&#10;    int timer, n;&#10;    vec&lt;int&gt; fup, tin;&#10;    vec&lt;bool&gt; used;&#10;    vec&lt;vec&lt;pII&gt;&gt; edge_components;&#10;    vec&lt;int&gt; components;&#10;    vec&lt;int&gt; cut_points;&#10;    vec&lt;bool&gt; is_cut_point;&#10;    stack&lt;pII&gt; buffer;&#10;    int component_cnt;&#10;&#10;    void dfs(int v, int p) {&#10;        tin[v] = fup[v] = timer++;&#10;        used[v] = true;&#10;        bool is_cut = false;&#10;        int child_cnt = 0;&#10;        for (auto u: g[v]) {&#10;            if (u == p)&#10;                continue;&#10;            if (!used[u]) {&#10;                child_cnt++;&#10;                buffer.emplace(v, u);&#10;                dfs(u, v);&#10;                if (fup[u] &gt;= tin[v]) {&#10;                    is_cut = true;&#10;                    edge_components.emplace_back();&#10;                    while (true) {&#10;                        auto [a, b] = buffer.top();&#10;                        buffer.pop();&#10;                        edge_components.back().emplace_back(a, b);&#10;                        if (a == v &amp;&amp; b == u) {&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;                chmin(fup[v], fup[u]);&#10;            } else {&#10;                chmin(fup[v], tin[u]);&#10;                if (tin[u] &lt; tin[v]) {&#10;                    buffer.emplace(v, u);&#10;                }&#10;            }&#10;        }&#10;        if (p == -1) {&#10;            is_cut = child_cnt &gt; 1;&#10;        }&#10;        if (is_cut) {&#10;            cut_points.push_back(v);&#10;            is_cut_point[v] = true;&#10;        }&#10;    }&#10;&#10;    void build_components() {&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            if (!used[i]) {&#10;                dfs(i, -1);&#10;            }&#10;        }&#10;        components = vec&lt;int&gt;(n);&#10;        component_cnt = 0;&#10;        for (auto cp: cut_points) {&#10;            components[cp] = component_cnt++;&#10;        }&#10;        for (auto &amp;ec: edge_components) {&#10;            bool was = false;&#10;            for (auto [u, v]: ec) {&#10;                if (!is_cut_point[u])&#10;                    components[u] = component_cnt, was = true;&#10;                if (!is_cut_point[v])&#10;                    components[v] = component_cnt, was = true;&#10;            }&#10;//            if (was)&#10;            component_cnt++;&#10;        }&#10;    }&#10;&#10;    graph&lt;int&gt; bc_tree;&#10;&#10;    void build_tree() {&#10;        bc_tree = graph&lt;int&gt;(component_cnt);&#10;        vec&lt;set&lt;int&gt;&gt; bc_tree_edges(component_cnt);&#10;        int id = len(cut_points) - 1;&#10;        for (const auto &amp;eg: edge_components) {&#10;            id++;&#10;            for (auto [u, v]: eg) {&#10;                if (is_cut_point[u]) {&#10;                    bc_tree_edges[components[u]].insert(id);&#10;                    bc_tree_edges[id].insert(components[u]);&#10;                }&#10;                if (is_cut_point[v]) {&#10;                    bc_tree_edges[id].insert(components[v]);&#10;                    bc_tree_edges[components[v]].insert(id);&#10;                }&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; component_cnt; ++i) {&#10;            for (auto to: bc_tree_edges[i]) {&#10;                bc_tree[i].push_back(to);&#10;            }&#10;        }&#10;    }&#10;&#10;    BlockCutTree(graph&lt;int&gt; &amp;g) : g(g) {&#10;        n = len(g);&#10;        timer = 0;&#10;        fup = tin = vec&lt;int&gt;(n);&#10;        used = vec&lt;bool&gt;(n);&#10;        is_cut_point = vec&lt;bool&gt;(n);&#10;    }&#10;&#10;    void print() {&#10;        set&lt;pII&gt; edges;&#10;        for (int i = 0; i &lt; component_cnt; ++i) {&#10;            for (auto to: bc_tree[i]) {&#10;                if (edges.count({i, to}) or edges.count({to, i})) {&#10;                    continue;&#10;                }&#10;                edges.emplace(i, to);&#10;            }&#10;        }&#10;        cout &lt;&lt; len(edges) &lt;&lt; endl;&#10;        for (auto [u, v]: edges) {&#10;            cout &lt;&lt; u + 1 &lt;&lt; &quot; &quot; &lt;&lt; v + 1 &lt;&lt; endl;&#10;        }&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".splay_tree" value="template&lt;typename T&gt;&#10;struct splay_tree {&#10;public:&#10;&#10;    struct node {&#10;        T val;&#10;        node *l, *r, *p;&#10;        int cnt;&#10;&#10;        node(T val) : val(val), l(nullptr), r(nullptr), p(nullptr), cnt(1) {}&#10;    };&#10;&#10;    class iterator {&#10;    private:&#10;        node *_next(node *x) {&#10;            if (x == nullptr) return nullptr;&#10;            if (x-&gt;r != nullptr) {&#10;                auto tcur = x-&gt;r;&#10;                while (tcur-&gt;l) {&#10;                    tcur = tcur-&gt;l;&#10;                }&#10;                return tcur;&#10;            } else {&#10;                auto tcur = x;&#10;                while (tcur-&gt;p &amp;&amp; tcur-&gt;p-&gt;r == tcur) {&#10;                    tcur = tcur-&gt;p;&#10;                }&#10;                return tcur-&gt;p;&#10;            }&#10;        }&#10;&#10;        node *_prev(node *x) {&#10;            if (x == nullptr) return nullptr;&#10;            if (x-&gt;l != nullptr) {&#10;                auto tcur = x-&gt;l;&#10;                while (tcur-&gt;r) {&#10;                    tcur = tcur-&gt;r;&#10;                }&#10;                return tcur;&#10;            } else {&#10;                auto tcur = x;&#10;                while (tcur-&gt;p &amp;&amp; tcur-&gt;p-&gt;l == tcur) {&#10;                    tcur = tcur-&gt;p;&#10;                }&#10;                return tcur-&gt;p;&#10;            }&#10;        }&#10;&#10;    public:&#10;        node *cur;&#10;&#10;        iterator(node *cur) : cur(cur) {}&#10;&#10;        T operator*() {&#10;            return cur-&gt;val;&#10;        }&#10;&#10;        iterator operator++() {&#10;            cur = _next(cur);&#10;            return *this;&#10;        }&#10;&#10;        iterator operator--() {&#10;            cur = _prev(cur);&#10;            return *this;&#10;        }&#10;&#10;        bool operator==(const iterator &amp;other) const {&#10;            return cur == other.cur;&#10;        }&#10;&#10;        bool operator!=(const iterator &amp;other) const {&#10;            return cur != other.cur;&#10;        }&#10;&#10;    };&#10;&#10;    node *root;&#10;&#10;    splay_tree() : root(nullptr) {}&#10;&#10;    splay_tree(node *root) : root(root) {}&#10;&#10;    iterator find(T val) {&#10;        node *cur = root;&#10;        while (cur) {&#10;            if (cur-&gt;val == val) {&#10;                splay(cur);&#10;                return cur;&#10;            } else if (cur-&gt;val &lt; val) {&#10;                if (cur-&gt;r == nullptr)&#10;                    break;&#10;                cur = cur-&gt;r;&#10;            } else {&#10;                if (cur-&gt;l == nullptr)&#10;                    break;&#10;                cur = cur-&gt;l;&#10;            }&#10;        }&#10;        splay(cur);&#10;        return nullptr;&#10;    }&#10;&#10;    void rotate(node *x) {&#10;        if (x-&gt;p == nullptr) return;&#10;        auto p = x-&gt;p;&#10;        auto g = p-&gt;p;&#10;        x-&gt;p = g;&#10;        if (g != nullptr) {&#10;            if (g-&gt;l == p) g-&gt;l = x;&#10;            else g-&gt;r = x;&#10;        }&#10;        if (p-&gt;l == x) {&#10;            //auto a = x-&gt;l;&#10;            auto b = x-&gt;r;&#10;            //auto c = p-&gt;r;&#10;            //x-&gt;l = a;&#10;            x-&gt;r = p;&#10;            if (p)&#10;                p-&gt;p = x;&#10;            p-&gt;l = b;&#10;            if (b)&#10;                b-&gt;p = p;&#10;            //p-&gt;r = c;&#10;        } else {&#10;            auto a = x-&gt;l;&#10;            //auto b = x-&gt;r;&#10;            //auto c = p-&gt;l;&#10;            //x-&gt;r = b;&#10;            x-&gt;l = p;&#10;            if (p)&#10;                p-&gt;p = x;&#10;            //p-&gt;l = c;&#10;            p-&gt;r = a;&#10;            if (a)&#10;                a-&gt;p = p;&#10;        }&#10;    }&#10;&#10;    void splay(node *x) {&#10;        if (x-&gt;p == nullptr) return;&#10;        auto p = x-&gt;p;&#10;        if (p-&gt;p == nullptr) {&#10;            rotate(x);&#10;            return;&#10;        }&#10;        auto g = p-&gt;p;&#10;        if ((g-&gt;l == p &amp;&amp; p-&gt;l == x) || (g-&gt;r == p &amp;&amp; p-&gt;r == x)) {&#10;            rotate(p);&#10;            rotate(x);&#10;        } else {&#10;            rotate(x);&#10;            rotate(x);&#10;        }&#10;        splay(x);&#10;    }&#10;&#10;    iterator insert(T val) {&#10;        if (root == nullptr) return root = new node(val);&#10;        node *cur = root;&#10;        while (cur) {&#10;            if (cur-&gt;val == val) {&#10;                cur-&gt;cnt++;&#10;                splay(cur);&#10;                return root = cur;&#10;            } else if (cur-&gt;val &lt; val) {&#10;                if (cur-&gt;r == nullptr) {&#10;                    cur-&gt;r = new node(val);&#10;                    cur-&gt;r-&gt;p = cur;&#10;                    auto res = cur-&gt;r;&#10;                    splay(res);&#10;                    return root = res;&#10;                } else {&#10;                    cur = cur-&gt;r;&#10;                }&#10;            } else {&#10;                if (cur-&gt;l == nullptr) {&#10;                    cur-&gt;l = new node(val);&#10;                    cur-&gt;l-&gt;p = cur;&#10;                    auto res = cur-&gt;l;&#10;                    splay(res);&#10;                    return root = res;&#10;                } else {&#10;                    cur = cur-&gt;l;&#10;                }&#10;            }&#10;        }&#10;        return nullptr;&#10;    }&#10;&#10;    void remove(iterator it) {&#10;        auto x = it.cur;&#10;        if (x == nullptr) return;&#10;        splay(x);&#10;        auto l = x-&gt;l;&#10;        auto r = x-&gt;r;&#10;        disconnect(l);&#10;        disconnect(r);&#10;        delete x;&#10;        merge(l, r);&#10;    }&#10;&#10;    void disconnect(node *x) {&#10;        if (x == nullptr) return;&#10;        if (x-&gt;p == nullptr) return;&#10;        auto p = x-&gt;p;&#10;        if (p-&gt;l == x) p-&gt;l = nullptr;&#10;        else p-&gt;r = nullptr;&#10;        x-&gt;p = nullptr;&#10;    }&#10;&#10;//    val goes to left subtree&#10;    pair&lt;splay_tree&lt;T&gt;, splay_tree&lt;T&gt;&gt; split(node *x) {&#10;        if (x == nullptr) return {nullptr, nullptr};&#10;        splay(x);&#10;        auto r = x-&gt;r;&#10;        disconnect(r);&#10;        return {splay_tree&lt;T&gt;(x), splay_tree&lt;T&gt;(r)};&#10;    }&#10;&#10;    void merge(splay_tree&lt;T&gt; &amp;lt, splay_tree&lt;T&gt; &amp;rt) {&#10;        if (lt == nullptr) return;&#10;        if (rt == nullptr) return;&#10;        auto l = lt.root;&#10;        auto r = rt.root;&#10;        auto cur = l;&#10;        while (cur-&gt;r) {&#10;            cur = cur-&gt;r;&#10;        }&#10;        splay(cur);&#10;        cur-&gt;r = r;&#10;        r-&gt;p = cur;&#10;    }&#10;&#10;&#10;    iterator begin() {&#10;        if (root == nullptr) return iterator(nullptr);&#10;        auto cur = root;&#10;        while (cur-&gt;l) {&#10;            cur = cur-&gt;l;&#10;        }&#10;        return iterator(cur);&#10;    }&#10;&#10;    iterator end() {&#10;        return iterator(nullptr);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".divisible" value="int divisible(int a, int b, int x) {&#10;//    returns a number of integers in range [a, b] that are divisible by x&#10;    if (a % x == 0) return (b - a) / x + 1;&#10;    return (b - (a - a % x)) / x;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".st.beats" value="struct SegmentTreeBeats {&#10;private:&#10;    struct Node {&#10;        int val;&#10;        int max1;&#10;        int max2;&#10;        int cnt_max1;&#10;&#10;&#10;        Node(int x) : val(x), max1(x), max2(-inf), cnt_max1(1) {}&#10;&#10;        Node() : val(0), max1(-inf), max2(-inf), cnt_max1(0) {}&#10;&#10;        Node(const Node &amp;a) = default;&#10;&#10;        Node(int x, int y, int z, int w) : val(x), max1(y), max2(z), cnt_max1(w) {}&#10;    };&#10;&#10;    int __n;&#10;    vec&lt;Node&gt; tree;&#10;&#10;    Node combine(const Node &amp;a, const Node &amp;b) {&#10;        Node res;&#10;        res.val = a.val + b.val;&#10;        if (a.max1 == b.max1) {&#10;            res.max1 = a.max1;&#10;            res.cnt_max1 = a.cnt_max1 + b.cnt_max1;&#10;            res.max2 = max(a.max2, b.max2);&#10;        } elif (a.max1 &lt; b.max1) {&#10;            res.max1 = b.max1;&#10;            res.cnt_max1 = b.cnt_max1;&#10;            res.max2 = max(a.max1, b.max2);&#10;        } else {&#10;            res.max1 = a.max1;&#10;            res.cnt_max1 = a.cnt_max1;&#10;            res.max2 = max(a.max2, b.max1);&#10;        }&#10;        return res;&#10;    }&#10;&#10;    void build(const vec&lt;int&gt; &amp;a, int v, int tl, int tr) {&#10;        if (tl == tr) {&#10;            tree[v] = Node(a[tl]);&#10;            return;&#10;        }&#10;        int tm = (tl + tr) / 2;&#10;        build(a, v * 2, tl, tm);&#10;        build(a, v * 2 + 1, tm + 1, tr);&#10;        tree[v] = combine(tree[v * 2], tree[v * 2 + 1]);&#10;    }&#10;&#10;    void build(const vec&lt;int&gt; &amp;a) {&#10;        build(a, 1, 0, len(a) - 1);&#10;    }&#10;&#10;&#10;    void update(int v, int new_max) {&#10;        if (tree[v].max1 &gt; new_max) {&#10;            tree[v].val -= (tree[v].max1 - new_max) * tree[v].cnt_max1;&#10;            tree[v].max1 = new_max;&#10;        }&#10;    }&#10;&#10;&#10;    void push(int v, int tl, int tr) {&#10;        if (tl != tr) {&#10;            update(v * 2, tree[v].max1);&#10;            update(v * 2 + 1, tree[v].max1);&#10;        }&#10;    }&#10;&#10;&#10;    bool break_condition(int v, int tl, int tr, int l, int r, int new_max) {&#10;        return tree[v].max1 &lt;= new_max or l &gt; r;&#10;    }&#10;&#10;    bool tag_condition(int v, int tl, int tr, int l, int r, int new_max) {&#10;        return l == tl and r == tr and tree[v].max2 &lt; new_max ;&#10;    }&#10;&#10;&#10;    void apply(int v, int tl, int tr, int l, int r, int new_max) {&#10;        if (break_condition(v, tl, tr, l, r, new_max))&#10;            return;&#10;        if (tag_condition(v, tl, tr, l, r, new_max)) {&#10;            update(v, new_max);&#10;            return;&#10;        }&#10;        push(v, tl, tr);&#10;        int tm = (tl + tr) / 2;&#10;        apply(v * 2, tl, tm, l, min(r, tm), new_max);&#10;        apply(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, new_max);&#10;        tree[v] = combine(tree[v * 2], tree[v * 2 + 1]);&#10;    }&#10;&#10;&#10;    Node get(int v, int tl, int tr, int l, int r) {&#10;        if (l &gt; r)&#10;            return {};&#10;        if (tl == l and tr == r)&#10;            return tree[v];&#10;        push(v, tl, tr);&#10;        int tm = (tl + tr) / 2;&#10;        return combine(get(v * 2, tl, tm, l, min(r, tm)), get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r));&#10;    }&#10;&#10;public:&#10;&#10;    SegmentTreeBeats(const vec&lt;int&gt; &amp;a) {&#10;        __n = len(a);&#10;        tree.resize(4 * len(a));&#10;        build(a);&#10;    }&#10;&#10;    Node get(int l, int r) {&#10;        return get(1, 0, __n - 1, l, r);&#10;    }&#10;&#10;    void apply(int l, int r, int mod_val) {&#10;        apply(1, 0, __n - 1, l, r, mod_val);&#10;    }&#10;&#10;&#10;    int get_sum(int l, int r) {&#10;        return get(l, r).val;&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".st.general" value="template&lt;typename T, typename P&gt;&#10;struct SegmentTree {&#10;private:&#10;    function&lt;T(const T &amp;, const T &amp;)&gt; comb;&#10;    function&lt;void(T &amp;, const P, int, int)&gt; apply_push;&#10;    function&lt;void(P &amp;, const P &amp;)&gt; merge_push;&#10;    function&lt;pair&lt;P, P&gt;(const P &amp;, int l, int r, int pos)&gt; split_push;&#10;    size_t n;&#10;    vec&lt;T&gt; tree;&#10;    vec&lt;optional&lt;P&gt;&gt; pushes;&#10;&#10;    void push(int v, int tl, int tr) {&#10;        if (!pushes[v].has_value())&#10;            return;&#10;        if (tl != tr) {&#10;            int tm = (tl + tr) / 2;&#10;            auto [l, r] = split_push(pushes[v].value(), tl, tr, tm);&#10;            apply_push(tree[2 * v], l, tl, tm);&#10;            apply_push(tree[2 * v + 1], r, tm + 1, tr);&#10;            if (pushes[2 * v].has_value())&#10;                merge_push(pushes[2 * v].value(), l);&#10;            else&#10;                pushes[2 * v] = l;&#10;            if (pushes[2 * v + 1].has_value())&#10;                merge_push(pushes[2 * v + 1].value(), r);&#10;            else&#10;                pushes[2 * v + 1] = r;&#10;        }&#10;&#10;        pushes[v] = nullopt;&#10;    }&#10;&#10;    void build(int v, int tl, int tr, const vec&lt;T&gt; &amp;a) {&#10;        if (tl == tr) {&#10;            tree[v] = a[tl];&#10;            return;&#10;        }&#10;        int tm = (tl + tr) / 2;&#10;        build(2 * v, tl, tm, a);&#10;        build(2 * v + 1, tm + 1, tr, a);&#10;        tree[v] = comb(tree[2 * v], tree[2 * v + 1]);&#10;    }&#10;&#10;    T get(int v, int tl, int tr, int l, int r) {&#10;        if (l &gt; r)&#10;            return T();&#10;        if (l == tl &amp;&amp; r == tr)&#10;            return tree[v];&#10;        push(v, tl, tr);&#10;        int tm = (tl + tr) / 2;&#10;        if (r &lt;= tm)&#10;            return get(2 * v, tl, tm, l, r);&#10;        if (l &gt; tm)&#10;            return get(2 * v + 1, tm + 1, tr, l, r);&#10;&#10;        return comb(get(2 * v, tl, tm, l, tm), get(2 * v + 1, tm + 1, tr, tm + 1, r));&#10;    }&#10;&#10;    void update(int v, int tl, int tr, int l, int r, const P &amp;val) {&#10;        if (l &gt; r)&#10;            return;&#10;        if (l == tl &amp;&amp; r == tr) {&#10;            apply_push(tree[v], val, l, r);&#10;            if (pushes[v].has_value())&#10;                merge_push(pushes[v].value(), val);&#10;            else&#10;                pushes[v] = val;&#10;            return;&#10;        }&#10;        push(v, tl, tr);&#10;        int tm = (tl + tr) / 2;&#10;        if (r &lt;= tm)&#10;            update(2 * v, tl, tm, l, r, val);&#10;        elif (l &gt; tm)update(2 * v + 1, tm + 1, tr, l, r, val);&#10;        else {&#10;            auto [lval, rval] = split_push(val, l, r, tm);&#10;            update(2 * v, tl, tm, l, tm, lval);&#10;            update(2 * v + 1, tm + 1, tr, tm + 1, r, rval);&#10;        }&#10;        tree[v] = comb(tree[2 * v], tree[2 * v + 1]);&#10;    }&#10;&#10;public:&#10;&#10;    SegmentTree(const function&lt;T(const T &amp;, const T &amp;)&gt; &amp;comb,&#10;                const function&lt;void(T &amp;, const P, int, int)&gt; &amp;apply_push,&#10;                const function&lt;void(P &amp;, const P &amp;)&gt; &amp;merge_push,&#10;                const function&lt;pair&lt;P, P&gt;(const P &amp;, int l, int r, int pos)&gt; &amp;split_push) :&#10;            comb(comb), apply_push(apply_push), merge_push(merge_push), split_push(split_push) {&#10;&#10;    }&#10;&#10;&#10;    T get(int l, int r) {&#10;        return get(1, 0, n - 1, l, r);&#10;    }&#10;&#10;    T operator[](int i) {&#10;        return get(i, i);&#10;    }&#10;&#10;    T operator()(int l, int r) {&#10;        return get(l, r);&#10;    }&#10;&#10;    void update(int l, int r, const P &amp;val) {&#10;        update(1, 0, n - 1, l, r, val);&#10;    }&#10;&#10;    void init(int _n, const vec&lt;T&gt; &amp;a) {&#10;        this-&gt;n = _n;&#10;        tree.resize(4 * n);&#10;        pushes.resize(4 * n);&#10;        build(1, 0, n - 1, a);&#10;    }&#10;&#10;    void init(const vec&lt;T&gt; &amp;a) {&#10;        init(len(a), a);&#10;    }&#10;&#10;    void init(int _n, const T &amp;val) {&#10;        init(_n, vect&lt;T&gt;(_n, val));&#10;    }&#10;&#10;    void reset() {&#10;        fill(all(tree), T());&#10;        fill(all(pushes), nullopt);&#10;    }&#10;&#10;};&#10;&#10;struct Push {&#10;    int d;&#10;    int start;&#10;};&#10;&#10;auto split_push = [](const Push &amp;p, int tl, int tr, int pos) {&#10;    return mp(Push{p.d, p.start}, Push{p.d, p.start + p.d * (pos - tl + 1)});&#10;};&#10;&#10;auto merge_push = [](Push &amp;p, const Push &amp;q) {&#10;    p.start += q.start;&#10;    p.d += q.d;&#10;};&#10;&#10;auto apply_push = [](int &amp;x, const Push &amp;p, int l, int r) {&#10;    x += (2 * p.start + (r - l) * p.d) * (r - l + 1) / 2;&#10;};&#10;auto comb = [](const int &amp;x, const int &amp;y) {&#10;    return x + y;&#10;};&#10;&#10;SegmentTree&lt;int, Push&gt; st(comb, apply_push, merge_push, split_push);&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".compr" value="void compress(vec&lt;int&gt; &amp;v) {&#10;    vec&lt;int&gt; u = v;&#10;    srt(u);&#10;    u.erase(unique(all(u)), u.end());&#10;    for (auto &amp;i: v) {&#10;        i = lower_bound(all(u), i) - u.begin();&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".divs" value="const int maxN = 2e6 + 7;&#10;int divisors[maxN];&#10;&#10;void init_divisors() {&#10;    memset(divisors, 0, sizeof(divisors));&#10;    for (int i = 2; i &lt; maxN; ++i) {&#10;        if (divisors[i] == 0) {&#10;            for (int j = i; j &lt; maxN; j += i) {&#10;                divisors[j] = i;&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;bool is_prime(int x) {&#10;    if (x &lt; 2) return false;&#10;    return divisors[x] == x;&#10;}&#10;&#10;vec&lt;int&gt; prime_divisors(int x) {&#10;    vec&lt;int&gt; res;&#10;    while (x &gt; 1) {&#10;        res.push_back(divisors[x]);&#10;        x /= divisors[x];&#10;    }&#10;    return res;&#10;}&#10;&#10;vec&lt;pII&gt; factorize(int x) {&#10;    vec&lt;pII&gt; res;&#10;    while (x &gt; 1) {&#10;        int p = divisors[x];&#10;        int cnt = 0;&#10;        while (x % p == 0) {&#10;            x /= p;&#10;            cnt++;&#10;        }&#10;        res.emplace_back(p, cnt);&#10;    }&#10;    return res;&#10;}&#10;&#10;vec&lt;int&gt; divisors_of(int x) {&#10;    auto f = factorize(x);&#10;    vec&lt;int&gt; res = {};&#10;    function&lt;void(int, int)&gt; dfs = [&amp;](int i, int cur) {&#10;        if (i == len(f)) {&#10;            res.push_back(cur);&#10;            return;&#10;        }&#10;        dfs(i + 1, cur);&#10;        for (int j = 0; j &lt; f[i].second; ++j) {&#10;            cur *= f[i].first;&#10;            dfs(i + 1, cur);&#10;        }&#10;    };&#10;    dfs(0, 1);&#10;    return res;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".fenvik3d" value="template&lt;typename T&gt;&#10;struct fenvik3d {&#10;    vec&lt;vec&lt;vec&lt;T&gt;&gt;&gt; fen;&#10;    int n, m, k;&#10;&#10;    void _add(int x, int y, int z, T val) {&#10;        for (int i = x; i &lt;= n; i += low_bit(i)) {&#10;            for (int j = y; j &lt;= m; j += low_bit(j)) {&#10;                for (int l = z; l &lt;= k; l += low_bit(l)) {&#10;                    fen[i][j][l] += val;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    T _get(int x, int y, int z) {&#10;        T res = 0;&#10;        for (int i = x; i &gt; 0; i -= low_bit(i)) {&#10;            for (int j = y; j &gt; 0; j -= low_bit(j)) {&#10;                for (int l = z; l &gt; 0; l -= low_bit(l)) {&#10;                    res += fen[i][j][l];&#10;                }&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;public:&#10;    fenvik3d(int n, int m, int k) : n(n), m(m), k(k) {&#10;        fen = vect(n + 1, m + 1, k + 1, 0);&#10;    }&#10;&#10;    void add(int x, int y, int z, T val) {&#10;        _add(x + 1, y + 1, z + 1, val);&#10;    }&#10;&#10;    T get(int x, int y, int z) {&#10;        if (x &lt; 0 || y &lt; 0 || z &lt; 0)&#10;            return 0;&#10;        return _get(x + 1, y + 1, z + 1);&#10;    }&#10;&#10;    T get(int x1, int y1, int z1, int x2, int y2, int z2) {&#10;        return get(x2, y2, z2) - get(x1 - 1, y2, z2) - get(x2, y1 - 1, z2) - get(x2, y2, z1 - 1) +&#10;               get(x1 - 1, y1 - 1, z2) + get(x1 - 1, y2, z1 - 1) + get(x2, y1 - 1, z1 - 1) -&#10;               get(x1 - 1, y1 - 1, z1 - 1);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>