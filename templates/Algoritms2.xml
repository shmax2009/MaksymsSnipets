<templateSet group="Algoritms">
  <template name=".STree" value="namespace Algorithms {&#10;&#10;    template&lt;typename T&gt;&#10;    class vertex {&#10;    public:&#10;        vertex&lt;T&gt; *left;&#10;        vertex&lt;T&gt; *right;&#10;        T val;&#10;&#10;        explicit vertex(const T &amp;_val = T()) : val(_val), left(NULL), right(NULL) {}&#10;&#10;        vertex(vertex&lt;T&gt; *_left, vertex&lt;T&gt; *_right, std::function&lt;T(T, T)&gt; &amp;merge) : left(_left), right(_right),&#10;                                                                                     val(T()) {&#10;            if (_left == NULL)&#10;                val = right-&gt;val;&#10;            else if (_right == NULL)val = left-&gt;val;&#10;            else&#10;                val = merge(right-&gt;val, left-&gt;val);&#10;        }&#10;    };&#10;&#10;    template&lt;typename T&gt;&#10;    class segment_tree {&#10;    private:&#10;        std::function&lt;T(T, T)&gt; merge;&#10;        T defaultValue = T();&#10;        std::vector&lt;T&gt; data;&#10;        std::vector&lt;vertex&lt;T&gt; *&gt; versions;&#10;        std::vector&lt;vertex&lt;T&gt; *&gt; vertexes;&#10;&#10;        vertex&lt;T&gt; *_build(int tl, int tr) {&#10;            if (tl == tr)&#10;                return new vertex&lt;T&gt;(data[tl]);&#10;            int tm = (tl + tr) / 2;&#10;            auto vertex = new Algorithms::vertex&lt;T&gt;(_build(tl, tm), _build(tm + 1, tr), merge);&#10;            vertexes.push_back(vertex);&#10;            return vertex;&#10;        }&#10;&#10;        T _get(vertex&lt;T&gt; *v, int tl, int tr, int l, int r) {&#10;            if (l &gt; r)&#10;                return defaultValue;&#10;            if (l == tl &amp;&amp; r == tr)&#10;                return v-&gt;val;&#10;            int tm = (tl + tr) / 2;&#10;            return merge(_get(v-&gt;left, tl, tm, l, std::min(r, tm)), _get(v-&gt;right, tm + 1, tr, std::max(l, tm + 1), r));&#10;        }&#10;&#10;        vertex&lt;T&gt; *_update(vertex&lt;T&gt; *t, int tl, int tr, int pos, T newVal) {&#10;            if (tl == tr) {&#10;                auto vertex = new Algorithms::vertex&lt;T&gt;(newVal);&#10;                vertexes.push_back(vertex);&#10;                return vertex;&#10;            }&#10;            int tm = (tl + tr) / 2;&#10;            if (pos &lt;= tm) {&#10;                auto vertex = new Algorithms::vertex&lt;T&gt;(_update(t-&gt;left, tl, tm, pos, newVal), t-&gt;right, merge);&#10;                vertexes.push_back(vertex);&#10;                return vertex;&#10;            } else {&#10;                auto vertex = new Algorithms::vertex&lt;T&gt;(t-&gt;left, _update(t-&gt;right, tm + 1, tr, pos, newVal), merge);&#10;                vertexes.push_back(vertex);&#10;                return vertex;&#10;            }&#10;        }&#10;&#10;        template&lt;class F&gt;&#10;        static F sum(F a, F b) {&#10;            return a + b;&#10;        }&#10;&#10;    public:&#10;        segment_tree() = default;&#10;&#10;        explicit segment_tree(std::vector&lt;T&gt; _data, std::function&lt;T(T, T)&gt; merge = sum&lt;T&gt;) : data(_data), merge(merge) {&#10;            versions.push_back(_build(0, data.size() - 1));&#10;        }&#10;&#10;        void update(size_t pos, T val) {&#10;            if (pos &gt;= data.size())&#10;                throw std::out_of_range(&quot;Error: index is out of range&quot;);&#10;            data[pos] = val;&#10;            versions.push_back(_update(versions[versions.size() - 1], 0, data.size() - 1, pos, val));&#10;        }&#10;&#10;        T get(int x, int y, int version = -1) {&#10;            if (x &gt; y)&#10;                std::swap(x, y);&#10;            if (x &gt;= data.size() || y &gt;= data.size())&#10;                throw std::out_of_range(&quot;Error: at least one of the bounds is out of range&quot;);&#10;            if (version &lt; -1 || version &gt;= (int) versions.size())&#10;                throw std::out_of_range(&quot;Error: bad version of tree&quot;);&#10;            if (version == -1)&#10;                version += versions.size();&#10;            vertex&lt;T&gt; *t = versions[version];&#10;            return _get(t, 0, data.size() - 1, x, y);&#10;        }&#10;    };&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".import" value="/*&#10; * powered by ANDRIY POPYK&#10; * in honor of MYSELF and SEGMENT DECOMPOSITION and N^(log(N)) and (Harry Potter and the Methods of Rationality) and Monkie D. Luffy&#10;*/&#10;#include &lt;bits/stdc++.h&gt;&#10;#include &lt;ext/pb_ds/assoc_container.hpp&gt;&#10;&#10;//#pragma GCC optimize(&quot;O3&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,fma&quot;)&#10;//#pragma GCC optimization (&quot;unroll-loops&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,sse,sse2,sse3,sse4,popcnt&quot;)&#10;&#10;using namespace std;&#10;using namespace __gnu_pbds;&#10;#define int long long&#10;#define float long double&#10;#define elif else if&#10;#define endl &quot;\n&quot;&#10;#define mod 1000000007&#10;#define pi acos(-1)&#10;#define eps 0.000000001&#10;#define inf 1000'000'000'000'000'000LL&#10;#define FIXED(a) cout &lt;&lt; fixed &lt;&lt; setprecision(a)&#10;#define all(x) x.begin(), x.end()&#10;#define rall(x) x.rbegin(), x.rend()&#10;#define time_init auto start = std::chrono::high_resolution_clock::now()&#10;#define time_report                                       \&#10;    auto end = std::chrono::high_resolution_clock::now(); \&#10;    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count() &lt;&lt; &quot; ms&quot; &lt;&lt; endl&#10;#define debug(x) \&#10;    { cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; }&#10;#define len(x) (int) x.size()&#10;#define sqr(x) ((x) * (x))&#10;#define cube(x) ((x) * (x) * (x))&#10;#define bit(x, i) (((x) &gt;&gt; (i)) &amp; 1)&#10;#define set_bit(x, i) ((x) | (1LL &lt;&lt; (i)))&#10;#define clear_bit(x, i) ((x) &amp; (~(1LL &lt;&lt; (i))))&#10;#define toggle_bit(x, i) ((x) ^ (1LL &lt;&lt; (i)))&#10;#define low_bit(x) ((x) &amp; (-(x)))&#10;#define count_bit(x) __builtin_popcountll(x)&#10;#define srt(x) sort(all(x))&#10;#define rsrt(x) sort(rall(x))&#10;#define mp make_pair&#10;#define maxel(x) (*max_element(all(x)))&#10;#define minel(x) (*min_element(all(x)))&#10;#define maxelpos(x) (max_element(all(x)) - x.begin())&#10;#define minelpos(x) (min_element(all(x)) - x.begin())&#10;#define sum(x) (accumulate(all(x), 0LL))&#10;#define product(x) (accumulate(all(x), 1LL, multiplies&lt;int&gt;()))&#10;#define gcd __gcd&#10;#define lcm(a, b) ((a) / gcd(a, b) * (b))&#10;#define rev(x) (reverse(all(x)))&#10;#define shift_left(x, k) (rotate(x.begin(), x.begin() + k, x.end()))&#10;#define shift_right(x, k) (rotate(x.rbegin(), x.rbegin() + k, x.rend()))&#10;#define is_sorted(x) (is_sorted_until(all(x)) == x.end())&#10;#define is_even(x) (((x) &amp;1) == 0)&#10;#define is_odd(x) (((x) &amp;1) == 1)&#10;#define pow2(x) (1LL &lt;&lt; (x))&#10;struct custom_hash {&#10;    static uint64_t splitmix64(uint64_t x) {&#10;        // http://xorshift.di.unimi.it/splitmix64.c&#10;        x += 0x9e3779b97f4a7c15;&#10;        x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;&#10;        x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;&#10;        return x ^ (x &gt;&gt; 31);&#10;    }&#10;&#10;    size_t operator()(uint64_t x) const {&#10;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();&#10;        return splitmix64(x + FIXED_RANDOM);&#10;    }&#10;};&#10;template&lt;typename T&gt;&#10;using min_heap = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using max_heap = priority_queue&lt;T, vector&lt;T&gt;, less&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_multiset = tree&lt;T, null_type, less_equal&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;template&lt;typename T&gt;&#10;using matrix = vector&lt;vector&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using graph = vector&lt;vector&lt;T&gt;&gt;;&#10;using hashmap = gp_hash_table&lt;int, int, custom_hash&gt;;&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; vect(int n, T val) {&#10;    return vector&lt;T&gt;(n, val);&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;T&gt;&gt; vect(int n, int m, T val) {&#10;    return vector&lt;vector&lt;T&gt;&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt; vect(int n, int m, int k, T val) {&#10;    return vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(n, vector&lt;vector&lt;T&gt;&gt;(m, vector&lt;T&gt;(k, val)));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt; vect(int n, int m, int k, int l, T val) {&#10;    return vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt;(n, vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(m, vector&lt;vector&lt;T&gt;&gt;(k, vector&lt;T&gt;(l, val))));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;matrix&lt;T&gt; new_matrix(int n, int m, T val) {&#10;    return matrix&lt;T&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;graph&lt;T&gt; new_graph(int n) {&#10;    return graph&lt;T&gt;(n);&#10;}&#10;template&lt;class T, class S&gt;&#10;inline bool chmax(T &amp;a, const S &amp;b) {&#10;    return (a &lt; b ? a = b, 1 : 0);&#10;}&#10;template&lt;class T, class S&gt;&#10;inline bool chmin(T &amp;a, const S &amp;b) {&#10;    return (a &gt; b ? a = b, 1 : 0);&#10;}&#10;&#10;using i8 = int8_t;&#10;using i16 = int16_t;&#10;using i32 = int32_t;&#10;using i64 = int64_t;&#10;using i128 = __int128_t;&#10;using u8 = uint8_t;&#10;using u16 = uint16_t;&#10;using u32 = uint32_t;&#10;using u64 = uint64_t;&#10;using u128 = __uint128_t;&#10;&#10;template&lt;typename T&gt;&#10;using vec = vector&lt;T&gt;;&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".sm" value="signed main(){&#10;ios_base::sync_with_stdio(false);&#10;cin.tie(nullptr);&#10;cout.tie(nullptr);&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".query" value="int q;&#10;cin&gt;&gt;q;&#10;while(q--)&#10;    $name$();" description="" toReformat="true" toShortenFQNames="true">
    <variable name="name" expression="variableOfType()" defaultValue="solve" alwaysStopAt="true" />
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".bfs" value="    queue&lt;$type$&gt; q;&#10;    vector&lt;bool&gt; used($size$);&#10;    q.push($start$);&#10;    int wave = 0;&#10;    while (!q.empty()) {&#10;        const size_t st = q.size();&#10;        for (size_t it = 0; it &lt; st; it++) {&#10;            auto cur = q.front();&#10;            q.pop();&#10;            &#10;//            generate nexts&#10;&#10;//            generate nexts&#10;        }&#10;        wave++;&#10;    }" description="" toReformat="false" toShortenFQNames="true">
    <variable name="type" expression="" defaultValue="int" alwaysStopAt="true" />
    <variable name="size" expression="variableForIteration()" defaultValue="" alwaysStopAt="true" />
    <variable name="start" expression="variableForIteration()" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".vs" value="void solve(){&#10;    int n;&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".alphabet" value="&quot;abcdefghijklmnopqrstuvwxyz&quot;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".dsu" value="struct DSU {&#10;public:&#10;    DSU() : _n(0) {}&#10;    explicit DSU(int n) : _n(n), parent_or_size(n, -1) {}&#10;&#10;    int unite(int a, int b) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        assert(0 &lt;= b &amp;&amp; b &lt; _n);&#10;        int x = leader(a), y = leader(b);&#10;        if (x == y) return x;&#10;        if (-parent_or_size[x] &lt; -parent_or_size[y]) std::swap(x, y);&#10;        parent_or_size[x] += parent_or_size[y];&#10;        parent_or_size[y] = x;&#10;        return x;&#10;    }&#10;&#10;    bool one(int a, int b) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        assert(0 &lt;= b &amp;&amp; b &lt; _n);&#10;        return leader(a) == leader(b);&#10;    }&#10;&#10;    int leader(int a) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        if (parent_or_size[a] &lt; 0) return a;&#10;        return parent_or_size[a] = leader(parent_or_size[a]);&#10;    }&#10;&#10;    int size(int a) {&#10;        assert(0 &lt;= a &amp;&amp; a &lt; _n);&#10;        return -parent_or_size[leader(a)];&#10;    }&#10;&#10;    std::vector&lt;std::vector&lt;int&gt;&gt; groups() {&#10;        std::vector&lt;int&gt; leader_buf(_n), group_size(_n);&#10;        for (int i = 0; i &lt; _n; i++) {&#10;            leader_buf[i] = leader(i);&#10;            group_size[leader_buf[i]]++;&#10;        }&#10;        std::vector&lt;std::vector&lt;int&gt;&gt; result(_n);&#10;        for (int i = 0; i &lt; _n; i++) {&#10;            result[i].reserve(group_size[i]);&#10;        }&#10;        for (int i = 0; i &lt; _n; i++) {&#10;            result[leader_buf[i]].push_back(i);&#10;        }&#10;        result.erase(&#10;                std::remove_if(result.begin(), result.end(),&#10;                               [&amp;](const std::vector&lt;int&gt; &amp;v) { return v.empty(); }),&#10;                result.end());&#10;        return result;&#10;    }&#10;&#10;private:&#10;    int _n;&#10;    // root node: -1 * component size&#10;    // otherwise: parent&#10;    std::vector&lt;int&gt; parent_or_size;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".binOp" value="int binMult(int a, int b, int m) {&#10;    if (a == 0 or b == 0)&#10;        return 0;&#10;    if (a == 1)&#10;        return b;&#10;    if (b == 1)&#10;        return a;&#10;    if (a &lt; b)&#10;        swap(a, b);&#10;    if (b % 2 == 0) {&#10;        int f = binMult(a, b / 2, m);&#10;        f %= m;&#10;        f += f;&#10;        f %= m;&#10;        return f;&#10;    } else {&#10;        return (binMult(a, (b - 1), m) % m + a) % m;&#10;    }&#10;}&#10;&#10;int binPow(int a, int b, int m) {&#10;    if (b == 0)&#10;        return 1;&#10;    if (b == 1)&#10;        return a;&#10;    if (b % 2 == 0) {&#10;        int f = binPow(a, b / 2, m);&#10;        f %= m;&#10;        f = binMult(f, f, m);&#10;        f %= m;&#10;        return f;&#10;    } else {&#10;        return binMult(binPow(a, (b - 1), m) % m, a, m) % m;&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".crt" value="// @param b `1 &lt;= b`&#10;// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 &lt;= x &lt; b/g&#10;constexpr std::pair&lt;long long, long long&gt; inv_gcd(long long a, long long b) {&#10;    a = safe_mod(a, b);&#10;    if (a == 0) return {b, 0};&#10;&#10;    // Contracts:&#10;    // [1] s - m0 * a = 0 (mod b)&#10;    // [2] t - m1 * a = 0 (mod b)&#10;    // [3] s * |m1| + t * |m0| &lt;= b&#10;    long long s = b, t = a;&#10;    long long m0 = 0, m1 = 1;&#10;&#10;    while (t) {&#10;        long long u = s / t;&#10;        s -= t * u;&#10;        m0 -= m1 * u;  // |m1 * u| &lt;= |m1| * s &lt;= b&#10;&#10;        // [3]:&#10;        // (s - t * u) * |m1| + t * |m0 - m1 * u|&#10;        // &lt;= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)&#10;        // = s * |m1| + t * |m0| &lt;= b&#10;&#10;        auto tmp = s;&#10;        s = t;&#10;        t = tmp;&#10;        tmp = m0;&#10;        m0 = m1;&#10;        m1 = tmp;&#10;    }&#10;    // by [3]: |m0| &lt;= b/g&#10;    // by g != b: |m0| &lt; b/g&#10;    if (m0 &lt; 0) m0 += b / s;&#10;    return {s, m0};&#10;}&#10;&#10;pair&lt;int, int&gt; crt(const std::vector&lt;long long&gt; &amp;r, const std::vector&lt;long long&gt; &amp;m) {&#10;    assert(r.size() == m.size());&#10;    int n = (int) (r.size());&#10;    int r0 = 0, m0 = 1;&#10;    for (int i = 0; i &lt; n; i++) {&#10;        assert(1 &lt;= m[i]);&#10;        long long r1 = safe_mod(r[i], m[i]), m1 = m[i];&#10;        if (m0 &lt; m1) {&#10;            std::swap(r0, r1);&#10;            std::swap(m0, m1);&#10;        }&#10;        if (m0 % m1 == 0) {&#10;            if (r0 % m1 != r1) return {0, 0};&#10;            continue;&#10;        }&#10;        // assume: m0 &gt; m1, lcm(m0, m1) &gt;= 2 * max(m0, m1)&#10;&#10;        // (r0, m0), (r1, m1) -&gt; (r2, m2 = lcm(m0, m1));&#10;        // r2 % m0 = r0&#10;        // r2 % m1 = r1&#10;        // -&gt; (r0 + x*m0) % m1 = r1&#10;        // -&gt; x*u0*g = r1-r0 (mod u1*g) (u0*g = m0, u1*g = m1)&#10;        // -&gt; x = (r1 - r0) / g * inv(u0) (mod u1)&#10;&#10;        // im = inv(u0) (mod u1) (0 &lt;= im &lt; u1)&#10;        long long g, im;&#10;        std::tie(g, im) = inv_gcd(m0, m1);&#10;&#10;        long long u1 = (m1 / g);&#10;        // |r1 - r0| &lt; (m0 + m1) &lt;= lcm(m0, m1)&#10;        if ((r1 - r0) % g) return {0, 0};&#10;&#10;        // u1 * u1 &lt;= m1 * m1 / g / g &lt;= m0 * m1 / g = lcm(m0, m1)&#10;        long long x = (r1 - r0) / g % u1 * im % u1;&#10;&#10;        // |r0| + |m0 * x|&#10;        // &lt; m0 + m0 * (u1 - 1)&#10;        // = m0 + m0 * m1 / g - m0&#10;        // = lcm(m0, m1)&#10;        r0 += x * m0;&#10;        m0 *= u1;  // -&gt; lcm(m0, m1)&#10;        if (r0 &lt; 0) r0 += m0;&#10;    }&#10;    return {r0, m0};&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".int_sqrt" value="int int_sqrt(int x) {&#10;    long long ans = 0;&#10;    for (int k = 1LL &lt;&lt; 30; k != 0; k /= 2) {&#10;        if ((ans + k) * (ans + k) &lt;= x) {&#10;            ans += k;&#10;        }&#10;    }&#10;    return ans;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".phi" value="int phi (int n) {&#10;&#9;int result = n;&#10;&#9;for (int i=2; i*i&lt;=n; ++i)&#10;&#9;&#9;if (n % i == 0) {&#10;&#9;&#9;&#9;while (n % i == 0)&#10;&#9;&#9;&#9;&#9;n /= i;&#10;&#9;&#9;&#9;result -= result / i;&#10;&#9;&#9;}&#10;&#9;if (n &gt; 1)&#10;&#9;&#9;result -= result / n;&#10;&#9;return result;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="c" value="true" />
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".sieve" value="class EratosthenesSieve {&#10;public:&#10;    vector&lt;bool&gt; sieve;&#10;    vector&lt;int&gt; primes;&#10;&#10;    EratosthenesSieve(int N = 1000000) {&#10;        sieve.resize((int) N, true);&#10;        sieve[0] = sieve[1] = false;&#10;        for (int i = 2; i &lt; (int) N; i++) {&#10;            if (sieve[i]) {&#10;                primes.push_back((int) i);&#10;                for (int j = i + i; j &lt; (int) N; j += i) {&#10;                    sieve[j] = false;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    bool isPrime(int n) {&#10;        if (n &gt;= sieve.size()) {&#10;            throw exception();&#10;        }&#10;        return sieve[n];&#10;    }&#10;};&#10;&#10;EratosthenesSieve sieve(1000000);" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".printer" value="template&lt;typename T, typename U&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair&lt;T, U&gt; &amp;p) {&#10;    os &lt;&lt; &quot;(&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;)&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;v) {&#10;    os &lt;&lt; &quot;{&quot;;&#10;    for (int i = 0; i &lt; v.size(); ++i) {&#10;        if (i) os &lt;&lt; &quot;, &quot;;&#10;        os &lt;&lt; v[i];&#10;    }&#10;    os &lt;&lt; &quot;}&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;typename T&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const set&lt;T&gt; &amp;v) {&#10;    os &lt;&lt; &quot;[&quot;;&#10;    for (auto it = v.begin(); it != v.end(); ++it) {&#10;        if (it != v.begin()) os &lt;&lt; &quot;, &quot;;&#10;        os &lt;&lt; *it;&#10;    }&#10;    os &lt;&lt; &quot;]&quot;;&#10;    return os;&#10;}&#10;&#10;template&lt;typename T, typename U&gt;&#10;ostream &amp;operator&lt;&lt;(ostream &amp;os, const map&lt;T, U&gt; &amp;v) {&#10;    os &lt;&lt; &quot;[&quot;;&#10;    for (auto it = v.begin(); it != v.end(); ++it) {&#10;        if (it != v.begin()) os &lt;&lt; &quot;, &quot;;&#10;        os &lt;&lt; it-&gt;first &lt;&lt; &quot; = &quot; &lt;&lt; it-&gt;second;&#10;    }&#10;    os &lt;&lt; &quot;]&quot;;&#10;    return os;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".Fenvik" value="class Fenvik {&#10;&#10;    int p(int x) {&#10;        return x &amp; (x + 1);&#10;    }&#10;&#10;    vector&lt;int&gt; f;&#10;&#10;    int sum(int r) {&#10;        int id = r;&#10;        int ans = 0;&#10;        while (id &gt;= 0) {&#10;            ans += f[id];&#10;            id = p(id) - 1;&#10;        }&#10;        return ans;&#10;    }&#10;&#10;&#10;public:&#10;    Fenvik(const vector&lt;int&gt; &amp;a) {&#10;        f.resize(a.size());&#10;        vector&lt;int&gt; pref = a;&#10;        for (int i = 1; i &lt; a.size(); ++i) {&#10;            pref[i] += pref[i - 1];&#10;        }&#10;        for (int i = 0; i &lt; a.size(); ++i) {&#10;            if (p(i) - 1 &lt; 0)&#10;                f[i] = pref[i];&#10;            else&#10;                f[i] = pref[i] - pref[p(i) - 1];&#10;        }&#10;    }&#10;&#10;    int get(int l, int r) {&#10;        if (l == 0)&#10;            return sum(r);&#10;&#10;        return sum(r) - sum(l - 1);&#10;    }&#10;&#10;    void add(int i, int v) {&#10;        int cur = i;&#10;        while (cur &lt; f.size()) {&#10;            f[cur] += v;&#10;            cur |= cur + 1;&#10;        }&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".median_finder" value="/**&#10; * @brief  A data structure that allows you to find the median in O(log(n)) time and O(n) memory&#10; * @author maksym&#10; * @date   2023-16-05&#10; * @note   You can add and delete elements from this structure&#10; * @note   You can get median in O(1) time&#10; * @note   If the size of the structure is even, then the median will be the pair of elements in the middle&#10; * @note   If the size of the structure is odd, then the median will be the middle element&#10; * @note   If the size of the structure is 0, then the median will be undefined&#10; * @param  T The type of elements in the structure&#10; * @param  Compare The type of comparator for elements in the structure&#10; */&#10;&#10;template&lt;typename T, typename Compare = less&lt;T&gt;&gt;&#10;class median_finder {&#10;&#10;    template&lt;typename Comp&gt;&#10;    class reverse_compare {&#10;    public:&#10;        Comp comp;&#10;&#10;        bool operator()(const T &amp;a, const T &amp;b) const {&#10;            return comp(b, a);&#10;        }&#10;    };&#10;&#10;private:&#10;    multiset&lt;T, Compare&gt; r;&#10;    multiset&lt;T, reverse_compare&lt;Compare&gt;&gt; l;&#10;    int sz = 0;&#10;&#10;    void balance() {&#10;        while (l.size() &gt; r.size()) {&#10;            r.insert(*l.begin());&#10;            l.erase(l.begin());&#10;        }&#10;        while (r.size() &gt; l.size() + 1) {&#10;            l.insert(*r.begin());&#10;            r.erase(r.begin());&#10;        }&#10;&#10;    }&#10;&#10;public:&#10;    void insert(T x) {&#10;        if (sz == 0) {&#10;            r.insert(x);&#10;        } else if (sz == 1) {&#10;            if (Compare()(x, *r.begin())) {&#10;                l.insert(x);&#10;            } else {&#10;                l.insert(*r.begin());&#10;                r.erase(r.begin());&#10;                r.insert(x);&#10;            }&#10;        } else {&#10;            if (Compare()(x, *r.begin())) {&#10;                l.insert(x);&#10;            } else {&#10;                r.insert(x);&#10;            }&#10;        }&#10;        sz++;&#10;        balance();&#10;    }&#10;&#10;    void erase(T x) {&#10;        if (r.find(x) != r.end()) {&#10;            r.erase(r.find(x));&#10;        } else {&#10;            l.erase(l.find(x));&#10;        }&#10;        sz--;&#10;        balance();&#10;    }&#10;&#10;    pair&lt;T, T&gt; getMedian() {&#10;        if (sz % 2 == 0) {&#10;            return {*l.begin(), *r.begin()};&#10;        } else {&#10;            return {*r.begin(), *r.begin()};&#10;        }&#10;    }&#10;&#10;    vector&lt;T&gt; getSorted() {&#10;        vector&lt;T&gt; ans;&#10;        for (auto it = l.rbegin(); it != l.rend(); it++) {&#10;            ans.push_back(*it);&#10;        }&#10;        for (auto it: r) {&#10;            ans.push_back(it);&#10;        }&#10;        return ans;&#10;    }&#10;&#10;&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".mo" value="&#10;struct query {&#10;    int l, r, id;&#10;};&#10;&#10;template&lt;typename T, typename U = T&gt;&#10;interface MoDataStructure {&#10;    virtual void add(T x, bool start) = 0;&#10;&#10;    virtual void remove(T x, bool start) = 0;&#10;&#10;    virtual U get() = 0;&#10;};&#10;&#10;template&lt;typename T, typename U = T&gt;&#10;class Mo {&#10;private:&#10;    vector&lt;query&gt; queries;&#10;    int block_size;&#10;    int n;&#10;    int q;&#10;    vector&lt;T&gt; v;&#10;&#10;public:&#10;    Mo(vector&lt;T&gt; &amp;v, vector&lt;query&gt; &amp;queries) {&#10;        this-&gt;v = v;&#10;        this-&gt;queries = queries;&#10;        n = v.size();&#10;        q = queries.size();&#10;        block_size = sqrt(n);&#10;    }&#10;&#10;    vector&lt;U&gt; solve(MoDataStructure&lt;T, U&gt; &amp;ds) {&#10;        vector&lt;U&gt; ans(q);&#10;        sort(all(queries), [](query a, query b) {&#10;            return a.r &lt; b.r;&#10;        });&#10;        int l = 0, r = -1;&#10;        for (auto &amp;q: queries) {&#10;            while (r &lt; q.r) {&#10;                ds.add(v[++r], false);&#10;            }&#10;            while (r &gt; q.r) {&#10;                ds.remove(v[r--], false);&#10;            }&#10;            while (l &lt; q.l) {&#10;                ds.remove(v[l++], true);&#10;            }&#10;            while (l &gt; q.l) {&#10;                ds.add(v[--l], true);&#10;            }&#10;            ans[q.id] = ds.get();&#10;        }&#10;        return ans;&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".adgq" value="const int DIM = 500005;&#10;vector&lt;$TYPE1$&gt; segment_tree[4 * DIM];&#10;bool ask[DIM];&#10;$TYPE2$ ask_val[DIM];&#10;$TYPE3$ ask_ans[DIM];&#10;&#10;&#10;struct update {&#10;&#10;};&#10;&#10;stack&lt;update&gt; updates;&#10;&#10;&#10;$TYPE3$ get(){&#10;    &#10;}&#10;&#10;void apply($TYPE4$) {&#10;    &#10;}&#10;&#10;&#10;void rollback() {&#10;&#10;}&#10;&#10;&#10;void add_segment(int node, int l, int r, int u, int v, $TYPE1$ val) {&#10;    if (v &lt; l || r &lt; u) return;&#10;    if (u &lt;= l &amp;&amp; r &lt;= v) {&#10;        segment_tree[node].push_back(val);&#10;        return;&#10;    }&#10;    int mid = (l + r) &gt;&gt; 1;&#10;    add_segment(node &lt;&lt; 1, l, mid, u, v, val);&#10;    add_segment(node &lt;&lt; 1 | 1, mid + 1, r, u, v, val);&#10;}&#10;&#10;void dfs(int node, int tl, int tr, int size) {&#10;&#10;    for (auto &amp;val: segment_tree[node]) {&#10;        apply($TEXT$);&#10;    }&#10;&#10;&#10;    if (tl == tr) {&#10;        if (ask[tl])&#10;            ask_ans[tl] = get();&#10;&#10;        return;&#10;    }&#10;&#10;    int mid = (tl + tr) &gt;&gt; 1;&#10;&#10;    dfs(node &lt;&lt; 1, tl, mid, updates.size());&#10;    dfs(node &lt;&lt; 1 | 1, mid + 1, tr, updates.size());&#10;    while (updates.size() &gt; size)&#10;        rollback();&#10;&#10;}&#10;" description="add delete get query" toReformat="false" toShortenFQNames="true">
    <variable name="TYPE1" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TYPE2" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TYPE3" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TYPE4" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="TEXT" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".range_fenvik" value="class fenvik {&#10;private:&#10;    vector&lt;int&gt; diff_tree;&#10;    vector&lt;int&gt; diff_mul_tree;&#10;&#10;public:&#10;    fenvik() = default;&#10;&#10;    explicit fenvik(int n) {&#10;        diff_tree.resize(n + 1, 0);&#10;        diff_mul_tree.resize(n + 1, 0);&#10;    }&#10;&#10;    explicit fenvik(const vector&lt;int&gt; &amp;a) {&#10;        diff_tree.resize(len(a), 0);&#10;        diff_mul_tree.resize(len(a), 0);&#10;        for (int i = 1; i &lt;= len(a); ++i) {&#10;            add(i, a[i] - a[i - 1]);&#10;        }&#10;    }&#10;&#10;    void add(int id, int val) {&#10;        for (int i = id; i &lt; len(diff_tree); i += low_bit(i)) {&#10;            diff_tree[i] += val;&#10;            diff_mul_tree[i] += val * id;&#10;        }&#10;    }&#10;&#10;&#10;    void add_range(int l, int r, int val) {&#10;        add(l, val);&#10;        if (r + 1 &lt; len(diff_tree))&#10;            add(r + 1, -val);&#10;    }&#10;&#10;&#10;    int get(int l, int r) {&#10;        int res = 0;&#10;        for (int i = r; i &gt; 0; i -= low_bit(i))&#10;            res += (r + 1) * diff_tree[i] - diff_mul_tree[i];&#10;        for (int i = l - 1; i &gt; 0; i -= low_bit(i))&#10;            res -= (l) * diff_tree[i] - diff_mul_tree[i];&#10;        return res;&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".Fenvik2D" value="class Fenvik2D {&#10;    vector&lt;vector&lt;int&gt;&gt; fenvik;&#10;&#10;    int get(int x, int y) {&#10;        if (x &lt;= 0 || y &lt;= 0) return 0;&#10;        int res = 0;&#10;        for (int i = x; i &gt; 0; i -= low_bit(i)) {&#10;            for (int j = y; j &gt; 0; j -= low_bit(j)) {&#10;                res += fenvik[i][j];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;public:&#10;&#10;    Fenvik2D(int n, int m) {&#10;        fenvik.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;    }&#10;&#10;    void add(int x, int y, int v) {&#10;        for (int i = x; i &lt; len(fenvik); i += low_bit(i)) {&#10;            for (int j = y; j &lt; len(fenvik[0]); j += low_bit(j)) {&#10;                fenvik[i][j] += v;&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    int get(int x1, int y1, int x2, int y2) {&#10;        return get(x2, y2) - get(x1 - 1, y2) - get(x2, y1 - 1) + get(x1 - 1, y1 - 1);&#10;    }&#10;&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".range_fenvik2d" value="class Fenvik2D {&#10;private:&#10;    int n, m;&#10;    vector&lt;vector&lt;int&gt;&gt; diff;&#10;    vector&lt;vector&lt;int&gt;&gt; diff_mul_x;&#10;    vector&lt;vector&lt;int&gt;&gt; diff_mul_y;&#10;    vector&lt;vector&lt;int&gt;&gt; diff_mul_xy;&#10;&#10;    void add(int x, int y, int v) {&#10;        if (x &lt;= 0 || y &lt;= 0) return;&#10;        if (x &gt; n || y &gt; m) return;&#10;        for (int i = x; i &lt;= n; i += low_bit(i)) {&#10;            for (int j = y; j &lt;= m; j += low_bit(j)) {&#10;                diff[i][j] += v;&#10;                diff_mul_x[i][j] += v * x;&#10;                diff_mul_y[i][j] += v * y;&#10;                diff_mul_xy[i][j] += v * x * y;&#10;            }&#10;        }&#10;    }&#10;&#10;    int get_pref(int x, int y) {&#10;        if (x &lt;= 0 || y &lt;= 0) return 0;&#10;        if (x &gt; n || y &gt; m) return 0;&#10;        int res = 0;&#10;        for (int i = x; i &gt; 0; i -= low_bit(i)) {&#10;            for (int j = y; j &gt; 0; j -= low_bit(j)) {&#10;                res += diff[i][j] * (x + 1) * (y + 1) - diff_mul_x[i][j] * (y + 1) - diff_mul_y[i][j] * (x + 1) +&#10;                       diff_mul_xy[i][j];&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;public:&#10;    Fenvik2D(int n, int m) : n(n), m(m) {&#10;        diff.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        diff_mul_x.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        diff_mul_y.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        diff_mul_xy.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;&#10;    }&#10;&#10;    Fenvik2D(const vector&lt;vector&lt;int&gt;&gt; &amp;a) {&#10;        n = len(a) - 1;&#10;        m = len(a[0]) - 1;&#10;        diff.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        diff_mul_x.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        diff_mul_y.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        diff_mul_xy.resize(n + 1, vector&lt;int&gt;(m + 1, 0));&#10;        for (int i = 1; i &lt;= n; i++) {&#10;            for (int j = 1; j &lt;= m; j++) {&#10;                add(i, j, a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1]);&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    void add_range(int x1, int y1, int x2, int y2, int v) {&#10;        add(x1, y1, v);&#10;        add(x1, y2 + 1, -v);&#10;        add(x2 + 1, y1, -v);&#10;        add(x2 + 1, y2 + 1, v);&#10;    }&#10;&#10;    int get(int x1, int y1, int x2, int y2) {&#10;        return get_pref(x2, y2) - get_pref(x1 - 1, y2) - get_pref(x2, y1 - 1) + get_pref(x1 - 1, y1 - 1);&#10;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".min_coost_max_flow" value="struct edge {&#10;//    v -&gt; u&#10;    int v, u;&#10;    int capacity, flow;&#10;    int cost;&#10;};&#10;&#10;&#10;//edge edges[MAXN];&#10;vector&lt;edge&gt; edges;&#10;int N, M;&#10;&#10;&#10;graph&lt;int&gt; g;&#10;vector&lt;int&gt; phi;&#10;vector&lt;int&gt; dist, parent;&#10;&#10;&#10;void dijkstra(int s) {&#10;    dist.assign(phi.size(), inf);&#10;    parent.assign(phi.size(), -1);&#10;    dist[s] = 0;&#10;    min_heap&lt;pair&lt;int, int&gt;&gt; q;&#10;    q.emplace(0, s);&#10;    while (!q.empty()) {&#10;        auto cur = q.top();&#10;        q.pop();&#10;        int v = cur.second;&#10;        int d = cur.first;&#10;        if (d &gt; dist[v]) continue;&#10;        for (auto id: g[v]) {&#10;            int u = edges[id].u;&#10;            int w = edges[id].cost + phi[v] - phi[u];&#10;            if (edges[id].flow &lt; edges[id].capacity &amp;&amp; dist[v] + w &lt; dist[u]) {&#10;                dist[u] = dist[v] + w;&#10;                parent[u] = id;&#10;                q.emplace(dist[u], u);&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;void min_cost(int need_flow = inf) {&#10;    int cost = 0;&#10;    int end = 2 * N + 1;&#10;    int start = 0;&#10;    while (true) {&#10;        dijkstra(start);&#10;        if (need_flow == 0) break;&#10;        if (dist[end] == inf) break;&#10;&#10;        for (int i = 0; i &lt; phi.size(); ++i) {&#10;            phi[i] += dist[i];&#10;        }&#10;        int cur_flow = need_flow;&#10;        for (int v = end; v != start; v = edges[parent[v]].v) {&#10;            int id = parent[v];&#10;            cur_flow = min(cur_flow, edges[id].capacity - edges[id].flow);&#10;        }&#10;        for (int v = end; v != start; v = edges[parent[v]].v) {&#10;            int id = parent[v];&#10;            edges[id].flow += cur_flow;&#10;            edges[id ^ 1].flow -= cur_flow;&#10;            cost += cur_flow * edges[id].cost;&#10;        }&#10;        need_flow -= cur_flow;&#10;    }&#10;    cout &lt;&lt; cost &lt;&lt; endl;&#10;}&#10;&#10;&#10;void add_edge(int v, int u, int capacity, int cost) {&#10;    edges.push_back({v, u, capacity, 0, cost});&#10;    edges.push_back({u, v, 0, 0, -cost});&#10;    g[v].push_back(edges.size() - 2);&#10;    g[u].push_back(edges.size() - 1);&#10;}&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".dinic" value="vector&lt;int&gt; level, ptr;&#10;&#10;bool bfs(int s) {&#10;    level.assign(N, -1);&#10;    level[s] = 0;&#10;    queue&lt;int&gt; q;&#10;    q.push(s);&#10;    while (!q.empty()) {&#10;        int u = q.front();&#10;        q.pop();&#10;        for (int id: g[u]) {&#10;            int v = edges[id].v;&#10;            if (edges[id].cap - edges[id].flow &lt; 1 || level[v] != -1) continue;&#10;            level[v] = level[u] + 1;&#10;            q.push(v);&#10;        }&#10;    }&#10;    return level[N - 1] != -1;&#10;}&#10;&#10;void push(int id, int flow) {&#10;    edges[id].flow += flow;&#10;    edges[id ^ 1].flow -= flow;&#10;}&#10;&#10;int dfs(int u, int end, int flow) {&#10;    if (u == end || flow == 0) return flow;&#10;    for (; ptr[u] &lt; len(g[u]); ++ptr[u]) {&#10;        int id = g[u][ptr[u]];&#10;        int v = edges[id].v;&#10;        if (level[v] != level[u] + 1 || edges[id].cap - edges[id].flow &lt; 1) continue;&#10;        int pushed = dfs(v, end, min(flow, edges[id].cap - edges[id].flow));&#10;        if (pushed) {&#10;            push(id, pushed);&#10;            return pushed;&#10;        }&#10;    }&#10;    return 0;&#10;}&#10;&#10;&#10;int dinic(int start, int end) {&#10;    int flow = 0;&#10;    while (true) {&#10;        if (!bfs(start)) break;&#10;        ptr.assign(N, 0);&#10;        while (int pushed = dfs(start, end, inf)) {&#10;            flow += pushed;&#10;        }&#10;    }&#10;    return flow;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".preffsum" value="struct PrefixSum {&#10;    int n;&#10;    vector&lt;int&gt; pref;&#10;&#10;    explicit PrefixSum(const vector&lt;int&gt; &amp;a) {&#10;        n = len(a);&#10;        pref = vect(n, 0LL);&#10;        pref[0] = a[0];&#10;        for (int i = 1; i &lt; n; i++) {&#10;            pref[i] = pref[i - 1] + a[i];&#10;        }&#10;    }&#10;&#10;    int get(int l, int r) {&#10;        if (l == 0) {&#10;            return pref[r];&#10;        } else {&#10;            return pref[r] - pref[l - 1];&#10;        }&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".modimport" value="/*&#10;* powered by ANDRIY POPYK&#10;* in honor of MYSELF and SEGMENT DECOMPOSITION and N^(log(N)) and (Harry Potter and the Methods of Rationality) and Monkie D. Luffy&#10;*/&#10;&#10;#include &lt;bits/stdc++.h&gt;&#10;#include &lt;ext/pb_ds/assoc_container.hpp&gt;&#10;&#10;//#pragma GCC optimize(&quot;O3&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,fma&quot;)&#10;//#pragma GCC optimization (&quot;unroll-loops&quot;)&#10;//#pragma GCC target(&quot;avx,avx2,sse,sse2,sse3,sse4,popcnt&quot;)&#10;&#10;using namespace std;&#10;using namespace __gnu_pbds;&#10;#define float long double&#10;#define elif else if&#10;#define endl &quot;\n&quot;&#10;//#define mod 1000000007&#10;#define pi acos(-1)&#10;#define eps 0.000000001&#10;#define inf 1000000000000&#10;#define FIXED(a) cout &lt;&lt; fixed &lt;&lt; setprecision(a)&#10;#define all(x) x.begin(), x.end()&#10;#define rall(x) x.rbegin(), x.rend()&#10;#define time_init auto start = std::chrono::high_resolution_clock::now()&#10;#define time_report                                       \&#10;    auto end = std::chrono::high_resolution_clock::now(); \&#10;    std::cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count() &lt;&lt; &quot; ms&quot; &lt;&lt; endl&#10;#define debug(x) \&#10;    { cerr &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl; }&#10;#define len(x) (int) x.size()&#10;#define sqr(x) ((x) * (x))&#10;#define cube(x) ((x) * (x) * (x))&#10;#define bit(x, i) (((x) &gt;&gt; (i)) &amp; 1)&#10;#define set_bit(x, i) ((x) | (1LL &lt;&lt; (i)))&#10;#define clear_bit(x, i) ((x) &amp; (~(1LL &lt;&lt; (i))))&#10;#define toggle_bit(x, i) ((x) ^ (1LL &lt;&lt; (i)))&#10;#define low_bit(x) ((x) &amp; (-(x)))&#10;#define count_bit(x) __builtin_popcountll(x)&#10;#define srt(x) sort(all(x))&#10;#define rsrt(x) sort(rall(x))&#10;#define mp make_pair&#10;#define maxel(x) (*max_element(all(x)))&#10;#define minel(x) (*min_element(all(x)))&#10;#define maxelpos(x) (max_element(all(x)) - x.begin())&#10;#define minelpos(x) (min_element(all(x)) - x.begin())&#10;#define sum(x) (accumulate(all(x), 0LL))&#10;#define product(x) (accumulate(all(x), 1LL, multiplies&lt;int&gt;()))&#10;#define gcd __gcd&#10;#define lcm(a, b) ((a) / gcd(a, b) * (b))&#10;#define rev(x) (reverse(all(x)))&#10;#define shift_left(x, k) (rotate(x.begin(), x.begin() + k, x.end()))&#10;#define shift_right(x, k) (rotate(x.rbegin(), x.rbegin() + k, x.rend()))&#10;#define is_sorted(x) (is_sorted_until(all(x)) == x.end())&#10;#define is_even(x) (((x) &amp;1) == 0)&#10;#define is_odd(x) (((x) &amp;1) == 1)&#10;#define pow2(x) (1LL &lt;&lt; (x))&#10;&#10;struct custom_hash {&#10;    static uint64_t splitmix64(uint64_t x) {&#10;        // http://xorshift.di.unimi.it/splitmix64.c&#10;        x += 0x9e3779b97f4a7c15;&#10;        x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;&#10;        x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;&#10;        return x ^ (x &gt;&gt; 31);&#10;    }&#10;&#10;    size_t operator()(uint64_t x) const {&#10;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();&#10;        return splitmix64(x + FIXED_RANDOM);&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;using min_heap = priority_queue&lt;T, vector&lt;T&gt;, greater&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using max_heap = priority_queue&lt;T, vector&lt;T&gt;, less&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;template&lt;typename T&gt;&#10;using ordered_multiset = tree&lt;T, null_type, less_equal&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;&#10;using hashmap = gp_hash_table&lt;int, int, custom_hash&gt;;&#10;template&lt;typename T&gt;&#10;using matrix = vector&lt;vector&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using graph = vector&lt;vector&lt;T&gt;&gt;;&#10;template&lt;typename T&gt;&#10;using vec = vector&lt;T&gt;;&#10;&#10;namespace internal {&#10;&#10;#ifndef _MSC_VER&#10;    template&lt;class T&gt;&#10;    using is_signed_int128 =&#10;            typename std::conditional&lt;std::is_same&lt;T, __int128_t&gt;::value ||&#10;                                              std::is_same&lt;T, __int128&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int128 =&#10;            typename std::conditional&lt;std::is_same&lt;T, __uint128_t&gt;::value ||&#10;                                              std::is_same&lt;T, unsigned __int128&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using make_unsigned_int128 =&#10;            typename std::conditional&lt;std::is_same&lt;T, __int128_t&gt;::value,&#10;                                      __uint128_t,&#10;                                      unsigned __int128&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_integral = typename std::conditional&lt;std::is_integral&lt;T&gt;::value ||&#10;                                                          is_signed_int128&lt;T&gt;::value ||&#10;                                                          is_unsigned_int128&lt;T&gt;::value,&#10;                                                  std::true_type,&#10;                                                  std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_signed_int = typename std::conditional&lt;(is_integral&lt;T&gt;::value &amp;&amp;&#10;                                                     std::is_signed&lt;T&gt;::value) ||&#10;                                                            is_signed_int128&lt;T&gt;::value,&#10;                                                    std::true_type,&#10;                                                    std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int =&#10;            typename std::conditional&lt;(is_integral&lt;T&gt;::value &amp;&amp;&#10;                                       std::is_unsigned&lt;T&gt;::value) ||&#10;                                              is_unsigned_int128&lt;T&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using to_unsigned = typename std::conditional&lt;&#10;            is_signed_int128&lt;T&gt;::value,&#10;            make_unsigned_int128&lt;T&gt;,&#10;            typename std::conditional&lt;std::is_signed&lt;T&gt;::value,&#10;                                      std::make_unsigned&lt;T&gt;,&#10;                                      std::common_type&lt;T&gt;&gt;::type&gt;::type;&#10;&#10;#else&#10;&#10;    template&lt;class T&gt;&#10;    using is_integral = typename std::is_integral&lt;T&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_signed_int =&#10;            typename std::conditional&lt;is_integral&lt;T&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int =&#10;            typename std::conditional&lt;is_integral&lt;T&gt;::value &amp;&amp;&#10;                                              std::is_unsigned&lt;T&gt;::value,&#10;                                      std::true_type,&#10;                                      std::false_type&gt;::type;&#10;&#10;    template&lt;class T&gt;&#10;    using to_unsigned = typename std::conditional&lt;is_signed_int&lt;T&gt;::value,&#10;                                                  std::make_unsigned&lt;T&gt;,&#10;                                                  std::common_type&lt;T&gt;&gt;::type;&#10;&#10;#endif&#10;&#10;    template&lt;class T&gt;&#10;    using is_signed_int_t = std::enable_if_t&lt;is_signed_int&lt;T&gt;::value&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_unsigned_int_t = std::enable_if_t&lt;is_unsigned_int&lt;T&gt;::value&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using to_unsigned_t = typename to_unsigned&lt;T&gt;::type;&#10;&#10;}// namespace internal&#10;&#10;&#10;namespace internal {&#10;&#10;    // @param m `1 &lt;= m`&#10;    // @return x mod m&#10;    constexpr long long safe_mod(long long x, long long m) {&#10;        x %= m;&#10;        if (x &lt; 0) x += m;&#10;        return x;&#10;    }&#10;&#10;    // Fast modular multiplication by barrett reduction&#10;    // Reference: https://en.wikipedia.org/wiki/Barrett_reduction&#10;    // NOTE: reconsider after Ice Lake&#10;    struct barrett {&#10;        unsigned int _m;&#10;        unsigned long long im;&#10;&#10;        // @param m `1 &lt;= m`&#10;        explicit barrett(unsigned int m) : _m(m), im((unsigned long long) (-1) / m + 1) {}&#10;&#10;        // @return m&#10;        unsigned int umod() const { return _m; }&#10;&#10;        // @param a `0 &lt;= a &lt; m`&#10;        // @param b `0 &lt;= b &lt; m`&#10;        // @return `a * b % m`&#10;        unsigned int mul(unsigned int a, unsigned int b) const {&#10;            // [1] m = 1&#10;            // a = b = im = 0, so okay&#10;&#10;            // [2] m &gt;= 2&#10;            // im = ceil(2^64 / m)&#10;            // -&gt; im * m = 2^64 + r (0 &lt;= r &lt; m)&#10;            // let z = a*b = c*m + d (0 &lt;= c, d &lt; m)&#10;            // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im&#10;            // c*r + d*im &lt; m * m + m * im &lt; m * m + 2^64 + m &lt;= 2^64 + m * (m + 1) &lt; 2^64 * 2&#10;            // ((ab * im) &gt;&gt; 64) == c or c + 1&#10;            unsigned long long z = a;&#10;            z *= b;&#10;#ifdef _MSC_VER&#10;            unsigned long long x;&#10;            _umul128(z, im, &amp;x);&#10;#else&#10;            unsigned long long x =&#10;                    (unsigned long long) (((unsigned __int128) (z) *im) &gt;&gt; 64);&#10;#endif&#10;            unsigned long long y = x * _m;&#10;            return (unsigned int) (z - y + (z &lt; y ? _m : 0));&#10;        }&#10;    };&#10;&#10;    // @param n `0 &lt;= n`&#10;    // @param m `1 &lt;= m`&#10;    // @return `(x ** n) % m`&#10;    constexpr long long pow_mod_constexpr(long long x, long long n, int m) {&#10;        if (m == 1) return 0;&#10;        unsigned int _m = (unsigned int) (m);&#10;        unsigned long long r = 1;&#10;        unsigned long long y = safe_mod(x, m);&#10;        while (n) {&#10;            if (n &amp; 1) r = (r * y) % _m;&#10;            y = (y * y) % _m;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return r;&#10;    }&#10;&#10;    // Reference:&#10;    // M. Forisek and J. Jancina,&#10;    // Fast Primality Testing for Integers That Fit into a Machine Word&#10;    // @param n `0 &lt;= n`&#10;    constexpr bool is_prime_constexpr(int n) {&#10;        if (n &lt;= 1) return false;&#10;        if (n == 2 || n == 7 || n == 61) return true;&#10;        if (n % 2 == 0) return false;&#10;        long long d = n - 1;&#10;        while (d % 2 == 0) d /= 2;&#10;        constexpr long long bases[3] = {2, 7, 61};&#10;        for (long long a: bases) {&#10;            long long t = d;&#10;            long long y = pow_mod_constexpr(a, t, n);&#10;            while (t != n - 1 &amp;&amp; y != 1 &amp;&amp; y != n - 1) {&#10;                y = y * y % n;&#10;                t &lt;&lt;= 1;&#10;            }&#10;            if (y != n - 1 &amp;&amp; t % 2 == 0) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;    template&lt;int n&gt;&#10;    constexpr bool is_prime = is_prime_constexpr(n);&#10;&#10;    // @param b `1 &lt;= b`&#10;    // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 &lt;= x &lt; b/g&#10;    constexpr std::pair&lt;long long, long long&gt; inv_gcd(long long a, long long b) {&#10;        a = safe_mod(a, b);&#10;        if (a == 0) return {b, 0};&#10;&#10;        // Contracts:&#10;        // [1] s - m0 * a = 0 (mod b)&#10;        // [2] t - m1 * a = 0 (mod b)&#10;        // [3] s * |m1| + t * |m0| &lt;= b&#10;        long long s = b, t = a;&#10;        long long m0 = 0, m1 = 1;&#10;&#10;        while (t) {&#10;            long long u = s / t;&#10;            s -= t * u;&#10;            m0 -= m1 * u;// |m1 * u| &lt;= |m1| * s &lt;= b&#10;&#10;            // [3]:&#10;            // (s - t * u) * |m1| + t * |m0 - m1 * u|&#10;            // &lt;= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)&#10;            // = s * |m1| + t * |m0| &lt;= b&#10;&#10;            auto tmp = s;&#10;            s = t;&#10;            t = tmp;&#10;            tmp = m0;&#10;            m0 = m1;&#10;            m1 = tmp;&#10;        }&#10;        // by [3]: |m0| &lt;= b/g&#10;        // by g != b: |m0| &lt; b/g&#10;        if (m0 &lt; 0) m0 += b / s;&#10;        return {s, m0};&#10;    }&#10;&#10;    // Compile time primitive root&#10;    // @param m must be prime&#10;    // @return primitive root (and minimum in now)&#10;    constexpr int primitive_root_constexpr(int m) {&#10;        if (m == 2) return 1;&#10;        if (m == 167772161) return 3;&#10;        if (m == 469762049) return 3;&#10;        if (m == 754974721) return 11;&#10;        if (m == 998244353) return 3;&#10;        int divs[20] = {};&#10;        divs[0] = 2;&#10;        int cnt = 1;&#10;        int x = (m - 1) / 2;&#10;        while (x % 2 == 0) x /= 2;&#10;        for (int i = 3; (long long) (i) *i &lt;= x; i += 2) {&#10;            if (x % i == 0) {&#10;                divs[cnt++] = i;&#10;                while (x % i == 0) {&#10;                    x /= i;&#10;                }&#10;            }&#10;        }&#10;        if (x &gt; 1) {&#10;            divs[cnt++] = x;&#10;        }&#10;        for (int g = 2;; g++) {&#10;            bool ok = true;&#10;            for (int i = 0; i &lt; cnt; i++) {&#10;                if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {&#10;                    ok = false;&#10;                    break;&#10;                }&#10;            }&#10;            if (ok) return g;&#10;        }&#10;    }&#10;    template&lt;int m&gt;&#10;    constexpr int primitive_root = primitive_root_constexpr(m);&#10;&#10;    // @param n `n &lt; 2^32`&#10;    // @param m `1 &lt;= m &lt; 2^32`&#10;    // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)&#10;    unsigned long long floor_sum_unsigned(unsigned long long n,&#10;                                          unsigned long long m,&#10;                                          unsigned long long a,&#10;                                          unsigned long long b) {&#10;        unsigned long long ans = 0;&#10;        while (true) {&#10;            if (a &gt;= m) {&#10;                ans += n * (n - 1) / 2 * (a / m);&#10;                a %= m;&#10;            }&#10;            if (b &gt;= m) {&#10;                ans += n * (b / m);&#10;                b %= m;&#10;            }&#10;&#10;            unsigned long long y_max = a * n + b;&#10;            if (y_max &lt; m) break;&#10;            // y_max &lt; m * (n + 1)&#10;            // floor(y_max / m) &lt;= n&#10;            n = (unsigned long long) (y_max / m);&#10;            b = (unsigned long long) (y_max % m);&#10;            std::swap(m, a);&#10;        }&#10;        return ans;&#10;    }&#10;&#10;}// namespace internal&#10;&#10;&#10;namespace internal {&#10;&#10;    struct modint_base {};&#10;    struct static_modint_base : modint_base {};&#10;&#10;    template&lt;class T&gt;&#10;    using is_modint = std::is_base_of&lt;modint_base, T&gt;;&#10;    template&lt;class T&gt;&#10;    using is_modint_t = std::enable_if_t&lt;is_modint&lt;T&gt;::value&gt;;&#10;&#10;}// namespace internal&#10;&#10;template&lt;int m, std::enable_if_t&lt;(1 &lt;= m)&gt; * = nullptr&gt;&#10;struct static_modint : internal::static_modint_base {&#10;    using mint = static_modint;&#10;&#10;public:&#10;    static constexpr int mod() { return m; }&#10;    static mint raw(int v) {&#10;        mint x;&#10;        x._v = v;&#10;        return x;&#10;    }&#10;&#10;    static_modint() : _v(0) {}&#10;    template&lt;class T, internal::is_signed_int_t&lt;T&gt; * = nullptr&gt;&#10;    static_modint(T v) {&#10;        long long x = (long long) (v % (long long) (umod()));&#10;        if (x &lt; 0) x += umod();&#10;        _v = (unsigned int) (x);&#10;    }&#10;    template&lt;class T, internal::is_unsigned_int_t&lt;T&gt; * = nullptr&gt;&#10;    static_modint(T v) {&#10;        _v = (unsigned int) (v % umod());&#10;    }&#10;&#10;    unsigned int val() const { return _v; }&#10;&#10;    mint &amp;operator++() {&#10;        _v++;&#10;        if (_v == umod()) _v = 0;&#10;        return *this;&#10;    }&#10;    mint &amp;operator--() {&#10;        if (_v == 0) _v = umod();&#10;        _v--;&#10;        return *this;&#10;    }&#10;    mint operator++(int) {&#10;        mint result = *this;&#10;        ++*this;&#10;        return result;&#10;    }&#10;    mint operator--(int) {&#10;        mint result = *this;&#10;        --*this;&#10;        return result;&#10;    }&#10;&#10;    mint &amp;operator+=(const mint &amp;rhs) {&#10;        _v += rhs._v;&#10;        if (_v &gt;= umod()) _v -= umod();&#10;        return *this;&#10;    }&#10;    mint &amp;operator-=(const mint &amp;rhs) {&#10;        _v -= rhs._v;&#10;        if (_v &gt;= umod()) _v += umod();&#10;        return *this;&#10;    }&#10;    mint &amp;operator*=(const mint &amp;rhs) {&#10;        unsigned long long z = _v;&#10;        z *= rhs._v;&#10;        _v = (unsigned int) (z % umod());&#10;        return *this;&#10;    }&#10;    mint &amp;operator/=(const mint &amp;rhs) { return *this = *this * rhs.inv(); }&#10;&#10;    mint operator+() const { return *this; }&#10;    mint operator-() const { return mint() - *this; }&#10;&#10;    mint pow(long long n) const {&#10;        assert(0 &lt;= n);&#10;        mint x = *this, r = 1;&#10;        while (n) {&#10;            if (n &amp; 1) r *= x;&#10;            x *= x;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return r;&#10;    }&#10;    mint inv() const {&#10;        if (prime) {&#10;            assert(_v);&#10;            return pow(umod() - 2);&#10;        } else {&#10;            auto eg = internal::inv_gcd(_v, m);&#10;            assert(eg.first == 1);&#10;            return eg.second;&#10;        }&#10;    }&#10;&#10;    friend mint operator+(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) += rhs;&#10;    }&#10;    friend mint operator-(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) -= rhs;&#10;    }&#10;    friend mint operator*(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) *= rhs;&#10;    }&#10;    friend mint operator/(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) /= rhs;&#10;    }&#10;    friend bool operator==(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v == rhs._v;&#10;    }&#10;    friend bool operator!=(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v != rhs._v;&#10;    }&#10;&#10;private:&#10;    unsigned int _v;&#10;    static constexpr unsigned int umod() { return m; }&#10;    static constexpr bool prime = internal::is_prime&lt;m&gt;;&#10;};&#10;&#10;template&lt;int id&gt;&#10;struct dynamic_modint : internal::modint_base {&#10;    using mint = dynamic_modint;&#10;&#10;public:&#10;    static int mod() { return (int) (bt.umod()); }&#10;    static void set_mod(int m) {&#10;        assert(1 &lt;= m);&#10;        bt = internal::barrett(m);&#10;    }&#10;    static mint raw(int v) {&#10;        mint x;&#10;        x._v = v;&#10;        return x;&#10;    }&#10;&#10;    dynamic_modint() : _v(0) {}&#10;    template&lt;class T, internal::is_signed_int_t&lt;T&gt; * = nullptr&gt;&#10;    dynamic_modint(T v) {&#10;        long long x = (long long) (v % (long long) (mod()));&#10;        if (x &lt; 0) x += mod();&#10;        _v = (unsigned int) (x);&#10;    }&#10;    template&lt;class T, internal::is_unsigned_int_t&lt;T&gt; * = nullptr&gt;&#10;    dynamic_modint(T v) {&#10;        _v = (unsigned int) (v % mod());&#10;    }&#10;&#10;    unsigned int val() const { return _v; }&#10;&#10;    mint &amp;operator++() {&#10;        _v++;&#10;        if (_v == umod()) _v = 0;&#10;        return *this;&#10;    }&#10;    mint &amp;operator--() {&#10;        if (_v == 0) _v = umod();&#10;        _v--;&#10;        return *this;&#10;    }&#10;    mint operator++(int) {&#10;        mint result = *this;&#10;        ++*this;&#10;        return result;&#10;    }&#10;    mint operator--(int) {&#10;        mint result = *this;&#10;        --*this;&#10;        return result;&#10;    }&#10;&#10;    mint &amp;operator+=(const mint &amp;rhs) {&#10;        _v += rhs._v;&#10;        if (_v &gt;= umod()) _v -= umod();&#10;        return *this;&#10;    }&#10;    mint &amp;operator-=(const mint &amp;rhs) {&#10;        _v += mod() - rhs._v;&#10;        if (_v &gt;= umod()) _v -= umod();&#10;        return *this;&#10;    }&#10;    mint &amp;operator*=(const mint &amp;rhs) {&#10;        _v = bt.mul(_v, rhs._v);&#10;        return *this;&#10;    }&#10;    mint &amp;operator/=(const mint &amp;rhs) { return *this = *this * rhs.inv(); }&#10;&#10;    mint operator+() const { return *this; }&#10;    mint operator-() const { return mint() - *this; }&#10;&#10;    mint pow(long long n) const {&#10;        assert(0 &lt;= n);&#10;        mint x = *this, r = 1;&#10;        while (n) {&#10;            if (n &amp; 1) r *= x;&#10;            x *= x;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return r;&#10;    }&#10;    mint inv() const {&#10;        auto eg = internal::inv_gcd(_v, mod());&#10;        assert(eg.first == 1);&#10;        return eg.second;&#10;    }&#10;&#10;    friend mint operator+(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) += rhs;&#10;    }&#10;    friend mint operator-(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) -= rhs;&#10;    }&#10;    friend mint operator*(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) *= rhs;&#10;    }&#10;    friend mint operator/(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return mint(lhs) /= rhs;&#10;    }&#10;    friend bool operator==(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v == rhs._v;&#10;    }&#10;    friend bool operator!=(const mint &amp;lhs, const mint &amp;rhs) {&#10;        return lhs._v != rhs._v;&#10;    }&#10;&#10;private:&#10;    unsigned int _v;&#10;    static internal::barrett bt;&#10;    static unsigned int umod() { return bt.umod(); }&#10;};&#10;template&lt;int id&gt;&#10;internal::barrett dynamic_modint&lt;id&gt;::bt(998244353);&#10;&#10;using modint998244353 = static_modint&lt;998244353&gt;;&#10;using modint1000000007 = static_modint&lt;1000000007&gt;;&#10;using modint = dynamic_modint&lt;-1&gt;;&#10;&#10;namespace internal {&#10;&#10;    template&lt;class T&gt;&#10;    using is_static_modint = std::is_base_of&lt;internal::static_modint_base, T&gt;;&#10;&#10;    template&lt;class T&gt;&#10;    using is_static_modint_t = std::enable_if_t&lt;is_static_modint&lt;T&gt;::value&gt;;&#10;&#10;    template&lt;class&gt;&#10;    struct is_dynamic_modint : public std::false_type {};&#10;    template&lt;int id&gt;&#10;    struct is_dynamic_modint&lt;dynamic_modint&lt;id&gt;&gt; : public std::true_type {};&#10;&#10;    template&lt;class T&gt;&#10;    using is_dynamic_modint_t = std::enable_if_t&lt;is_dynamic_modint&lt;T&gt;::value&gt;;&#10;&#10;}// namespace internal&#10;&#10;&#10;using mint = modint998244353;&#10;&#10;#define int long long&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; vect(int n, T val) {&#10;    return vector&lt;T&gt;(n, val);&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;T&gt;&gt; vect(int n, int m, T val) {&#10;    return vector&lt;vector&lt;T&gt;&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt; vect(int n, int m, int k, T val) {&#10;    return vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(n, vector&lt;vector&lt;T&gt;&gt;(m, vector&lt;T&gt;(k, val)));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt; vect(int n, int m, int k, int l, T val) {&#10;    return vector&lt;vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;&gt;(n, vector&lt;vector&lt;vector&lt;T&gt;&gt;&gt;(m, vector&lt;vector&lt;T&gt;&gt;(k, vector&lt;T&gt;(l, val))));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;matrix&lt;T&gt; new_matrix(int n, int m, T val) {&#10;    return matrix&lt;T&gt;(n, vector&lt;T&gt;(m, val));&#10;}&#10;&#10;template&lt;typename T&gt;&#10;graph&lt;T&gt; new_graph(int n) {&#10;    return graph&lt;T&gt;(n);&#10;}&#10;template&lt;class T, class S&gt;&#10;inline bool chmax(T &amp;a, const S &amp;b) {&#10;    return (a &lt; b ? a = b, 1 : 0);&#10;}&#10;template&lt;class T, class S&gt;&#10;inline bool chmin(T &amp;a, const S &amp;b) {&#10;    return (a &gt; b ? a = b, 1 : 0);&#10;}&#10;&#10;using i8 = int8_t;&#10;using i16 = int16_t;&#10;using i32 = int32_t;&#10;using i64 = int64_t;&#10;using u8 = uint8_t;&#10;using u16 = uint16_t;&#10;using u32 = uint32_t;&#10;using u64 = uint64_t;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".sparsetable" value="template&lt;typename it, typename bin_op&gt;&#10;struct SparseTable {&#10;&#10;    using T = typename remove_reference&lt;decltype(*declval&lt;it&gt;())&gt;::type;&#10;    vector&lt;vector&lt;T&gt;&gt; t;&#10;    bin_op f;&#10;    vector&lt;int&gt; log;&#10;    SparseTable() = default;&#10;&#10;    SparseTable(it first, it last, bin_op op) : t(1), f(op) {&#10;        int n = distance(first, last);&#10;        t.assign(32 - __builtin_clz(n), vector&lt;T&gt;(n));&#10;        t[0].assign(first, last);&#10;        //       calc log&#10;        log.resize(n + 1);&#10;        for (int i = 2; i &lt;= n; i++)&#10;            log[i] = log[i / 2] + 1;&#10;&#10;        for (int i = 1; i &lt; t.size(); i++)&#10;            for (int j = 0; j &lt; n - (1 &lt;&lt; i) + 1; j++)&#10;                t[i][j] = f(t[i - 1][j], t[i - 1][j + (1 &lt;&lt; (i - 1))]);&#10;    }&#10;&#10;    // returns f(a[l..r]) in O(1) time&#10;    T get(int l, int r) {&#10;        int h = log[r - l + 1];&#10;        return f(t[h][l], t[h][r - (1 &lt;&lt; h) + 1]);&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".Matrix" value="template&lt;typename T, size_t n, size_t m&gt;&#10;class Matrix {&#10;    array&lt;array&lt;T, m&gt;, n&gt; mat{};&#10;&#10;    [[nodiscard]] static bool is_square() {&#10;        return n == m;&#10;    }&#10;&#10;&#10;public:&#10;    static Matrix&lt;T, n, m&gt; identity() {&#10;        if (!is_square())&#10;            throw runtime_error(&quot;Matrix is not square&quot;);&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            res[i][i] = 1;&#10;        return res;&#10;    }&#10;&#10;    Matrix() = default;&#10;&#10;    explicit Matrix(const array&lt;array&lt;T, m&gt;, n&gt; &amp;mat) : mat(mat) {}&#10;&#10;    explicit Matrix(const vector&lt;vector&lt;T&gt;&gt; &amp;mat) {&#10;        if (mat.size() != n || mat[0].size() != m)&#10;            throw runtime_error(&quot;Matrix has wrong size&quot;);&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                this-&gt;mat[i][j] = mat[i][j];&#10;    }&#10;&#10;    explicit Matrix(const initializer_list&lt;initializer_list&lt;T&gt;&gt; &amp;mat) {&#10;        if (mat.size() != n || mat.begin()-&gt;size() != m)&#10;            throw runtime_error(&quot;Matrix has wrong size&quot;);&#10;        int i = 0;&#10;        for (const auto &amp;row: mat) {&#10;            int j = 0;&#10;            for (const auto &amp;x: row) {&#10;                this-&gt;mat[i][j] = x;&#10;                j++;&#10;            }&#10;            i++;&#10;        }&#10;    }&#10;&#10;    array&lt;T, m&gt; &amp;operator[](int i) {&#10;        return mat[i];&#10;    }&#10;&#10;    const array&lt;T, m&gt; &amp;operator[](int i) const {&#10;        return mat[i];&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator+(const Matrix&lt;T, n, m&gt; &amp;other) const {&#10;&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] + other[i][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator-(const Matrix&lt;T, n, m&gt; &amp;other) const {&#10;        if (mat.size() != other.size() || mat[0].size() != other[0].size())&#10;            throw runtime_error(&quot;Matrix has wrong size&quot;);&#10;&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] - other[i][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator-() {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = -mat[i][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator*(const T &amp;other) const {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] * other;&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator/(const T &amp;other) const {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] / other;&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator%(const T &amp;other) const {&#10;        Matrix&lt;T, n, m&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; m; j++)&#10;                res[i][j] = mat[i][j] % other;&#10;        return res;&#10;    }&#10;&#10;&#10;    template&lt;size_t k&gt;&#10;    Matrix&lt;T, n, m&gt; operator*(const Matrix&lt;T, m, k&gt; &amp;other) const {&#10;        Matrix&lt;T, n, k&gt; res{};&#10;        for (int i = 0; i &lt; n; i++)&#10;            for (int j = 0; j &lt; k; j++)&#10;                for (int l = 0; l &lt; m; l++)&#10;                    res[i][j] += mat[i][l] * other[l][j];&#10;        return res;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator^(int k) const {&#10;        if (!is_square())&#10;            throw runtime_error(&quot;Matrix is not square&quot;);&#10;        Matrix&lt;T, n, m&gt; res = identity();&#10;        Matrix&lt;T, n, m&gt; a = *this;&#10;        while (k) {&#10;            if (k &amp; 1)&#10;                res = res * a;&#10;            a = a * a;&#10;            k &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;&#10;&#10;    Matrix&lt;T, n, m&gt; operator+=(const Matrix&lt;T, n, m&gt; &amp;other) {&#10;        return *this = *this + other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator-=(const Matrix&lt;T, n, m&gt; &amp;other) {&#10;        return *this = *this - other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator*=(const T &amp;other) {&#10;        return *this = *this * other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator/=(const T &amp;other) {&#10;        return *this = *this / other;&#10;    }&#10;&#10;    Matrix&lt;T, n, m&gt; operator%=(const T &amp;other) {&#10;        return *this = *this % other;&#10;    }&#10;&#10;&#10;    Matrix&lt;T, n, m&gt; operator^=(const int &amp;other) {&#10;        return *this = *this ^ other;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".wavelet" value="class WaveletTree {&#10;    int low, high;&#10;    WaveletTree *left, *right;&#10;    vector&lt;int&gt; freq;&#10;&#10;public:&#10;    WaveletTree(vec&lt;int&gt;::iterator from, vec&lt;int&gt;::iterator to, int _low, int _high) : low(_low), high(_high) {&#10;        if (from &gt; to) return;&#10;        if (low == high) return;&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        auto lowerThanMid = [mid](int x) { return x &lt;= mid; };&#10;        freq.reserve(to - from + 1);&#10;        freq.push_back(0);&#10;        for (auto it = from; it != to; it++) {&#10;            freq.push_back(freq.back() + lowerThanMid(*it));&#10;        }&#10;        auto pivot = stable_partition(from, to, lowerThanMid);&#10;&#10;        if (from != pivot) {&#10;            left = new WaveletTree(from, pivot, low, mid);&#10;        }&#10;        if (pivot != to) {&#10;            right = new WaveletTree(pivot, to, mid + 1, high);&#10;        }&#10;    }&#10;&#10;&#10;    int equal(int l, int r, int k) {&#10;        if (l &gt; r || k &lt; low || k &gt; high) return 0;&#10;        if (low == high) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        if (k &lt;= mid) return left-&gt;equal(lb + 1, rb, k);&#10;        return right-&gt;equal(l - lb, r - rb, k);&#10;    }&#10;&#10;    int smaller(int l, int r, int k) {&#10;        if (l &gt; r || k &lt;= low) return 0;&#10;        if (k &gt; high) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;smaller(lb + 1, rb, k) + right-&gt;smaller(l - lb, r - rb, k);&#10;    }&#10;&#10;    int smaller_equal(int l, int r, int k) {&#10;        if (l &gt; r || k &lt; low) return 0;&#10;        if (k &gt;= high) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;smaller_equal(lb + 1, rb, k) + right-&gt;smaller_equal(l - lb, r - rb, k);&#10;    }&#10;&#10;    int bigger(int l, int r, int k) {&#10;        if (l &gt; r || k &gt;= high) return 0;&#10;        if (k &lt; low) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;bigger(lb + 1, rb, k) + right-&gt;bigger(l - lb, r - rb, k);&#10;    }&#10;&#10;    int bigger_equal(int l, int r, int k) {&#10;        if (l &gt; r || k &gt; high) return 0;&#10;        if (k &lt;= low) return r - l + 1;&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        int mid = (low + high) &gt;&gt; 1;&#10;        return left-&gt;bigger_equal(lb + 1, rb, k) + right-&gt;bigger_equal(l - lb, r - rb, k);&#10;    }&#10;&#10;    int kth(int l, int r, int k) {&#10;        if (l &gt; r) return -1;&#10;        if (r - l + 1 &lt; k)&#10;            throw runtime_error(&quot;kth element doesn't exist&quot;);&#10;        if (low == high) return low;&#10;        int left_part = freq[r] - freq[l - 1];&#10;        int lb = freq[l - 1], rb = freq[r];&#10;        if (k &lt;= left_part) return left-&gt;kth(lb + 1, rb, k);&#10;        return right-&gt;kth(l - lb, r - rb, k - left_part);&#10;    }&#10;&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".BitBor" value="template&lt;i32 bitCount&gt;&#10;struct DynamicBitBor {&#10;    struct vertex {&#10;        i32 next[2]{};&#10;        i32 cnt;&#10;&#10;        vertex() {&#10;            next[0] = next[1] = -1;&#10;            cnt = 0;&#10;        }&#10;    };&#10;    vector&lt;vertex&gt; bor;&#10;    void createVertex() {&#10;        bor.emplace_back();&#10;    }&#10;&#10;    void addToVertex(i32 v, i32 x) {&#10;        createVertex();&#10;        bor[v].next[x] = bor.size() - 1;&#10;    }&#10;&#10;public:&#10;    DynamicBitBor() {&#10;        bor.emplace_back();&#10;    }&#10;&#10;    void insert(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt++;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            if (bor[v].next[x] == -1) {&#10;                addToVertex(v, x);&#10;            }&#10;            v = bor[v].next[x];&#10;            bor[v].cnt++;&#10;        }&#10;    }&#10;&#10;    void remove(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt--;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            v = bor[v].next[x];&#10;            bor[v].cnt--;&#10;        }&#10;        bor[v].removeTerminal();&#10;    }&#10;    int countPref(int pref, int sz) {&#10;        int v = 0;&#10;        for (int i = bitCount - 1; i &gt;= bitCount - sz; i--) {&#10;            int bit = bit(pref, i);&#10;            if (bor[v].next[bit] == -1) {&#10;                return 0;&#10;            }&#10;            v = bor[v].next[bit];&#10;        }&#10;        return bor[v].cnt;&#10;    }&#10;&#10;    int count(int value) {&#10;        return countPref(value, bitCount);&#10;    }&#10;&#10;    bool contains(int value) {&#10;        return count(value) &gt; 0;&#10;    }&#10;&#10;    void clear() {&#10;        bor.clear();&#10;        bor.emplace_back();&#10;    }&#10;&#10;&#10;    int maxXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit ^ 1] != -1) {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            } else {&#10;                v = bor[v].next[bit];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int minXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit] != -1) {&#10;                v = bor[v].next[bit];&#10;            } else {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int size() {&#10;        return bor[0].cnt;&#10;    }&#10;};&#10;&#10;&#10;template&lt;i32 bitCount, int maxSize&gt;&#10;struct StaticBitBor {&#10;    struct vertex {&#10;        i32 next[2]{};&#10;        i32 cnt;&#10;&#10;        vertex() {&#10;            next[0] = next[1] = -1;&#10;            cnt = 0;&#10;        }&#10;    };&#10;    vertex bor[maxSize];&#10;    int ptr = 0;&#10;    void createVertex() {&#10;        bor[ptr++] = vertex();&#10;    }&#10;&#10;    void addToVertex(i32 v, i32 x) {&#10;        createVertex();&#10;        bor[v].next[x] = ptr - 1;&#10;    }&#10;&#10;public:&#10;    StaticBitBor() {&#10;        createVertex();&#10;    }&#10;&#10;    void insert(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt++;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            if (bor[v].next[x] == -1) {&#10;                addToVertex(v, x);&#10;            }&#10;            v = bor[v].next[x];&#10;            bor[v].cnt++;&#10;        }&#10;    }&#10;&#10;    void remove(int value) {&#10;        i32 v = 0;&#10;        bor[v].cnt--;&#10;        for (int bitId = bitCount - 1; bitId &gt;= 0; bitId--) {&#10;            int x = bit(value, bitId);&#10;            v = bor[v].next[x];&#10;            bor[v].cnt--;&#10;        }&#10;        bor[v].removeTerminal();&#10;    }&#10;    int countPref(int pref, int sz) {&#10;        int v = 0;&#10;        for (int i = bitCount - 1; i &gt;= bitCount - sz; i--) {&#10;            int bit = bit(pref, i);&#10;            if (bor[v].next[bit] == -1) {&#10;                return 0;&#10;            }&#10;            v = bor[v].next[bit];&#10;        }&#10;        return bor[v].cnt;&#10;    }&#10;&#10;    int count(int value) {&#10;        return countPref(value, bitCount);&#10;    }&#10;&#10;    bool contains(int value) {&#10;        return count(value) &gt; 0;&#10;    }&#10;&#10;    void clear() {&#10;        ptr = 0;&#10;        createVertex();&#10;    }&#10;&#10;&#10;    int maxXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit ^ 1] != -1) {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            } else {&#10;                v = bor[v].next[bit];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int minXor(int value) {&#10;        int v = 0;&#10;        int ans = 0;&#10;        for (int i = bitCount - 1; i &gt;= 0; i--) {&#10;            int bit = bit(value, i);&#10;            if (bor[v].next[bit] != -1) {&#10;                v = bor[v].next[bit];&#10;            } else {&#10;                ans = set_bit(ans, i);&#10;                v = bor[v].next[bit ^ 1];&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    int size() {&#10;        return bor[0].cnt;&#10;    }&#10;};&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".hullTrick" value="struct line {&#10;    float k{}, b{};&#10;    line() = default;&#10;    line(int k, int b) : k(k), b(b) {}&#10;    float operator()(float x) const {&#10;        return k * x + b;&#10;    }&#10;};&#10;&#10;float cross(line l1, line l2) {&#10;    return (l2.b - l1.b) / (l1.k - l2.k);&#10;}&#10;&#10;struct HullTrickMin {&#10;    deque&lt;line&gt; lines;&#10;&#10;    void addLine(line l) {&#10;        while (len(lines) &gt;= 2) {&#10;            line l1 = lines[len(lines) - 2];&#10;            line l2 = lines[len(lines) - 1];&#10;            if (cross(l1, l2) &gt; cross(l2, l)) {&#10;                lines.pop_back();&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;        lines.push_back(l);&#10;    }&#10;&#10;    //n*log(n)&#10;    float getMin(float x) {&#10;        int l = 0, r = len(lines) - 1;&#10;        while (l &lt; r) {&#10;            int m = (l + r) / 2;&#10;            if (lines[m](x) &gt; lines[m + 1](x)) {&#10;                l = m + 1;&#10;            } else {&#10;                r = m;&#10;            }&#10;        }&#10;        return lines[l](x);&#10;    }&#10;};&#10;&#10;struct HullTrickMax {&#10;    vector&lt;line&gt; lines;&#10;&#10;    // Helper function to check if a line is redundant&#10;    static bool isRedundant(const line &amp;l1, const line &amp;l2, const line &amp;l3) {&#10;        return cross(l1, l3) &lt;= cross(l1, l2);&#10;    }&#10;&#10;    // Add a line to the convex lines&#10;    void addLine(line l) {&#10;        while (lines.size() &gt;= 2 &amp;&amp; isRedundant(lines[len(lines) - 2], lines[len(lines) - 1], l)) {&#10;            lines.pop_back();&#10;        }&#10;        lines.push_back(l);&#10;    }&#10;&#10;    // Get the maximum value for a given x coordinate&#10;    float getMax(float x) {&#10;        int left = 0, right = len(lines) - 1;&#10;        while (left &lt; right) {&#10;            int mid = (left + right) / 2;&#10;            if (lines[mid](x) &lt; lines[mid + 1](x))&#10;                left = mid + 1;&#10;            else&#10;                right = mid;&#10;        }&#10;        return lines[left](x);&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".rand" value="#ifdef LOCAL&#10;mt19937 randEngine(0);&#10;#else&#10;mt19937 randEngine(chrono::steady_clock::now().time_since_epoch().count());&#10;#endif&#10;&#10;int randInt(int l, int r) {&#10;    return uniform_int_distribution&lt;int&gt;(l, r)(randEngine);&#10;}&#10;float randFloat(float l, float r) {&#10;    return uniform_real_distribution&lt;float&gt;(l, r)(randEngine);&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".hashing" value="struct Hashing {&#10;    pair&lt;int, int&gt; p = {31, 239};&#10;&#10;    int md = 1e9 + 9;&#10;    vector&lt;pair&lt;int, int&gt;&gt; p_pow;&#10;    vector&lt;pair&lt;int, int&gt;&gt; p_inv;&#10;    vector&lt;pair&lt;int, int&gt;&gt; h;&#10;    [[nodiscard]] int binpow(int a, int n) const {&#10;        int res = 1;&#10;        while (n) {&#10;            if (n &amp; 1)&#10;                res = (res * a) % md;&#10;            a = (a * a) % md;&#10;            n &gt;&gt;= 1;&#10;        }&#10;        return res;&#10;    }&#10;&#10;    explicit Hashing(const string &amp;s) {&#10;        int n = len(s);&#10;        p_pow.resize(n);&#10;        p_inv.resize(n);&#10;        h.resize(n);&#10;        p_pow[0] = {1, 1};&#10;        p_inv[0] = {1, 1};&#10;        for (int i = 1; i &lt; n; ++i) {&#10;            p_pow[i] = {p_pow[i - 1].first * p.first % md, p_pow[i - 1].second * p.second % md};&#10;            p_inv[i] = {binpow(p_pow[i].first, md - 2), binpow(p_pow[i].second, md - 2)};&#10;        }&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            h[i] = {((s[i] - 'a' + 1) * p_pow[i].first % md), ((s[i] - 'a' + 1) * p_pow[i].second % md)};&#10;            if (i)&#10;                h[i] = {(h[i].first + h[i - 1].first) % md, (h[i].second + h[i - 1].second) % md};&#10;        }&#10;    }&#10;&#10;    pair&lt;int,int&gt; get(int l, int r) {&#10;        if (r &lt; l)&#10;            return {0,0};&#10;        pair&lt;int, int&gt; res = h[r];&#10;        if (l)&#10;            res = {(res.first - h[l - 1].first + md) % md, (res.second - h[l - 1].second + md) % md};&#10;        res = {(res.first * p_inv[l].first) % md, (res.second * p_inv[l].second) % md};&#10;        return res;&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".convex" value="struct line {&#10;    int k, b;&#10;    line() : k(0), b(0) {}&#10;    line(int k, int b) : k(k), b(b) {}&#10;    int operator()(int x) const {&#10;        return k * x + b;&#10;    }&#10;};&#10;&#10;template&lt;typename comparer_func, typename compressor_func, typename validator_func&gt;&#10;struct LiChaoTree {&#10;    comparer_func comparer;&#10;    compressor_func compressor;&#10;    validator_func validator;&#10;    vector&lt;line&gt; tree;&#10;    int default_value{};&#10;    size_t sizeTree{};&#10;    void add_line(line l, int v, int tl, int tr) {&#10;        int tm = (tl + tr) &gt;&gt; 1;&#10;        bool left = comparer(l(compressor(tl)), tree[v](compressor(tl)));&#10;        bool mid = comparer(l(compressor(tm)), tree[v](compressor(tm)));&#10;        if (mid) {&#10;            swap(l, tree[v]);&#10;        }&#10;        if (tl == tr) {&#10;            return;&#10;        }&#10;        if (left != mid) {&#10;            add_line(l, v * 2, tl, tm);&#10;        } else {&#10;            add_line(l, v * 2 + 1, tm + 1, tr);&#10;        }&#10;    }&#10;&#10;    int func(int a, int b) {&#10;        if (comparer(a, b)) {&#10;            return a;&#10;        }&#10;        return b;&#10;    }&#10;&#10;&#10;    int get(int v, int tl, int tr, int x) {&#10;        if (tl == tr) {&#10;            return tree[v](x);&#10;        }&#10;        int tm = (tl + tr) &gt;&gt; 1;&#10;        if (x &lt;= tm) {&#10;            return func(tree[v](x), get(v * 2, tl, tm, x));&#10;        } else {&#10;            return func(tree[v](x), get(v * 2 + 1, tm + 1, tr, x));&#10;        }&#10;    }&#10;&#10;&#10;public:&#10;    LiChaoTree(int from, int to, int default_value_, comparer_func comparer, compressor_func compressor, validator_func validator) : comparer(comparer), compressor(std::move(compressor)), validator(validator) {&#10;        default_value = default_value_;&#10;        if (from &gt; to) {&#10;            swap(from, to);&#10;        }&#10;        sizeTree = to - from + 1;&#10;        tree.resize((sizeTree + 5) * 4, line(0, default_value));&#10;    }&#10;&#10;    void add_line(line l) {&#10;        add_line(l, 1, 0, sizeTree - 1);&#10;    }&#10;&#10;    int get(int x) {&#10;        if (!validator(x))&#10;            throw runtime_error(&quot;invalid x&quot;);&#10;        return get(1, 0, sizeTree - 1, compressor(x));&#10;    }&#10;};" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".lichao" value="//LiChaoTree start&#10;&#10;struct line {&#10;    int k, b;&#10;    line() : k(0), b(0) {}&#10;    line(int k, int b) : k(k), b(b) {}&#10;    int operator()(int x) const {&#10;        return k * x + b;&#10;    }&#10;};&#10;&#10;&#10;auto comparer = [](int a, int b) { return a &lt; b; };&#10;auto compressor = [](int a) { return a; };&#10;auto validator = [](int a) { return true; };&#10;&#10;vector&lt;line&gt; liChaoTree;&#10;int default_value{};&#10;size_t sizeTree{};&#10;//    res lines witch we have deleted&#10;void add_line(line l, int v, int tl, int tr, vector&lt;pair&lt;int, line&gt;&gt; &amp;changed) {&#10;    int tm = (tl + tr) &gt;&gt; 1;&#10;    bool left = comparer(l(compressor(tl)), liChaoTree[v](compressor(tl)));&#10;    bool mid = comparer(l(compressor(tm)), liChaoTree[v](compressor(tm)));&#10;    if (mid) {&#10;        swap(l, liChaoTree[v]);&#10;        changed.emplace_back(v, l);&#10;    }&#10;    if (tl == tr) {&#10;        return;&#10;    }&#10;    if (left != mid) {&#10;        add_line(l, v * 2, tl, tm, changed);&#10;    } else {&#10;        add_line(l, v * 2 + 1, tm + 1, tr, changed);&#10;    }&#10;}&#10;&#10;int func(int a, int b) {&#10;    if (comparer(a, b)) {&#10;        return a;&#10;    }&#10;    return b;&#10;}&#10;&#10;&#10;int get(int v, int tl, int tr, int x) {&#10;    if (tl == tr) {&#10;        return liChaoTree[v](x);&#10;    }&#10;    int tm = (tl + tr) &gt;&gt; 1;&#10;    if (x &lt;= compressor(tm)) {&#10;        return func(liChaoTree[v](x), get(v * 2, tl, tm, x));&#10;    } else {&#10;        return func(liChaoTree[v](x), get(v * 2 + 1, tm + 1, tr, x));&#10;    }&#10;}&#10;&#10;void init(int from, int to, int default_value_) {&#10;    default_value = default_value_;&#10;    if (from &gt; to) {&#10;        swap(from, to);&#10;    }&#10;    sizeTree = to - from + 1;&#10;    liChaoTree.resize((sizeTree + 5) * 4, line(0, default_value));&#10;}&#10;&#10;vector&lt;pair&lt;int, line&gt;&gt; add_line(line l) {&#10;    vector&lt;pair&lt;int, line&gt;&gt; res;&#10;    add_line(l, 1, 0, sizeTree - 1, res);&#10;    return res;&#10;}&#10;&#10;&#10;void forcePush(vector&lt;pair&lt;int, line&gt;&gt; &amp;changed) {&#10;    for (auto &amp;i: changed) {&#10;        liChaoTree[i.first] = i.second;&#10;    }&#10;    changed.clear();&#10;}&#10;&#10;int get(int x) {&#10;    if (!validator(x))&#10;        throw runtime_error(&quot;invalid x&quot;);&#10;    return get(1, 0, sizeTree - 1, compressor(x));&#10;}&#10;//LiChaoTree end" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".segmentTree" value="template&lt;typename T&gt;&#10;class setter {&#10;public:&#10;    T operator()(T a, T b) {&#10;        return b;&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;class minimum {&#10;public:&#10;    T operator()(T a, T b) {&#10;        if (a &lt; b) return a;&#10;        return b;&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;class maximum {&#10;public:&#10;    T operator()(T a, T b) {&#10;        if (a &gt; b) return a;&#10;        return b;&#10;    }&#10;};&#10;&#10;&#10;template&lt;typename T, size_t max_size, class Combiner, class Updater, auto identity&gt;&#10;class LazySegmentTree {&#10;private:&#10;    array&lt;T, 4 * max_size&gt; tree;&#10;    array&lt;T, 4 * max_size&gt; lazy;&#10;    array&lt;bool, 4 * max_size&gt; lazy_flag;&#10;    Combiner combiner;&#10;    Updater updater;&#10;    T identity_element = identity();&#10;    int n;&#10;    void push(int node, int l, int r) {&#10;        if (lazy_flag[node]) {&#10;            tree[node] = updater(tree[node], lazy[node]);&#10;            if (l != r) {&#10;                lazy[2 * node + 1] = updater(lazy[2 * node + 1], lazy[node]);&#10;                lazy[2 * node + 2] = updater(lazy[2 * node + 2], lazy[node]);&#10;                lazy_flag[2 * node + 1] = lazy_flag[2 * node + 2] = true;&#10;            }&#10;            lazy[node] = identity_element;&#10;            lazy_flag[node] = false;&#10;        }&#10;    }&#10;&#10;    void update(int node, int l, int r, int ql, int qr, T val) {&#10;        push(node, l, r);&#10;        if (l &gt; qr || r &lt; ql) {&#10;            return;&#10;        }&#10;        if (l &gt;= ql &amp;&amp; r &lt;= qr) {&#10;            lazy[node] = updater(lazy[node], val);&#10;            lazy_flag[node] = true;&#10;            push(node, l, r);&#10;            return;&#10;        }&#10;        int mid = (l + r) / 2;&#10;        update(2 * node + 1, l, mid, ql, qr, val);&#10;        update(2 * node + 2, mid + 1, r, ql, qr, val);&#10;        tree[node] = combiner(tree[2 * node + 1], tree[2 * node + 2]);&#10;    }&#10;&#10;    T get(int node, int l, int r, int ql, int qr) {&#10;        push(node, l, r);&#10;        if (l &gt; qr || r &lt; ql) {&#10;            return identity_element;&#10;        }&#10;        if (l &gt;= ql &amp;&amp; r &lt;= qr) {&#10;            return tree[node];&#10;        }&#10;        int mid = (l + r) / 2;&#10;        T left = get(2 * node + 1, l, mid, ql, qr);&#10;        T right = get(2 * node + 2, mid + 1, r, ql, qr);&#10;        return combiner(left, right);&#10;    }&#10;&#10;    void build(vector&lt;T&gt; &amp;v, int node, int l, int r) {&#10;        if (l == r) {&#10;            tree[node] = v[l];&#10;            return;&#10;        }&#10;        int mid = (l + r) / 2;&#10;        build(v, 2 * node + 1, l, mid);&#10;        build(v, 2 * node + 2, mid + 1, r);&#10;        tree[node] = combiner(tree[2 * node + 1], tree[2 * node + 2]);&#10;    }&#10;&#10;public:&#10;    LazySegmentTree() {&#10;        n = max_size;&#10;        fill(all(lazy_flag), false);&#10;        fill(all(tree), identity_element);&#10;        fill(all(lazy), identity_element);&#10;    }&#10;    void build(int _n) {&#10;        n = _n;&#10;        build(vect(n, identity_element), 0, 0, n - 1);&#10;    }&#10;    void build(vector&lt;T&gt; &amp;v) {&#10;        n = v.size();&#10;        build(v, 0, 0, n - 1);&#10;    }&#10;&#10;    void update(int l, int r, T val) {&#10;        update(0, 0, n - 1, l, r, val);&#10;    }&#10;&#10;    void update(int i, T val) {&#10;        update(0, 0, n - 1, i, i, val);&#10;    }&#10;&#10;    T get(int l, int r) {&#10;        return get(0, 0, n - 1, l, r);&#10;    }&#10;&#10;    T get(int i) {&#10;        return get(0, 0, n - 1, i, i);&#10;    }&#10;};&#10;int countr_zero(unsigned int n) {&#10;#ifdef _MSC_VER&#10;    unsigned long index;&#10;    _BitScanForward(&amp;index, n);&#10;    return index;&#10;#else&#10;    return __builtin_ctz(n);&#10;#endif&#10;}&#10;unsigned int bit_ceil(unsigned int n) {&#10;    unsigned int x = 1;&#10;    while (x &lt; (unsigned int) (n)) x *= 2;&#10;    return x;&#10;}&#10;&#10;template&lt;typename T, size_t max_size, class Combiner, class Updater, auto identity&gt;&#10;class SegmentTree {&#10;private:&#10;    vector&lt;T&gt; tree;&#10;    Combiner combiner;&#10;    Updater updater;&#10;    T identity_element = identity();&#10;    int __n, size, log;&#10;    void update(int k) { tree[k] = combiner(tree[2 * k], tree[2 * k + 1]); }&#10;&#10;public:&#10;    void build(vector&lt;T&gt; &amp;v) {&#10;        __n = len(v);&#10;        size = (int) bit_ceil(__n);&#10;        log = countr_zero((unsigned int) size);&#10;        tree.resize(2 * size, identity_element);&#10;        for (int i = 0; i &lt; __n; i++) {&#10;            tree[size + i] = v[i];&#10;        }&#10;        for (int i = size - 1; i &gt; 0; i--) {&#10;            update(i);&#10;        }&#10;    }&#10;&#10;    void update(int pos, T val) {&#10;        assert(0 &lt;= pos &amp;&amp; pos &lt; __n);&#10;        pos += size;&#10;        tree[pos] = updater(tree[pos], val);&#10;        for (int i = 1; i &lt;= log; i++) {&#10;            update(pos &gt;&gt; i);&#10;        }&#10;    }&#10;&#10;    T get(int l, int r) {&#10;        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt; __n);&#10;        l += size;&#10;        r += size;&#10;        r++;&#10;        T left = identity_element;&#10;        T right = identity_element;&#10;        while (l &lt; r) {&#10;            if (l &amp; 1) {&#10;                left = combiner(left, tree[l++]);&#10;            }&#10;            if (r &amp; 1) {&#10;                right = combiner(tree[--r], right);&#10;            }&#10;            l &gt;&gt;= 1;&#10;            r &gt;&gt;= 1;&#10;        }&#10;        return combiner(left, right);&#10;    }&#10;&#10;    T get(int pos) {&#10;        assert(0 &lt;= pos &amp;&amp; pos &lt; __n);&#10;        return tree[size + pos];&#10;    }&#10;    &#10;};&#10;&#10;&#10;int identity() {&#10;    return 0;&#10;}&#10;&#10;struct reverser {&#10;    int operator()(int a, int b) {&#10;        if (a == 1)&#10;            return 0;&#10;        return 1;&#10;    }&#10;};&#10;&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".lca" value="//lca&#10;&#10;vector&lt;int&gt; tin, tout;&#10;vector&lt;vector&lt;int&gt;&gt; ancestor;&#10;vector&lt;int&gt; dist;&#10;int timer;&#10;void buildLCA(int v, int p, int d) {&#10;    tin[v] = ++timer;&#10;    ancestor[v][0] = p;&#10;    dist[v] = d;&#10;    for (int i = 1; i &lt; ancestor[v].size(); ++i) {&#10;        ancestor[v][i] = ancestor[ancestor[v][i - 1]][i - 1];&#10;    }&#10;    for (int u: g[v]) {&#10;        if (u != p) {&#10;            buildLCA(u, v, d + 1);&#10;        }&#10;    }&#10;    tout[v] = ++timer;&#10;}&#10;bool isAncestor(int u, int v) {&#10;    return tin[u] &lt;= tin[v] &amp;&amp; tout[u] &gt;= tout[v];&#10;}&#10;&#10;int lca(int u, int v) {&#10;    if (isAncestor(u, v)) {&#10;        return u;&#10;    }&#10;    if (isAncestor(v, u)) {&#10;        return v;&#10;    }&#10;    for (int i = len(ancestor[u]) - 1; i &gt;= 0; --i) {&#10;        if (!isAncestor(ancestor[u][i], v)) {&#10;            u = ancestor[u][i];&#10;        }&#10;    }&#10;    return ancestor[u][0];&#10;}&#10;&#10;int getDist(int u, int v) {&#10;    return dist[u] + dist[v] - 2 * dist[lca(u, v)];&#10;}&#10;&#10;int getXAncestor(int v, int x) {&#10;    for (int i = len(ancestor[v]) - 1; i &gt;= 0; --i) {&#10;        if (x &gt;= pow2(i)) {&#10;            v = ancestor[v][i];&#10;            x -= pow2(i);&#10;        }&#10;    }&#10;    return v;&#10;}&#10;&#10;&#10;//lca" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".mo3d" value="struct query {&#10;    int l, r;&#10;    int t;&#10;    int id;&#10;};&#10;&#10;struct update {&#10;    int pos;&#10;    int val;&#10;    int prev;&#10;    int time;&#10;};&#10;vector&lt;int&gt; a;&#10;int blockSize;&#10;&#10;&#10;bool cmp(query &amp;x, query &amp;y) {&#10;    if (x.l / blockSize != y.l / blockSize)&#10;        return x.l / blockSize &lt; y.l / blockSize;&#10;    if (x.r / blockSize != y.r / blockSize)&#10;        return x.r / blockSize &lt; y.r / blockSize;&#10;    return x.t &lt; y.t;&#10;}&#10;&#10;&#10;int curL = 0, curR = -1;&#10;int curT = 0;&#10;int curAns = 0;&#10;int K;&#10;int M;&#10;vector&lt;int&gt; cnt;&#10;&#10;void add(int pos) {&#10;    if (cnt[a[pos]] == K - 1) {&#10;        curAns++;&#10;    }&#10;    if (cnt[a[pos]] == K) {&#10;        curAns--;&#10;    }&#10;    cnt[a[pos]]++;&#10;}&#10;void remove(int pos) {&#10;    if (cnt[a[pos]] == K + 1) {&#10;        curAns++;&#10;    }&#10;    if (cnt[a[pos]] == K) {&#10;        curAns--;&#10;    }&#10;    cnt[a[pos]]--;&#10;}&#10;&#10;void apply(int pos, int val) {&#10;    if (pos &gt;= curL &amp;&amp; pos &lt;= curR) {&#10;        remove(pos);&#10;        a[pos] = val;&#10;        add(pos);&#10;    } else {&#10;        a[pos] = val;&#10;    }&#10;}&#10;&#10;&#10;signed main() {&#10;    ios_base::sync_with_stdio(false);&#10;    cin.tie(nullptr);&#10;    cout.tie(nullptr);&#10;    int q;&#10;    int n;&#10;    cin &gt;&gt; n &gt;&gt; M &gt;&gt; q &gt;&gt; K;&#10;    cnt.resize(M + 1, 0);&#10;    a = vect(n, 0LL);&#10;    for (int i = 0; i &lt; n; i++) {&#10;        cin &gt;&gt; a[i];&#10;    }&#10;    auto aCP = a;&#10;    blockSize = pow(n, 2.0 / 3.0);&#10;    if (K == 0) {&#10;        curAns = M;&#10;    }&#10;    vector&lt;query&gt; queries;&#10;    vector&lt;update&gt; updates;&#10;    for (int i = 0; i &lt; q; i++) {&#10;        int type;&#10;        cin &gt;&gt; type;&#10;        if (type == 1) {&#10;            int l, r;&#10;            cin &gt;&gt; l &gt;&gt; r;&#10;            l--;&#10;            r--;&#10;            queries.push_back({l, r, len(updates), len(queries)});&#10;        } else {&#10;            int pos, val;&#10;            cin &gt;&gt; pos &gt;&gt; val;&#10;            pos--;&#10;            updates.push_back({pos, val, a[pos], len(updates)});&#10;            a[pos] = val;&#10;        }&#10;    }&#10;    a = aCP;&#10;    sort(all(queries), cmp);&#10;    vector&lt;int&gt; ans(len(queries));&#10;    for (auto [l, r, t, id]: queries) {&#10;        while (curT &lt; t) {&#10;            auto [pos, val, prev, time] = updates[curT];&#10;            apply(pos, val);&#10;            curT++;&#10;        }&#10;        while (curT &gt; t) {&#10;            curT--;&#10;            auto [pos, val, prev, time] = updates[curT];&#10;            apply(pos, prev);&#10;        }&#10;&#10;        while (curL &gt; l) {&#10;            curL--;&#10;            add(curL);&#10;        }&#10;        while (curR &lt; r) {&#10;            curR++;&#10;            add(curR);&#10;        }&#10;        while (curL &lt; l) {&#10;            remove(curL);&#10;            curL++;&#10;        }&#10;&#10;        while (curR &gt; r) {&#10;            remove(curR);&#10;            curR--;&#10;        }&#10;        ans[id] = curAns;&#10;    }&#10;    for (auto &amp;x: ans) {&#10;        cout &lt;&lt; x &lt;&lt; endl;&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".comb" value="template&lt;typename T&gt;&#10;struct Factorials {&#10;    vector&lt;T&gt; fact;&#10;    explicit Factorials(int n) {&#10;        fact.resize(n + 1);&#10;        fact[0] = 1;&#10;        for (int i = 1; i &lt;= n; ++i) {&#10;            fact[i] = fact[i - 1] * i;&#10;        }&#10;    }&#10;&#10;    T operator()(int n) {&#10;        return fact[n];&#10;    }&#10;};&#10;&#10;template&lt;typename T&gt;&#10;struct Catalans {&#10;    vector&lt;T&gt; cat;&#10;    explicit Catalans(int n) {&#10;        cat.resize(n + 1);&#10;        cat[0] = 1;&#10;        for (int i = 1; i &lt;= n; ++i) {&#10;            cat[i] = cat[i - 1] * (4 * i - 2) / (i + 1);&#10;        }&#10;    }&#10;&#10;    T operator()(int n) {&#10;        return cat[n];&#10;    }&#10;};&#10;&#10;Factorials&lt;mint&gt; fact(2e5 + 5);&#10;&#10;mint C(int n, int k) {&#10;    if (k &lt; 0 || k &gt; n) return 0;&#10;    return fact(n) / (fact(k) * fact(n - k));&#10;}&#10;&#10;mint A(int n, int k) {&#10;    if (k &lt; 0 || k &gt; n) return 0;&#10;    return fact(n) / fact(n - k);&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".point" value="template&lt;typename T&gt;&#10;struct Point {&#10;    T x, y;&#10;&#10;    Point() : x(0), y(0) {}&#10;    Point(T x, T y) : x(x), y(y) {}&#10;    explicit Point(pair&lt;T, T&gt; p) : x(p.first), y(p.second) {}&#10;    Point(const Point&lt;T&gt; &amp;p) : x(p.x), y(p.y) {}&#10;    Point(Point&lt;T&gt; &amp;&amp;p)  noexcept : x(p.x), y(p.y) {}&#10;    Point&lt;T&gt; &amp;operator=(const Point&lt;T&gt; &amp;p) {&#10;        x = p.x;&#10;        y = p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator=(Point&lt;T&gt; &amp;&amp;p) noexcept {&#10;        x = p.x;&#10;        y = p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator+=(const Point&lt;T&gt; &amp;p) {&#10;        x += p.x;&#10;        y += p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator-=(const Point&lt;T&gt; &amp;p) {&#10;        x -= p.x;&#10;        y -= p.y;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator*=(const T &amp;k) {&#10;        x *= k;&#10;        y *= k;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; &amp;operator/=(const T &amp;k) {&#10;        x /= k;&#10;        y /= k;&#10;        return *this;&#10;    }&#10;    Point&lt;T&gt; operator+(const Point&lt;T&gt; &amp;p) const {&#10;        return Point&lt;T&gt;(*this) += p;&#10;    }&#10;    Point&lt;T&gt; operator-(const Point&lt;T&gt; &amp;p) const {&#10;        return Point&lt;T&gt;(*this) -= p;&#10;    }&#10;    Point&lt;T&gt; operator*(const T &amp;k) const {&#10;        return Point&lt;T&gt;(*this) *= k;&#10;    }&#10;    Point&lt;T&gt; operator/(const T &amp;k) const {&#10;        return Point&lt;T&gt;(*this) /= k;&#10;    }&#10;    bool operator==(const Point&lt;T&gt; &amp;p) const {&#10;        return x == p.x &amp;&amp; y == p.y;&#10;    }&#10;    bool operator!=(const Point&lt;T&gt; &amp;p) const {&#10;        return x != p.x || y != p.y;&#10;    }&#10;    bool operator&lt;(const Point&lt;T&gt; &amp;p) const {&#10;        return x &lt; p.x || (x == p.x &amp;&amp; y &lt; p.y);&#10;    }&#10;    bool operator&gt;(const Point&lt;T&gt; &amp;p) const {&#10;        return x &gt; p.x || (x == p.x &amp;&amp; y &gt; p.y);&#10;    }&#10;    bool operator&lt;=(const Point&lt;T&gt; &amp;p) const {&#10;        return x &lt;= p.x || (x == p.x &amp;&amp; y &lt;= p.y);&#10;    }&#10;    bool operator&gt;=(const Point&lt;T&gt; &amp;p) const {&#10;        return x &gt;= p.x || (x == p.x &amp;&amp; y &gt;= p.y);&#10;    }&#10;    friend istream &amp;operator&gt;&gt;(istream &amp;is, Point&lt;T&gt; &amp;p) {&#10;        is &gt;&gt; p.x &gt;&gt; p.y;&#10;        return is;&#10;    }&#10;    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Point&lt;T&gt; &amp;p) {&#10;        os &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y;&#10;        return os;&#10;    }&#10;};&#10;typedef Point&lt;int&gt; ipoint;&#10;typedef Point&lt;float&gt; fpoint;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".factorize" value="vec&lt;int&gt; factorize(int x) {&#10;    vec&lt;int&gt; ans;&#10;    for (int i = 2; i * i &lt;= x; ++i) {&#10;        if (x % i == 0) {&#10;            ans.push_back(i);&#10;            while (x % i == 0) {&#10;                x /= i;&#10;            }&#10;        }&#10;    }&#10;    if (x &gt; 1) {&#10;        ans.push_back(x);&#10;    }&#10;    return ans;&#10;}&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".dividers" value="vec&lt;int&gt; dividers(int x) {&#10;    if (x == 1) return {};&#10;    vec&lt;int&gt; ans;&#10;    for (int i = 1; i * i &lt;= x; ++i) {&#10;        if (x % i == 0) {&#10;            ans.push_back(i);&#10;            if (i * i != x) ans.push_back(x / i);&#10;        }&#10;    }&#10;    return ans;&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".scc" value="int n;&#10;graph&lt;int&gt; g;&#10;graph&lt;int&gt; g_rev;&#10;&#10;graph&lt;int&gt; condensation;&#10;vec&lt;bool&gt; used;&#10;vec&lt;int&gt; ordered;&#10;vec&lt;int&gt; comp;&#10;vec&lt;vec&lt;int&gt;&gt; components;&#10;&#10;void top_sort(int v) {&#10;    used[v] = true;&#10;    for (auto u: g[v]) {&#10;        if (!used[u]) {&#10;            top_sort(u);&#10;        }&#10;    }&#10;    ordered.push_back(v);&#10;}&#10;&#10;void build_comp(int v, int k) {&#10;    used[v] = true;&#10;    comp[v] = k;&#10;    for (auto u: g_rev[v]) {&#10;        if (!used[u]) {&#10;            build_comp(u, k);&#10;        }&#10;    }&#10;}&#10;&#10;void add_edge(int v, int u) {&#10;    g[v].push_back(u);&#10;    g_rev[u].push_back(v);&#10;}&#10;&#10;void init() {&#10;    g = new_graph&lt;int&gt;(n);&#10;    g_rev = new_graph&lt;int&gt;(n);&#10;    used = vect&lt;bool&gt;(n, false);&#10;    ordered.clear();&#10;    comp = vect&lt;int&gt;(n, -1);&#10;    components.clear();&#10;    condensation.clear();&#10;}&#10;&#10;int build_components() {&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        if (!used[i]) {&#10;            top_sort(i);&#10;        }&#10;    }&#10;    rev(ordered);&#10;    used = vect&lt;bool&gt;(n, false);&#10;    int k = 0;&#10;    for (auto v: ordered) {&#10;        if (!used[v]) {&#10;            build_comp(v, k++);&#10;        }&#10;    }&#10;    components = vect&lt;vec&lt;int&gt;&gt;(k, vec&lt;int&gt;());&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        components[comp[i]].push_back(i);&#10;    }&#10;    return k;&#10;}&#10;&#10;void build_condensation() {&#10;    int k = len(components);&#10;    vec&lt;set&lt;int&gt;&gt; cond(k);&#10;    for (int i = 0; i &lt; k; ++i) {&#10;        for (auto v: components[i]) {&#10;            for (auto u: g[v]) {&#10;                if (comp[u] != i) {&#10;                    cond[i].insert(comp[u]);&#10;                }&#10;            }&#10;        }&#10;    }&#10;    condensation = new_graph&lt;int&gt;(k);&#10;    for (int i = 0; i &lt; k; ++i) {&#10;        for (auto u: cond[i]) {&#10;            condensation[i].push_back(u);&#10;        }&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name=".centroidDecomp" value="struct edge {&#10;    int to, w;&#10;};&#10;&#10;graph&lt;edge&gt; g;&#10;vec&lt;int&gt; sizes;&#10;vec&lt;bool&gt; removed;&#10;&#10;void calc_sizes(int v, int p) {&#10;    sizes[v] = 1;&#10;    for (auto [u, w]: g[v]) {&#10;        if (u == p) continue;&#10;        if (removed[u]) continue;&#10;        calc_sizes(u, v);&#10;        sizes[v] += sizes[u];&#10;    }&#10;}&#10;&#10;int n;&#10;int sz = 0;&#10;&#10;int find_centroid(int v, int p) {&#10;    for (auto [u, w]: g[v]) {&#10;        if (u == p) continue;&#10;        if (removed[u]) continue;&#10;        if (sizes[u] &gt; sz / 2) return find_centroid(u, v);&#10;    }&#10;    return v;&#10;}&#10;&#10;vec&lt;vec&lt;int&gt;&gt; centroidParents;&#10;&#10;void fill_centroid(int v, int p, int c) {&#10;    centroidParents[c].push_back(v);&#10;    for (auto [u, w]: g[v]) {&#10;        if (u == p) continue;&#10;        if (removed[u]) continue;&#10;        fill_centroid(u, v, c);&#10;    }&#10;}&#10;&#10;void calc_stat(int centroid){&#10;    &#10;}&#10;&#10;&#10;void decompose(int v) {&#10;    calc_sizes(v, -1);&#10;    sz = sizes[v];&#10;    int centroid = find_centroid(v, -1);&#10;    fill_centroid(v, -1, centroid);&#10;    calc_stat(centroid);&#10;    removed[centroid] = true;&#10;    for (auto [u, w]: g[centroid]) {&#10;        if (removed[u]) continue;&#10;        decompose(u);&#10;    }&#10;}" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>